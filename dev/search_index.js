var documenterSearchIndex = {"docs":
[{"location":"examples/B3a/#Basic/B3a-Example","page":"Basic/B3a Example","title":"Basic/B3a Example","text":"This example simulates schematically a Positron Emitted Tomography system. It is equivalent to the B3a example in Geant4 but re-written with a new more Julia friendly interface. See README file for the example.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/B3a/#Table-of-contents","page":"Basic/B3a Example","title":"Table of contents","text":"Pages = [\"B3a.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/B3a/#Loading-the-necessary-Julia-modules","page":"Basic/B3a Example","title":"Loading the necessary Julia modules","text":"Load the Geant4 and Geant4.SystemOfUnits modules.\n\nusing Geant4\nusing Geant4.SystemOfUnits:  cm, cm3, mm, pGy, eplus, keV, g, eV","category":"section"},{"location":"examples/B3a/#Define-Detector-Parameters-struct","page":"Basic/B3a Example","title":"Define Detector Parameters struct","text":"The B3Detector structure is defined with the default detector parameters. We include the B3Detector.jl file not to clutter the example.\n\ninclude(joinpath(@__DIR__, \"B3Detector.jl\"))","category":"section"},{"location":"examples/B3a/#Defile-Physics-List","page":"Basic/B3a Example","title":"Defile Physics List","text":"The B3aPhysics structure is defined with the default physics list for the B3a example. It is composed of the default physics, the electromagnetic physics and the radioactive decay physics. The RegisterPhysics function is used to register the physics processes in the physics list. The move! function is used to move the ownership of the physics list to the G4VUserPhysicsList type. It returns a pointer to the physics list.\n\nstruct B3aPhysics <: G4VUserPhysicsList\n    function B3aPhysics(verbose)\n        pl = G4VModularPhysicsList()\n        RegisterPhysics(pl, move!(G4DecayPhysics(verbose)))            ## Default physics\n        RegisterPhysics(pl, move!(G4EmStandardPhysics(verbose)))       ## EM physics\n        RegisterPhysics(pl, move!(G4RadioactiveDecayPhysics(verbose))) ## Radioactive decay\n        return pl\n    end\nend","category":"section"},{"location":"examples/B3a/#Define-Primary-Particle-Generator","page":"Basic/B3a Example","title":"Define Primary Particle Generator","text":"This is the primary particle generator for the B3a example. It generates a ion beam of 0 energy from a random position inside a cube shaped volume. The user parameter type B3aGeneratorData is defined with the default generator parameters. The functions _gen and _init are defined to generate the primary particles and to initialize the generator, respectively. Finally, the B3aGenerator function is defined to instantiate an instance of the G4JLPrimaryGenerator type.\n\n@with_kw mutable struct B3aGeneratorData <: G4JLGeneratorData\n    gun::Union{Nothing, CxxPtr{G4ParticleGun}} = nothing\n    ion::Union{Nothing, CxxPtr{G4ParticleDefinition}} = nothing\n    Z::Int64 = 9\n    A::Int64 = 18\n    ionCharge::Float64 = 0eplus\n    excitEnergy::Float64 = 0keV\n    position::G4ThreeVector = G4ThreeVector(4cm,4cm,4cm)\n    direction::G4ThreeVector = G4ThreeVector(1,0,0)\nend\nfunction B3aGenerator(;kwargs...)\n    data = B3aGeneratorData(;kwargs...)\n    function _init(data::B3aGeneratorData, ::Any)\n        gun = data.gun = move!(G4ParticleGun())\n        SetParticleMomentumDirection(gun, G4ThreeVector(1,0,0))\n        SetParticleEnergy(gun, 1eV)\n    end\n    function _gen(evt::G4Event, data::B3aGeneratorData)::Nothing\n        if isnothing(data.ion)  # late initialize (after physics processes)\n            ion = data.ion = GetIon(data.Z, data.A, data.excitEnergy)\n            SetParticleDefinition(data.gun, ion)\n            SetParticleCharge(data.gun, data.ionCharge)\n        end\n        position = data.position + G4ThreeVector((rand()-0.5)*1cm, (rand()-0.5)*1cm, (rand()-0.5)*1cm)\n        SetParticlePosition(data.gun, position)\n        GeneratePrimaryVertex(data.gun, CxxPtr(evt))\n    end\n    G4JLPrimaryGenerator(\"B3aGenerator\", data; init_method=_init, generate_method=_gen)\nend;","category":"section"},{"location":"examples/B3a/#Define-Simulation-Data","page":"Basic/B3a Example","title":"Define Simulation Data","text":"The SimDataB3a structure is defined to collect the simulation data during the execution of a run. The add! function is defined to add (i.e. reduce) the data from one instance to another when running in multi-threading mode. In this case we have only two counters for the number of good events and the sum of the dose of the patient.\n\nmutable struct SimDataB3a <: G4JLSimulationData\n    ##---Run data\n    goodEvents::Int64\n    sumDose::Float64\n    SimDataB3a() = new(0,0)\nend\nfunction add!(x::SimDataB3a, y::SimDataB3a)\n    x.goodEvents += y.goodEvents\n    x.sumDose += y.sumDose\nend\n\nadd! (generic function with 1 method)","category":"section"},{"location":"examples/B3a/#Define-Sensitive-Detectors","page":"Basic/B3a Example","title":"Define Sensitive Detectors","text":"The B3a example has two sensitive detectors. One is for the crystal and the other for the patient. Each one has an associated data structure. The CrystalData structure is defined to collect the energy deposited in each crystal. The PatientData structure is defined to collect the dose in the patient.\n\n# Crystal sensitive detector\nstruct CrystalData <: G4JLSDData\n    edep::Dict{Int64,Float64} # (CopyNo, Edep)\n    CrystalData() = new(Dict{Int64,Float64}())\nend\nfunction c_initialize(::G4HCofThisEvent, data::CrystalData)::Nothing\n    empty!(data.edep)\n    return\nend\nfunction c_processHits(step::G4Step, ::G4TouchableHistory, data::CrystalData)::Bool\n    edep = step |> GetTotalEnergyDeposit\n    edep <  0. && return false\n    copy = step |> GetPreStepPoint |> GetTouchable |> GetCopyNumber\n    data.edep[copy] = haskey(data.edep, copy) ? data.edep[copy] + edep : edep\n    return true\nend\n# Create SD instance\ncrystalSD = G4JLSensitiveDetector(\"CrystalSD\", CrystalData();          ## SD name an associated data are mandatory\n                                   processhits_method=c_processHits,   ## process hist method (also mandatory)\n                                   initialize_method=c_initialize);    ## initialize method\n# Patient Sensitive detector\nmutable struct PatientData <: G4JLSDData\n    dose::Float64\n    PatientData() = new(0)\nend\nfunction p_initialize(::G4HCofThisEvent, data::PatientData)::Nothing\n    data.dose = 0\n    return\nend\nfunction p_processHits(step::G4Step, ::G4TouchableHistory, data::PatientData)::Bool\n    edep = step |> GetTotalEnergyDeposit\n    edep <=  0. && return false\n    volume  = step |> GetPreStepPoint |> GetTouchable |> GetSolid |> GetCubicVolume\n    density = step |> GetPreStepPoint |> GetMaterial |> GetDensity\n    data.dose += edep /(density * volume)\n    return true\nend\n# Create SD instance\npatientSD = G4JLSensitiveDetector(\"PatientSD\", PatientData();           ## SD name an associated data are mandatory\n                                   processhits_method=p_processHits,    ## process hist method (also mandatory)\n                                   initialize_method=p_initialize);     ## initialize method","category":"section"},{"location":"examples/B3a/#User-Actions","page":"Basic/B3a Example","title":"User Actions","text":"We define the user actions for the B3a example. The beginrun function is defined to initialize the simulation data. The endrun function is defined to print the results of the simulation. The endevent function is defined to count the number of good events and to accumulate the dose in the patient. The stacking action is defined to kill the neutrinos and to keep the primary particles.\n\nfunction beginrun(run::G4Run, app::G4JLApplication)::Nothing\n    data = getSIMdata(app)\n    data.goodEvents = 0\n    data.sumDose = 0.\n    nothing\nend\nμGy = Geant4.SystemOfUnits.gray/1e6\n\nfunction endrun(run::G4Run, app::G4JLApplication)::Nothing\n    partName = app.generator.data.gun |> GetParticleDefinition |> GetParticleName |> String\n    ##---end run action is called for each workwer thread and the master one\n    if G4Threading!G4GetThreadId() < 0\n        data = app.simdata[1]\n        ##---This is the master thread, so we need to add all the simuation results-----------------\n        for d in app.simdata[2:end]\n            add!(data, d)\n        end\n        noEvents = run |> GetNumberOfEvent\n        G4JL_println(\"\"\"\n                     --------------------End of Run------------------------------\n                      The run was $noEvents $partName Nb of 'good' e+ annihilations: $(data.goodEvents)\n                      Total dose in patient : $(data.sumDose/pGy) pGy\n                     ------------------------------------------------------------\n                     \"\"\")\n    end\nend\n\nfunction endevent(evt::G4Event, app::G4JLApplication)\n    edep = getSDdata(app, \"CrystalSD\").edep\n    dose = getSDdata(app, \"PatientSD\").dose\n    data = getSIMdata(app)\n    if count(>(500keV), values(edep)) == 2\n        data.goodEvents += 1\n    end\n    data.sumDose += dose\n    return\nend\n\nlet G4NeutrinoE, first=true\nglobal function stacking(trk::G4Track, app::G4JLApplication)::G4ClassificationOfNewTrack\n    if first  ## emulation of C++ static variable\n        G4NeutrinoE = FindParticle(\"nu_e\")\n        first = false\n    end\n    (trk |> GetParentID) == 0 && return fUrgent               ## keep primary particle\n    (trk |> GetDefinition) == G4NeutrinoE && return fKill     ## kill neutrino\n    return fUrgent\nend\nend;","category":"section"},{"location":"examples/B3a/#Create-the-Application","page":"Basic/B3a Example","title":"Create the Application","text":"app = G4JLApplication(; detector = B3Detector(),                      ## detector with parameters\n                        simdata = SimDataB3a(),                       ## simulation data structure\n                        generator = B3aGenerator(),                   ## primary particle generator\n                        nthreads = 0,                                 ## # of threads (0 = no MT)\n                        physics_type = B3aPhysics,                    ## what physics list to instantiate\n                        #evtdisplay =  display,                       ## set event display\n                        endeventaction_method = endevent,             ## end-event action (fill histograms per event)\n                        beginrunaction_method = beginrun,             ## begin run action\n                        endrunaction_method = endrun,                 ## end run action\n                        stackaction_method = stacking,                ## track classification action\n                        sdetectors = [\"CrystalLV+\" => crystalSD,\n                                      \"PatientLV\" => patientSD]       ## mapping of LVs to SDs (+ means multiple LVs with same name)\n                      );\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\n","category":"section"},{"location":"examples/B3a/#Configure,-Initialize","page":"Basic/B3a Example","title":"Configure, Initialize","text":"configure(app)\ninitialize(app)\n\ncryst_mat = CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4Material}(Ptr{Geant4.G4Material}(0x000000003ffe1a20))\nChecking overlaps for volume crystal:0 (G4Box) ... OK! \nChecking overlaps for volume crystal:1 (G4Box) ... OK! \nChecking overlaps for volume crystal:2 (G4Box) ... OK! \nChecking overlaps for volume crystal:3 (G4Box) ... OK! \nChecking overlaps for volume crystal:4 (G4Box) ... OK! \nChecking overlaps for volume crystal:5 (G4Box) ... OK! \nChecking overlaps for volume crystal:6 (G4Box) ... OK! \nChecking overlaps for volume crystal:7 (G4Box) ... OK! \nChecking overlaps for volume crystal:8 (G4Box) ... OK! \nChecking overlaps for volume crystal:9 (G4Box) ... OK! \nChecking overlaps for volume crystal:10 (G4Box) ... OK! \nChecking overlaps for volume crystal:11 (G4Box) ... OK! \nChecking overlaps for volume crystal:12 (G4Box) ... OK! \nChecking overlaps for volume crystal:13 (G4Box) ... OK! \nChecking overlaps for volume crystal:14 (G4Box) ... OK! \nChecking overlaps for volume crystal:15 (G4Box) ... OK! \nChecking overlaps for volume crystal:16 (G4Box) ... OK! \nChecking overlaps for volume crystal:17 (G4Box) ... OK! \nChecking overlaps for volume crystal:18 (G4Box) ... OK! \nChecking overlaps for volume crystal:19 (G4Box) ... OK! \nChecking overlaps for volume crystal:20 (G4Box) ... OK! \nChecking overlaps for volume crystal:21 (G4Box) ... OK! \nChecking overlaps for volume crystal:22 (G4Box) ... OK! \nChecking overlaps for volume crystal:23 (G4Box) ... OK! \nChecking overlaps for volume crystal:24 (G4Box) ... OK! \nChecking overlaps for volume crystal:25 (G4Box) ... OK! \nChecking overlaps for volume crystal:26 (G4Box) ... OK! \nChecking overlaps for volume crystal:27 (G4Box) ... OK! \nChecking overlaps for volume crystal:28 (G4Box) ... OK! \nChecking overlaps for volume crystal:29 (G4Box) ... OK! \nChecking overlaps for volume crystal:30 (G4Box) ... OK! \nChecking overlaps for volume crystal:31 (G4Box) ... OK! \nChecking overlaps for volume ring:0 (G4Tubs) ... OK! \nChecking overlaps for volume ring:1 (G4Tubs) ... OK! \nChecking overlaps for volume ring:2 (G4Tubs) ... OK! \nChecking overlaps for volume ring:3 (G4Tubs) ... OK! \nChecking overlaps for volume ring:4 (G4Tubs) ... OK! \nChecking overlaps for volume ring:5 (G4Tubs) ... OK! \nChecking overlaps for volume ring:6 (G4Tubs) ... OK! \nChecking overlaps for volume ring:7 (G4Tubs) ... OK! \nChecking overlaps for volume ring:8 (G4Tubs) ... OK! \nChecking overlaps for volume Detector:0 (G4Tubs) ... OK! \nChecking overlaps for volume Patient:0 (G4Tubs) ... OK! \n","category":"section"},{"location":"examples/B3a/#Run-the-simulation","page":"Basic/B3a Example","title":"Run the simulation","text":"Lets run for 10,000 events and see the results.\n\nbeamOn(app, 10000)\n\n# ui`/tracking/verbose 0`\n\n======================================================================\n======          Radioactive Decay Physics Parameters           =======\n======================================================================\nmin MeanLife (from G4NuclideTable)                1 ns \nMax life time (from G4DeexPrecoParameters)        1000 ps \nInternal e- conversion flag                       1\nStored internal conversion coefficients           1\nEnabled atomic relaxation mode                    1\nEnable correlated gamma emission                  0\nMax 2J for sampling of angular correlations       10\nAtomic de-excitation enabled                      1\nAuger electron emission enabled                   1\nCheck EM cuts disabled for atomic de-excitation   1\nUse Bearden atomic level energies                 0\nUse ANSTO fluorescence model                      0\nThreshold for very long decay time at rest        1 y  \n======================================================================\n\n====================================================================\n                  HADRONIC PROCESSES SUMMARY (verbose level 1)\n-------------------------------------------------------------------------\n                           Hadronic Processes for GenericIon\n  Process: RadioactiveDecay\n--------------------End of Run------------------------------\n The run was 10000 F18 Nb of 'good' e+ annihilations: 1273\n Total dose in patient : 306.93869584298466 pGy\n------------------------------------------------------------\n\n","category":"section"},{"location":"examples/B3a/#Visualize-the-detector-geometry","page":"Basic/B3a Example","title":"Visualize the detector geometry","text":"Load the needed modules for visualization\n\nusing CairoMakie ## to force loading G4Vis extension\nimport DisplayAs: PNG\n\nDisplay the detector geometry\n\nworld = GetVolume(\"World\")\nimg = draw(world[])\nPNG(img)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/RE03/#Extended/RE03-Example","page":"Extended/RE03 Example","title":"Extended/RE03 Example","text":"This example demonstrates how to use UI-command base scoring. Its create parallel world(s) for defining scoring mesh(es).\n\nDue to some performance overhead, this functionality is not provided by default. To enable it, you need to set the parameter scores in G4JLApplication with a list of scorers\n\nThe geometry consists of one water box in the world volume filled by air. Particle gun shoots a gamma into the water box. The physics list is taken from referenced physics-list FTFP_BERT` in Geant4.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/RE03/#Table-of-contents","page":"Extended/RE03 Example","title":"Table of contents","text":"Pages = [\"RE03.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/RE03/#Loading-the-necessary-Julia-modules","page":"Extended/RE03 Example","title":"Loading the necessary Julia modules","text":"Load the Geant4, Geant4.PhysicalConstants and Geant4.SystemOfUnits modules. In addition we will use the Parameters module to handle the parameters of the detector. We will also use the FHist and Plots modules to handle the histograms and plots.\n\nusing Geant4\nusing Geant4.SystemOfUnits\nimport DisplayAs: PNG","category":"section"},{"location":"examples/RE03/#Define-Detector-structure","page":"Extended/RE03 Example","title":"Define Detector structure","text":"The RE03 detector is a simple box filled with air. The detector is defined by the RE03Detector structure. We include the RE03Detector.jl file not to clutter the example.\n\ninclude(joinpath(@__DIR__, \"RE03Detector.jl\"))","category":"section"},{"location":"examples/RE03/#Particle-Gun-initialization","page":"Extended/RE03 Example","title":"Particle Gun initialization","text":"particlegun = G4JLGunGenerator(particle = \"e-\",\n                               energy = 1GeV,\n                               direction = G4ThreeVector(0,0,1),\n                               position = G4ThreeVector(0,0,-1.01m))\n\nGeant4.G4JLGunGenerator(\"ParticleGun\", Geant4.G4JLParticleGunData(nothing, \"e-\", G4ThreeVector(0.0,0.0,1.0), G4ThreeVector(0.0,0.0,-1010.0), 1000.0), Geant4.var\"#init#19\"(), Geant4.var\"#gen#20\"(), Geant4.G4JLGeneratorAction[])","category":"section"},{"location":"examples/RE03/#Scoring-Setup","page":"Extended/RE03 Example","title":"Scoring Setup","text":"In this example, we define a scoring mesh that will score the energy deposit and the number of steps of gamma, e- and e+ particles. We do not use the UI interface to define the scoring mesh, instead we define it in the Julia code by instantiating a G4JLScoringMesh object.\n\nsc1 = G4JLScoringMesh(\"boxMesh_1\",\n                      BoxMesh(1m,1m,1m),\n                      bins = (30, 30, 30),\n                      quantities = [ energyDeposit(\"eDep\")\n                                     nOfStep(\"nOfStepGamma\", filters=[ParticleFilter(\"gammafilter\", \"gamma\")])\n                                     nOfStep(\"nOfStepEMinus\", filters=[ParticleFilter(\"eMinusFilter\", \"e-\")])\n                                     nOfStep(\"nOfStepEPlus\", filters=[ParticleFilter(\"ePlusFilter\", \"e+\")])\n                                   ]\n                      );","category":"section"},{"location":"examples/RE03/#Create-the-Application","page":"Extended/RE03 Example","title":"Create the Application","text":"app = G4JLApplication(;detector = RE03Detector(),                    ## detector with parameters\n                       generator = particlegun,                      ## primary particle generator\n                       nthreads = 4,                                 ## number of threads (MT)\n                       physics_type = FTFP_BERT,                     ## what physics list to instantiate\n                       scorers = [sc1]                               ## list of scorers\n                      );\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n  << in Multi-threaded mode >> \n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\n","category":"section"},{"location":"examples/RE03/#Configure,-Initialize-and-Run","page":"Extended/RE03 Example","title":"Configure, Initialize and Run","text":"configure(app)\ninitialize(app)\nbeamOn(app, 0)\n\n--- G4CoupledTransportation is used \n.... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4ScoringManager has 1 scoring meshes.\nG4ScoringBox : boxMesh_1 --- Shape: Box mesh\n Size (x, y, z): (100, 100, 100) [cm]\n # of segments: (30, 30, 30)\n displacement: (0, 0, 0) [cm]\n registered primitve scorers : \n   0  eDep\n   1  nOfStepGamma     with  gammafilter\n   2  nOfStepEMinus     with  eMinusFilter\n   3  nOfStepEPlus     with  ePlusFilter\nG4WT3 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT0 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT2 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT1 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT3 > G4ScoringManager has 1 scoring meshes.\nG4WT3 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT0 > G4ScoringManager has 1 scoring meshes.\nG4WT0 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT3 >  Size (x, y, z): (100, 100, 100) [cm]\nG4WT3 >  # of segments: (30, 30, 30)\nG4WT3 >  displacement: (0, 0, 0) [cm]\nG4WT3 >  registered primitve scorers : \nG4WT3 >    0  eDep\nG4WT3 >    1  nOfStepGamma     with  gammafilter\nG4WT3 >    2  nOfStepEMinus     with  eMinusFilter\nG4WT0 >  Size (x, y, z): (100, 100, 100) [cm]\nG4WT2 > G4ScoringManager has 1 scoring meshes.\nG4WT1 > G4ScoringManager has 1 scoring meshes.\nG4WT2 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT1 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT2 >  Size (x, y, z): (100, 100, 100) [cm]\nG4WT0 >  # of segments: (30, 30, 30)\nG4WT2 >  # of segments: (30, 30, 30)\nG4WT1 >  Size (x, y, z): (100, 100, 100) [cm]\nG4WT0 >  displacement: (0, 0, 0) [cm]\nG4WT0 >  registered primitve scorers : \nG4WT0 >    0  eDep\nG4WT0 >    1  nOfStepGamma     with  gammafilter\nG4WT0 >    2  nOfStepEMinus     with  eMinusFilter\nG4WT1 >  # of segments: (30, 30, 30)\nG4WT1 >  displacement: (0, 0, 0) [cm]\nG4WT1 >  registered primitve scorers : \nG4WT3 >    3  nOfStepEPlus     with  ePlusFilter\nG4WT1 >    0  eDep\nG4WT1 >    1  nOfStepGamma     with  gammafilter\nG4WT1 >    2  nOfStepEMinus     with  eMinusFilter\nG4WT2 >  displacement: (0, 0, 0) [cm]\nG4WT1 >    3  nOfStepEPlus     with  ePlusFilter\nG4WT0 >    3  nOfStepEPlus     with  ePlusFilter\nG4WT2 >  registered primitve scorers : \nG4WT2 >    0  eDep\nG4WT2 >    1  nOfStepGamma     with  gammafilter\nG4WT2 >    2  nOfStepEMinus     with  eMinusFilter\nG4WT2 >    3  nOfStepEPlus     with  ePlusFilter\n","category":"section"},{"location":"examples/RE03/#Do-a-run-and-get-the-scoring-results","page":"Extended/RE03 Example","title":"Do a run and get the scoring results","text":"beamOn(app,1000)\nprintln(\"done with run!!!\")\n\ndone with run!!!\n","category":"section"},{"location":"examples/RE03/#Access-the-scoring-results","page":"Extended/RE03 Example","title":"Access the scoring results","text":"This is done by accessing the eDep field of the G4JLScoringMesh object sc1, or by accessing the fields nOfStepGamma, nOfStepEMinus or nOfStepEPlus. Each of each of these fields returns a tuple with the scoring results (mean, mean², N) organized in a 3-dimensional matrix with the defined number of bins.\n\nt, t2, n = sc1.eDep\n\nBase.Generator{Tuple{Symbol, Symbol, Symbol}, Geant4.var\"#getScoringValues##0#getScoringValues##1\"{Tuple{Int64, Int64, Int64}, CSV.File}}(Geant4.var\"#getScoringValues##0#getScoringValues##1\"{Tuple{Int64, Int64, Int64}, CSV.File}((30, 30, 30), CSV.File(\"/tmp/jl_TE7e3KPQvC\"):\nSize: 27000 x 6\nTables.Schema:\n :iX      Int64\n :iY      Int64\n :iZ      Int64\n :total   Float64\n :total2  Float64\n :entry   Int64), (:total, :total2, :entry))\n\nLets see the dimensions of the scoring results\n\nprintln(\"Dimensions of the scoring results: $(Base.size(t))\")\n\nDimensions of the scoring results: (30, 30, 30)\n\n\nPrint the total energy deposit\n\nprintln(\"Total EDep = $(sum(t))\")\nprintln(\"Central EDep = $(sum(t[10:20,10:20,:]))\")\n\nTotal EDep = 859933.4426632221\nCentral EDep = 852786.0104553683\n","category":"section"},{"location":"examples/RE03/#Plot-the-scoring-results","page":"Extended/RE03 Example","title":"Plot the scoring results","text":"We will use the CairoMakie package to plot the scoring results. We will plot the energy deposit in the center of the scoring mesh.\n\nusing CairoMakie\nimg = heatmap(t[1:30,15,1:30])\nPNG(img)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/Solids/#Geant4-Solids","page":"Geant4 Solids","title":"Geant4 Solids","text":"Notebook/script to exercise all the types of solids defined in Geant4.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/Solids/#Table-of-contents","page":"Geant4 Solids","title":"Table of contents","text":"Pages = [\"Solids.md\"]\nDepth = 2:3\n\nusing Geant4\nusing Geant4.SystemOfUnits\nusing CairoMakie  ## to force loading G4Vis extension\n\nChange the number of steps when drawing curbed surfaces from 24 (default) to 64\n\nHepPolyhedron!SetNumberOfRotationSteps(64)\n","category":"section"},{"location":"examples/Solids/#G4Box","page":"Geant4 Solids","title":"G4Box","text":"box = G4Box(\"Box\", 2,3,4)\nimg = draw(box;color=:green)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Tubs","page":"Geant4 Solids","title":"G4Tubs","text":"Cylindrical Section or Tube\n\nname::String\nrmin::Float64\nrmax::Float64\ndz::Float64\nϕ₀::Float64\nΔϕ::Float64\n\ntub1 = G4Tubs(\"tub1\",0,10,10,0,2π)\nimg = draw(tub1, wireframe=true, color=:blue)\n\n(Image: )\n\ntub2 = G4Tubs(\"tub2\",5,10,10,0, 2π/3)\nimg = draw(tub2, wireframe=true, color=:blue)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4CutTubs","page":"Geant4 Solids","title":"G4CutTubs","text":"Cylindrical Cut Section. A cut in Z can be applied to a cylindrical section to obtain a cut tube.\n\nArguments:\n\nname::String\nrmin::Float64\nrmax::Float64\ndz::Float64\nϕ₀::Float64\nΔϕ::Float64\nlownormal::G4ThreeVector\nhighnormal::G4ThreeVector\n\nctub = G4CutTubs(\"ctub\", 12, 20, 20, 0, 3π/2, G4ThreeVector(0,-0.7,-0.71), G4ThreeVector(0.7,0,0.71))\nimg = draw(ctub, wireframe=true, color=:blue)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Cons","page":"Geant4 Solids","title":"G4Cons","text":"name::String\nrmin1::Float64\nrmax1::Float64\nrmin2::Float64\nrmax2::Float64\ndz::Float64\nϕ₀::Float64\nΔϕ::Float64\n\ncone1 = G4Cons(\"cone1\", 0, 10, 0, 5, 10, 0, 2π)\nimg = draw(cone1, color=:blue, wireframe=true)\n\n(Image: )\n\ncone1 = G4Cons(\"cone1\", 5, 10, 20, 25, 40, 0, 3π/4)\nimg = draw(cone1, color=:blue, wireframe=true)\n\n(Image: )\n\ncone1 = G4Cons(\"cone1\", 5, 10, 2, 5, 5, 0, π/2)\nimg = draw(cone1, color=:orange, shading=true)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Para","page":"Geant4 Solids","title":"G4Para","text":"A parallelepiped is constructed using: | parameter | description | | :–––– | :––––– | | dx,dy,dz | Half-length in x,y,z | | alpha | Angle formed by the Y axis and by the plane joining the centre of the faces parallel to the Z-X plane at -dy and +dy | | theta | Polar angle of the line joining the centres of the faces at -dz and +dz in Z | | phi | Azimuthal angle of the line joining the centres of the faces at -dz and +dz in Z |\n\npara = G4Para(\"para\", 20,30,30, 0, π/4, π/6)\nimg = draw(para, wireframe=true)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Trd","page":"Geant4 Solids","title":"G4Trd","text":"A trapezoid is constructed using:\n\nx1::Float64   XHalfLength1\nx2::Float64   XHalfLength2\ny1::Float64   YHalfLength1\ny2::Float64   YHalfLength2\nz::Float64    ZHalfLength\n\ntrd1 = G4Trd(\"trd1\", 10, 5, 10, 5, 5)\nimg = draw(trd1, wireframe=true, color=:blue)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Trap","page":"Geant4 Solids","title":"G4Trap","text":"To build a generic trapezoid, the G4Trap class is provided. G4Trap is a solid with six trapezoidal faces, it has two bases parallel to the XY-plane and four lateral faces. The bases are located at the same distance from the XY-plane, but on opposite sides from it. Each of the bases has two edges parallel the X-axis. Let’s call the line joining middle point of these edges - the centre line of the base, and the middle point of this line - the centre of the base. An important property of G4Trap is that the line joining the centres of the bases goes through the origin of the local coordinate system.\n\nparameter description\nz Half Z length - distance from the origin to the bases\ntheta Polar angle of the line joining the centres of the bases at -/+z\nphi Azimuthal angle of the line joining the centre of the base at -pDz to the centre of the base at +z\ny1, y2 Half Y length of the base at -z. +z\nx1, x2, x3, x4 Half X length at smaller, bigger Y of the base at -z, +z\nalpha1, alpha2 Angle between the Y-axis and the centre line of the base at -z. +z\n\ntrap = G4Trap(\"trap\", 60, 20deg, 5deg, 40, 30, 40, 10deg, 16, 10, 14, 10deg)\nimg = draw(trap, wireframe=true, color=:green)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Sphere","page":"Geant4 Solids","title":"G4Sphere","text":"rmin::Float64 inner radius\nrmax::Float64 outer radius\nϕ₀::Float64 origin phi angle [0,2π]\nΔϕ::Float64 delta phi angle\nθ₀::Float64 origin theta angle [0,π]\nΔθ::Float64 delta theta angle\n\nsph = G4Sphere(\"sphere\", 7,10, 0, pi/2, pi/4, pi/2 )\nimg = draw(sph, wireframe=true, color=:gray)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Orb","page":"Geant4 Solids","title":"G4Orb","text":"Complete sphere\n\norb = G4Orb(\"orb\", 10)\nimg = draw(orb, wireframe=false, color=:green)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Torus","page":"Geant4 Solids","title":"G4Torus","text":"A torus is constructed using:\n\nparameter description\nrmin Inside radius\nrmax Outside radius\nrtor Swept radius of torus\nϕ₀ Starting phi angle in radians ( ϕ₀+Δϕ <= 2π, ϕ₀ > -2π)\nΔϕ Delta angle of the segment in radians\n\ntorus = G4Torus(\"torus\", 40, 60, 200, 0, π/2)\nimg = draw(torus, wireframe=true, color=:blue)\n\n(Image: )\n\nimg = drawDistanceToOut(torus, 100000)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Hyper","page":"Geant4 Solids","title":"G4Hyper","text":"A hyperboloid is constructed using:\n\nparameter description\nrmin Inside radius\nrmax Outside radius\ninner, outer Stereo angles in radians\nrtor Swept radius of torus\nz Half‑length z\n\nhyper = G4Hype(\"Hype\", 5, 10, 0.2, 0.2, 20)\nimg = draw(hyper, wireframe=true, color=:blue)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Polycone","page":"Geant4 Solids","title":"G4Polycone","text":"A polycone is constructed using:\n\nparameter description\nϕ₀ Starting phi angle in radians ( ϕ₀+Δϕ <= 2π, ϕ₀ > -2π)\nΔϕ Delta angle of the segment in radians\nnumZPlanes Number of Z planes\nzPlane Position of Z planes, with Z in increasing order\nrInner Tangent distance to inner surface\nrOuter Tangent distance to outer surface\n\npcon = G4Polycone(\"pcone\", π/4, 3π/2, 9,\n                  [ 5., 7., 9., 11., 25., 27., 29., 31., 37. ],\n                  [ 0., 0., 0., 0., 0., 0., 0., 0., 0. ],\n                  [ 0., 10., 10., 5. , 5., 10. , 10. , 2., 2.]\n                 )\nimg = draw(pcon, wireframe=true, color=:blue)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4GenericPolycone","page":"Geant4 Solids","title":"G4GenericPolycone","text":"A genric polycone is constructed using:\n\nparameter description\nϕ₀ Starting phi angle in radians ( ϕ₀+Δϕ <= 2π, ϕ₀ > -2π)\nΔϕ Delta angle of the segment in radians\nnumRZ Number of RZ corners\nr r coordinate of corners\nz z coordinate of corners\n\ngpcon = G4GenericPolycone(\"pcone\", 0, π, 4,\n                         [ 5., 10., 10., 5.,],\n                         [ 0., 10., 20., 30.]\n                        )\nimg = draw(gpcon, wireframe=true, color=:blue)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Polyhedra","page":"Geant4 Solids","title":"G4Polyhedra","text":"A polyhedra is constructed using:\n\nparameter description\nϕ₀ Starting phi angle in radians ( ϕ₀+Δϕ <= 2π, ϕ₀ > -2π)\nΔϕ Delta angle of the segment in radians\nnumZPlanes Number of Z planes\nnumSides ! Number of sides \nzPlane Position of Z planes, with Z in increasing order\nrInner Tangent distance to inner surface\nrOuter Tangent distance to outer surface\n\npgon = G4Polyhedra(\"pgon\", -π/4, 5π/4, 3, 7,\n                  [ 0., 5., 8., 13. , 30., 32., 35. ],\n                  [ 0., 0., 0., 0., 0., 0., 0. ],\n                  [ 0., 15., 15., 4., 4., 10., 10.])\nimg = draw(pgon, wireframe=true, color=:blue)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4EllipticalTube","page":"Geant4 Solids","title":"G4EllipticalTube","text":"A tube with an elliptical cross section with elliptical semi-major and semi-minor axes along the X and Y cartesian axes.\n\nparameter description\nxSemiAxis Half length of axis along X\nySemiAxis Half length of axis along Y\nDz Half length Z\n\netub = G4EllipticalTube(\"etube\", 5., 10., 20.)\nimg = draw(etub, wireframe=true, color=:green)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4Ellipsoid","page":"Geant4 Solids","title":"G4Ellipsoid","text":"The general ellipsoid with possible cut in Z\n\nparameter description\nxSemiAxis Half length of axis along X\nySemiAxis Half length of axis along Y\nzSemiAxis Semiaxis in Z\nzBottomCut lower cut plane level, Z\nzTopCut upper cut plane level, Z\n\nellip = G4Ellipsoid(\"ellip\", 10., 20., 50., -10., 40.)\nimg = draw(ellip, wireframe=true, color=:green)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#Boolean-Solids","page":"Geant4 Solids","title":"Boolean Solids","text":"","category":"section"},{"location":"examples/Solids/#G4SubtractionSolid","page":"Geant4 Solids","title":"G4SubtractionSolid","text":"box1 = G4Box(\"box1\", 10,10,10)\ntub1 = G4Tubs(\"tub1\",0,7,11,0,2π)\nsub1 = G4SubtractionSolid(\"sub1\", CxxPtr(box1), CxxPtr(tub1))\nimg = draw(sub1, color=:green)\n\n(Image: )\n\nGenerate random points and check plot the final position using distanceToOut\n\nimg = drawDistanceToOut(sub1, 100000)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4IntersectionSolid","page":"Geant4 Solids","title":"G4IntersectionSolid","text":"box1 = G4Box(\"box1\", 10,10,10)\nt1 = G4Transform3D(G4RotationMatrix(π/4,0,0), G4ThreeVector())\ninter1 = G4IntersectionSolid(\"inter1\", CxxPtr(box1), CxxPtr(box1), t1)\nimg = draw(inter1, color=:green)\n\n(Image: )\n\nGenerate random points and check plot the final position using distanceToOut\n\nimg = drawDistanceToOut(inter1, 100000)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4UnionSolid","page":"Geant4 Solids","title":"G4UnionSolid","text":"tub1 = G4Tubs(\"tub1\",0,5,10,0,2π)\nt1 = G4Transform3D(G4RotationMatrix(0,π/2,0), G4ThreeVector())\nunion1 = G4UnionSolid(\"union1\", CxxPtr(tub1), CxxPtr(tub1), t1)\nimg = draw(union1, color=:green)\n\n(Image: )\n\nGenerate random points and check plot the final position using distanceToOut\n\nimg = drawDistanceToOut(union1, 100000)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#Twisted-Solids","page":"Geant4 Solids","title":"Twisted Solids","text":"","category":"section"},{"location":"examples/Solids/#G4TwistedBox","page":"Geant4 Solids","title":"G4TwistedBox","text":"A box twisted along one axis can be defined as follows:\n\nparameter description\ntwistedangle Twisted angle\npDx Half X length\npDy Half Y length\npDz Half Z length\n\ntwb1 =  G4TwistedBox( \"twbox\", 30deg, 1m,  1m,  1m)\nimg = draw(twb1, wireframe=true, color=:orange)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4TwistedTrap","page":"Geant4 Solids","title":"G4TwistedTrap","text":"A twisted trapezoid is constructed using:\n\nparameter description\ntwistedangle Twisted angle\npDx1 Half X length at y=-pDy\npDx2 Half X length at y=+pDy\npDy Half Y length\npDz Half Z length\npTheta Polar angle of the line joining the centres of the faces at -/+pDz\npDy1 Half Y length at -pDz\npDx1 Half X length at -pDz, y=-pDy1\npDx2 Half X length at -pDz, y=+pDy1\npDy2 Half Y length at +pDz\npDx3 Half X length at +pDz, y=-pDy2\npDx4 Half X length at +pDz, y=+pDy2\npAlph Angle with respect to the Y axis from the centre of the side\n\ntwt1 = G4TwistedTrap(\"twt1\", 30deg, 6cm, 20deg, 5deg, 4cm, 3cm, 4cm, 1.6cm, 1cm, 1.4cm, 10deg)\nimg = draw(twt1, wireframe=true, color=:orange)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4TwistedTubs","page":"Geant4 Solids","title":"G4TwistedTubs","text":"A twisted tube is constructed using:\n\nparameter description\ntwistedangle Twisted angle\nrmin Inside radius\nrmax Outside radius\ndz Half‑length z\ndphi Phi angle of a segment\n\ntwtub1 = G4TwistedTubs(\"twtub1\", 15deg, 1cm, 1.5cm, 2cm, π/2rad)\nimg = draw(twtub1, wireframe=true, color=:orange)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#G4TwistedTrd","page":"Geant4 Solids","title":"G4TwistedTrd","text":"A twisted trapezoid is constructed using:\n\nparameter description\npDx1 Half X length at -pDz\npDx2 Half X length at +pDz\npDy1 Half Y length at -pDz\npDy2 Half Y length at +pDz\npDz Half Z length\ntwistedangle Twisted angle\n\ntwtrd1 = G4TwistedTrd(\"twtrd1\", 30cm, 10cm, 40cm, 15cm, 60cm, 15deg)\nimg = draw(twtrd1, wireframe=true, color=:orange)\n\n(Image: )","category":"section"},{"location":"examples/Solids/#Tessellated-Solids","page":"Geant4 Solids","title":"Tessellated Solids","text":"","category":"section"},{"location":"examples/Solids/#G4TessellatedSolid","page":"Geant4 Solids","title":"G4TessellatedSolid","text":"A tessellated solid is constructed using triangular and quadrangular facets. Here we build a simple pyramid with a square base using 4 triangular faces and one quadrangular face.\n\ntsol = G4TessellatedSolid(\"tsol\")\np0 = G4ThreeVector(0, 0, 0)\np1 = G4ThreeVector(-10, -10, 0)\np2 = G4ThreeVector( 10, -10, 0)\np3 = G4ThreeVector( 10,  10, 0)\np4 = G4ThreeVector(-10,  10, 0)\nface1 = G4TriangularFacet(p1, p0, p2, ABSOLUTE)\nface2 = G4TriangularFacet(p2, p0, p3, ABSOLUTE)\nface3 = G4TriangularFacet(p3, p0, p4, ABSOLUTE)\nface4 = G4TriangularFacet(p4, p0, p1, ABSOLUTE)\napex = G4ThreeVector(0,0,30)\nface5 = G4TriangularFacet(p1, p2, apex, ABSOLUTE)\nface6 = G4TriangularFacet(p2, p3, apex, ABSOLUTE)\nface7 = G4TriangularFacet(p3, p4, apex, ABSOLUTE)\nface8 = G4TriangularFacet(p4, p1, apex, ABSOLUTE)\nAddFacet(tsol, face1)\nAddFacet(tsol, face2)\nAddFacet(tsol, face3)\nAddFacet(tsol, face4)\nAddFacet(tsol, face5)\nAddFacet(tsol, face6)\nAddFacet(tsol, face7)\nAddFacet(tsol, face8)\nSetSolidClosed(tsol, true)\nimg = draw(tsol, wireframe=false, color=:orange)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/MyCode/#MyCode.jl","page":"MyCode.jl","title":"MyCode.jl","text":"#---Load the needed Julia modules------------------------------------------------------------------\nusing Geant4\nusing FHist\nusing Plots\nusing Parameters\n\nprintln(\"=====> Loading MyCode.jl\")\n\n#---Simulation data struct-------------------------------------------------------------------------\n# define a mutable struct to store the simulation data (counters, hitograms, etc.)\n# make N+1 instances of this struct, where N is the number of threads\n@with_kw mutable struct MyData\n    edep = 0.0\n    edepHist = H1D(\"Event total Edep distribution\", 100, 0., 110.)\nend\nadd!(d::MyData, d2::MyData) = (d.edep += d2.edep; merge!(d.edepHist, d2.edepHist))\n\nconst nthreads = ENV[\"G4NUMTHREADS\"] == nothing ? 0 : parse(Int, ENV[\"G4NUMTHREADS\"])\nconst simdata = [MyData() for i in 1:nthreads+1]   # #workers + 1(master)\n\nfunction getMyData()\n    tid = G4Threading!G4GetThreadId()\n    tid < 0 && (tid = -1)   # master thread (-2 for without multi-threading support)\n    simdata[tid+2]\nend \n\n#---Actions----------------------------------------------------------------------------------------\nfunction end_of_event_action(event)\n    data = getMyData()\n    push!(data.edepHist, data.edep)\n    return                      # This is mandatory to force to return nothing\nend\n\nfunction begin_of_event_action(event)\n    data = getMyData()\n    data.edep = 0.0\n    return                      # This is mandatory to force to return nothing\nend\n\nfunction stepping_action(step)\n    data = getMyData()\n    data.edep += GetTotalEnergyDeposit(step)\n    return                      # This is mandatory to force to return nothing\nend\n\nfunction begin_of_run_action(run)\n    return                      # This is mandatory to force to return nothing\nend\n\nfunction end_of_run_action(run)\n    if G4Threading!G4GetThreadId() < 0   # only for the master thread\n        println(\"=====> End of run\")\n        data = simdata[1]\n        for d in simdata[2:end]\n            add!(data, d)                # merge all thread data to the master data\n        end\n        h = data.edepHist\n        img = plot(h.hist, title=h.title)\n        savefig(img, \"edepHist.png\")\n        println(\"=====> edepHist.png saved\")\n    end    \n    return                      # This is mandatory to force to return nothing\nend  ","category":"section"},{"location":"examples/GPS/#Extended/GPS-Example","page":"Extended/GPS Example","title":"Extended/GPS Example","text":"This example is to test the General Particle Source (GPS) in Geant4.jl. The GPS is a flexible and powerful tool to generate primary particles in Geant4. See the G4GeneralParticleSource documentation for the definition of parameters.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/GPS/#Table-of-contents","page":"Extended/GPS Example","title":"Table of contents","text":"Pages = [\"GPS.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/GPS/#Loading-the-necessary-Julia-modules","page":"Extended/GPS Example","title":"Loading the necessary Julia modules","text":"Load the Geant4, Geant4.PhysicalConstants and Geant4.SystemOfUnits modules. In addition we will use the Parameters module to handle the parameters of the detector. We will also use the FHist and Plots modules to handle the histograms and plots.\n\nusing Geant4\nusing Geant4.PhysicalConstants\nusing Geant4.SystemOfUnits\nusing Geant4.SystemOfUnits: deg\nusing Parameters\nusing FHist\nusing Plots\nimport DisplayAs: PNG","category":"section"},{"location":"examples/GPS/#Define-the-Detector","page":"Extended/GPS Example","title":"Define the Detector","text":"The GPS detector is a simple box filled with air. The detector is defined by the GPSDetector structure. We include the GPSDetector.jl file not to clutter the example.\n\ninclude(joinpath(@__DIR__, \"GPSDetector.jl\"))","category":"section"},{"location":"examples/GPS/#Define-the-Simulation-Data","page":"Extended/GPS Example","title":"Define the Simulation Data","text":"The simulation data structure GPSSimData consists of several histograms to store the simulation results.\n\nconst nbins = 50\n@with_kw mutable struct GPSSimData <: G4JLSimulationData\n    hKEne     = H1D(\"Energy Spectrum\", nbins, 0., 15., :MeV)\n    hRad      = H1D(\"Radial ditribution\", nbins, 0., 10., :cm)\n    hAngcosθ  = H1D(\"Angular ditribution cosθ\", nbins, -1., 1.)\n    hAngϕ     = H1D(\"Angular distribution ϕ\", nbins, 0.,360., :deg)\n    hXYpos    = H2D(\"Source X-Y distribution\", nbins, -10., 10., nbins, -10., 10., (:cm, :cm))\n    hZXpos    = H2D(\"Source Z-X distribution\", nbins, -10., 10., nbins, -10., 10., (:cm, :cm))\n    hYZpos    = H2D(\"Source Y-Z distribution\", nbins, -10., 10., nbins, -10., 10., (:cm, :cm))\n    hcosθϕ    = H2D(\"Angular cos(θ)-ϕ distribution\", nbins, -1., 1., nbins, 0., 360., (:nounit, :deg))\n    hθϕ       = H2D(\"Angular θ-ϕ distribution\", nbins, 0., 180., nbins, 0., 360., (:deg, :deg))\nend\n\nMain.var\"##277\".GPSSimData\n\nWe define the function merge! and empty! functions to reduce the simulation results\n\nfunction Base.merge!(x::D, y::D) where D <: G4JLSimulationData\n    for f in fieldnames(D)\n        merge!(getfield(x,f), getfield(y,f))\n    end\nend\nfunction Base.empty!(x::D) where D <: G4JLSimulationData\n    for f in fieldnames(D)\n        empty!(getfield(x,f))\n    end\nend\n\nThe function do_plot is defined to plot the histograms of the simulation data.\n\nfunction do_plot(data::GPSSimData)\n    img = Plots.plot(layout=(3,3), show=true, size=(1400,1000))\n    for (i,fn) in enumerate(fieldnames(GPSSimData))\n        h = getfield(data, fn)\n        Plots.plot!(subplot=i, h.hist, title=h.title, show=true, cgrad=:plasma)\n    end\n    return img\nend\n\ndo_plot (generic function with 1 method)","category":"section"},{"location":"examples/GPS/#Define-the-Simulation-Actions","page":"Extended/GPS Example","title":"Define the Simulation Actions","text":"The simulation actions are defined by the beginrun, endrun and pretrackaction functions.\n\nfunction beginrun(::G4Run, app::G4JLApplication)::Nothing\n    data = getSIMdata(app)\n    empty!(data)\n    nothing\nend\nfunction endrun(::G4Run, app::G4JLApplication)::Nothing\n    # end run action is called for each workwer thread and the master one\n    if G4Threading!G4GetThreadId() < 0\n        data = app.simdata[1]\n        # this is the master thread, so we need to add all the simulation results\n        for d in app.simdata[2:end]\n            merge!(data, d)\n        end\n    end\nend\nfunction pretrackaction(track::G4Track, app::G4JLApplication)::Nothing\n    data = getSIMdata(app)\n    ekin = track |> GetKineticEnergy\n    vertex = track |> GetPosition\n    direction = track |> GetMomentumDirection\n    weight = track |> GetWeight\n\n    x = vertex |> getX\n    y = vertex |> getY\n    z = vertex |> getZ\n    θ = direction |> getTheta\n    ϕ = direction |> getPhi\n    ϕ < 0 &&  (ϕ += 2π)\n    r = vertex |> mag\n    dr = binedges(data.hRad.hist).uniform_edges.step |> Float64\n    dv = 4π * r^2 * dr\n\n    # fill histograms\n    push!(data.hKEne, ekin)\n    push!(data.hRad, r, 1.0/dv)\n    push!(data.hAngcosθ, cos(θ))\n    push!(data.hAngϕ, ϕ)\n    push!(data.hXYpos, x, y)\n    push!(data.hZXpos, z, x)\n    push!(data.hYZpos, y, z)\n    push!(data.hcosθϕ, cos(θ), ϕ)\n    push!(data.hθϕ, θ, ϕ)\n    nothing\nend;","category":"section"},{"location":"examples/GPS/#GPS-initialization","page":"Extended/GPS Example","title":"GPS initialization","text":"We define the GPS parameters and create the primary particle generator. This is equivalent to the particle gun in the previous examples.\n\ngps = G4JLGeneralParticleSource(particle = \"geantino\",\n                                energy = 10MeV,\n                                direction = G4ThreeVector(1,0,0),\n                                position = G4ThreeVector(1,2,1));","category":"section"},{"location":"examples/GPS/#Create-the-Application","page":"Extended/GPS Example","title":"Create the Application","text":"app = G4JLApplication(detector = GPSDetector(),                   ## detector with parameters\n                      simdata = GPSSimData(),                     ## simulation data structure\n                      generator = gps,                            ## primary particle generator\n                      nthreads = VERSION > v\"1.9\" ? 4 : 0,        ## number of threads (MT)\n                      physics_type = FTFP_BERT,                   ## what physics list to instantiate\n                      ##----Actions--------------------------------\n                      pretrackaction_method = pretrackaction,     ## pre-tracking action\n                      beginrunaction_method = beginrun,           ## begin-run action (initialize counters and histograms)\n                      endrunaction_method = endrun,               ## end-run action (print summary)\n                      );\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n  << in Multi-threaded mode >> \n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\n","category":"section"},{"location":"examples/GPS/#Configure-and-Initialize","page":"Extended/GPS Example","title":"Configure and Initialize","text":"configure(app)\ninitialize(app)","category":"section"},{"location":"examples/GPS/#Run-the-simulation","page":"Extended/GPS Example","title":"Run the simulation","text":"We run the simulation with 100000 particles and plot the results.\n\nbeamOn(app,100000)\nimg = do_plot(app.simdata[1])\nPNG(img)\n\n(Image: )\n\nLet's change the GPS parameters and run the simulation again.\n\nui`/gps/particle geantino`\nui`/gps/pos/type Plane`\nui`/gps/pos/shape Square`\nui`/gps/pos/centre 1 2 1 cm`\nui`/gps/pos/halfx 2 cm`\nui`/gps/pos/halfy 2 cm`\nui`/gps/ang/type cos`\nui`/gps/ene/type Lin`\nui`/gps/ene/min 2 MeV`\nui`/gps/ene/max 10 MeV`\nui`/gps/ene/gradient 1`\nui`/gps/ene/intercept 1`\n\nbeamOn(app,100000)\nimg = do_plot(app.simdata[1])\nPNG(img)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/B2aVis/#Basic/B2a-Event-Display-Example","page":"Basic/B2a Event Display Example","title":"Basic/B2a Event Display Example","text":"In this example is based on the Geant4 basic/B2 example of the Geant4 distribution. It is a simple example that shows how to interact with the Geant4 classes.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/B2aVis/#Table-of-contents","page":"Basic/B2a Event Display Example","title":"Table of contents","text":"Pages = [\"B2aVis.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/B2aVis/#Loading-the-necessary-Julia-modules","page":"Basic/B2a Event Display Example","title":"Loading the necessary Julia modules","text":"Load the Geant4 and Geant4.SystemOfUnits modules. In order to trigger the load of the G4Vis extension we need to load the following modules: GLMakie\n\nusing Geant4\nusing Geant4.SystemOfUnits\nusing CairoMakie  # to force loading G4Vis extension\nimport DisplayAs: PNG","category":"section"},{"location":"examples/B2aVis/#Define-Detector-Parameters-structure","page":"Basic/B2a Event Display Example","title":"Define Detector Parameters structure","text":"The B2aDetector structure is defined with the default detector parameters. We include the B2aDetector.jl file not to clutter the example.\n\ninclude(joinpath(@__DIR__, \"B2aDetector.jl\"))","category":"section"},{"location":"examples/B2aVis/#Particle-Gun-initialization","page":"Basic/B2a Event Display Example","title":"Particle Gun initialization","text":"particlegun = G4JLGunGenerator(particle = \"proton\",\n                               energy = 3GeV,\n                               direction = G4ThreeVector(0,0,1),\n                               position = G4ThreeVector(0,0,-2940.0));","category":"section"},{"location":"examples/B2aVis/#Event-Display","page":"Basic/B2a Event Display Example","title":"Event Display","text":"To setup the event display we need to create an instance of the G4JLEventDisplay type. The file B2aVisSettings.jl contains the settings for the visualization.\n\nevtdisplay = G4JLEventDisplay(joinpath(@__DIR__, \"B2aVisSettings.jl\"));","category":"section"},{"location":"examples/B2aVis/#Create-the-application","page":"Basic/B2a Event Display Example","title":"Create the application","text":"app = G4JLApplication(;detector = B2aDetector(nChambers=5),          ## detector with parameters\n                       generator = particlegun,                      ## primary particle generator\n                       physics_type = FTFP_BERT,                     ## what physics list to instantiate\n                       evtdisplay =  evtdisplay,                     ## detector and event visualization\n                      );\n# wait_for_key(prompt) = (print(stdout, prompt); read(stdin, 1); nothing)\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\n","category":"section"},{"location":"examples/B2aVis/#Configure,-Initialize-and-Run","page":"Basic/B2a Event Display Example","title":"Configure, Initialize and Run","text":"configure(app)\ninitialize(app)\n\nChecking overlaps for volume Target:0 (G4Tubs) ... OK! \nChecking overlaps for volume Tracker:0 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:1 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:2 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:3 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:4 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:5 (G4Tubs) ... OK! \n\n\nDisplay the detector geometry at this point\n\nbeamOn(app,0)  ## Needed to really initialize\nPNG(evtdisplay.figure)\n\n(Image: )\n\nDisplay the detector geometry with the first event\n\nbeamOn(app,1)\nPNG(evtdisplay.figure)\n\n(Image: )\n\nDisplay the detector geometry with the second event\n\nbeamOn(app,1)\nPNG(evtdisplay.figure)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/B2aDetector/#B2aDetector.jl","page":"B2aDetector.jl","title":"B2aDetector.jl","text":"#--------------------------------------------------------------------------------------------------\n# Implementation of the B2a::DetectorConstruction class\n#--------------------------------------------------------------------------------------------------\nmutable struct B2aDetector <: G4JLDetector\n    # main input parameters\n    const nChambers::Int            # number of chambers\n    const checkOverlaps::Bool       # do check overlaps when creating the geometry\n    const chamberSpacing::Float64   # from chamber center to center!\n    const chamberWidth::Float64     # width of the chambers\n    const targetLength::Float64     # full length of Target\n    # mutable data\n    worldZHalfLength::Float64\n    # constructor with defaults values for parameters\n    function B2aDetector(;  nChambers::Int=5, \n                            checkOverlaps::Bool=true,\n                            chamberSpacing::Float64=80cm,\n                            chamberWidth::Float64=20cm,\n                            targetLength::Float64=5cm)\n        self = new(nChambers, checkOverlaps, chamberSpacing, chamberWidth, targetLength)\n        # Setup some geometry\n        self.worldZHalfLength = 1.2 * (2*targetLength +  (nChambers+1) * chamberSpacing) /2 \n        return self\n    end\nend\n\nfunction B2aConstruct(det::B2aDetector)::CxxPtr{G4VPhysicalVolume}\n    (; nChambers, checkOverlaps, chamberSpacing, chamberWidth, targetLength) = det\n\n    #---Materials----------------------------------------------------------------------------------\n    nist = G4NistManager!Instance()\n    m_air = FindOrBuildMaterial(nist, \"G4_AIR\")\n    m_target = FindOrBuildMaterial(nist, \"G4_Pb\")\n    m_chamber = FindOrBuildMaterial(nist, \"G4_Xe\")\n\n    #---Derived parameters-------------------------------------------------------------------------\n    trackerLength = (nChambers+1) * chamberSpacing\n    worldLength = 1.2 * (2*targetLength + trackerLength)\n    targetRadius = targetLength/2   # Radius of Target\n    targetLength = targetLength/2   # Half length of the Target\n    trackerSize  = trackerLength/2  # Half length of the Tracker\n\n    #---Volumes------------------------------------------------------------------------------------\n    det.worldZHalfLength = worldLength/2\n    worldS = G4Box(\"world\", det.worldZHalfLength, det.worldZHalfLength, det.worldZHalfLength)\n    worldLV = G4LogicalVolume(worldS, m_air, \"World\")\n    worldPV = G4PVPlacement(nothing, \n        G4ThreeVector(),                # at (0,0,0)\n        worldLV,                        # its logical volume\n        \"World\",                        # its name\n        nothing,                        # its mother  volume\n        false,                          # no boolean operations\n        0,                              # copy number\n        checkOverlaps)                  # checking overlaps\n\n    positionTarget = G4ThreeVector(0,0,-(targetLength+trackerSize))\n    targetS = G4Tubs(\"target\", 0, targetRadius, targetLength, 0, 360deg)\n    targetLV = G4LogicalVolume(targetS, m_target, \"Target\")\n    G4PVPlacement(nothing,              # no rotation\n        positionTarget,                 # at (x,y,z)\n        targetLV,                       # its logical volume\n        \"Target\",                       # its name\n        worldLV,                        # its mother volume\n        false,                          # no boolean operations\n        0,                              # copy number\n        checkOverlaps)                  # checking overlaps\n  \n    positionTracker = G4ThreeVector(0,0,0)\n    trackerS = G4Tubs(\"tracker\", 0, trackerSize, trackerSize, 0, 360deg)\n    trackerLV = G4LogicalVolume(trackerS, m_air, \"Tracker\")\n    G4PVPlacement(nothing,              # no rotation\n        positionTracker,                # at (x,y,z)\n        trackerLV,                      # its logical volume\n        \"Tracker\",                      # its name\n        worldLV,                        # its mother  volume\n        false,                          # no boolean operations\n        0,                              # copy number\n        checkOverlaps)                  # checking overlaps\n\n    # Visualization attributes\n    boxVisAtt = G4VisAttributes(G4Colour(1.0, 1.0, 1.0, 0.1))\n    targetVisAtt = G4VisAttributes(G4Colour(0.0, 0.0, 1.0))\n    chamberVisAtt = G4VisAttributes(G4Colour(1.0, 1.0, 0.0))\n    SetVisAttributes(worldLV, boxVisAtt)\n    SetVisAttributes(targetLV, targetVisAtt)\n    SetVisAttributes(trackerLV, boxVisAtt)\n\n    # Tracker segments\n    firstPosition = -trackerSize + chamberSpacing\n    firstLength   = trackerLength/10\n    lastLength    = trackerLength\n  \n    halfWidth = chamberWidth/2\n    rmaxFirst = firstLength/2\n  \n    rmaxIncr = 0.\n    if nChambers > 0\n        rmaxIncr =  0.5 * (lastLength-firstLength)/(nChambers-1)\n        if chamberSpacing  < chamberWidth\n            G4Exception(\"DetectorConstruction::DefineVolumes()\",\n                       \"InvalidSetup\", FatalException,\n                       \"Width>Spacing\")\n        end \n    end\n\n    fLogicChamber = Vector{G4LogicalVolume}()\n\n    for copyNo in 1:nChambers\n        Zposition = firstPosition + (copyNo-1) * chamberSpacing\n        rmax =  rmaxFirst + (copyNo -1) * rmaxIncr\n        chamberS = G4Tubs(\"Chamber_solid\", 0, rmax, halfWidth, 0, 360deg)\n        push!(fLogicChamber, G4LogicalVolume(chamberS, m_chamber, \"Chamber_LV\"))\n  \n        SetVisAttributes(fLogicChamber[copyNo], chamberVisAtt)\n\n        G4PVPlacement(nothing,              # no rotation\n            G4ThreeVector(0, 0, Zposition), # at (x,y,z)\n            fLogicChamber[copyNo],          # its logical volume\n            \"Chamber_PV\",                   # its name\n            trackerLV,                      # its mother  volume\n            false,                          # no boolean operations\n            copyNo,                         # copy number\n            checkOverlaps)                  # checking overlaps\n    end\n\n    # Example of User Limits\n    #\n    # Below is an example of how to set tracking constraints in a given\n    # logical volume\n    #\n    # Sets a max step length in the tracker region, with G4StepLimiter\n    maxStep = chamberWidth/2\n    fStepLimit = G4UserLimits(maxStep)\n    SetUserLimits(trackerLV, fStepLimit)\n   \n    # Always return the physical world-------------------------------------------------------------\n    return worldPV\nend\n\nGeant4.getConstructor(::B2aDetector)::Function = B2aConstruct","category":"section"},{"location":"examples/HBC30Detector/#HBC30Detector.jl","page":"HBC30Detector.jl","title":"HBC30Detector.jl","text":"\nmutable struct HBC30 <: G4JLDetector\n    # main input parameters\n    const chamberDiameter::Float64  # chamber diameter\n    const targetLength::Float64     # length of target\n    const checkOverlaps::Bool       # do check overlaps when creating the geometry\n    # mutable data\n    worldZHalfLength::Float64\n    # constructor with defaults values for parameters\n    function HBC30(; chamberDiameter=30cm,\n                     targetLength=5cm,\n                     checkOverlaps=false)\n        self = new(chamberDiameter, targetLength, checkOverlaps)\n        # derived parameters\n        self.worldZHalfLength = 1.1 * (targetLength + chamberDiameter)/2\n        return self\n    end\nend\n\nimport Geant4.SystemOfUnits:mole,cm3\n\nfunction HBC30Construct(det::HBC30)::CxxPtr{G4VPhysicalVolume}\n    (; chamberDiameter, targetLength, checkOverlaps) = det\n\n    #---Materials----------------------------------------------------------------------------------\n    G4Material(\"LH₂\",  z=1., a=1.008*g/mole, density= 70.8*mg/cm3)\n    nist = G4NistManager!Instance()\n    m_air    = FindOrBuildMaterial(nist, \"G4_AIR\")\n    m_lh2    = FindOrBuildMaterial(nist, \"LH₂\")\n    m_glass  = FindOrBuildMaterial(nist, \"G4_GLASS_PLATE\")\n    m_target = FindOrBuildMaterial(nist, \"G4_W\")\n    m_lAr    = FindOrBuildMaterial(nist, \"G4_lAr\")\n\n    #---Volumes------------------------------------------------------------------------------------\n    worldS  = G4Box(\"world\", det.worldZHalfLength, det.worldZHalfLength, det.worldZHalfLength)\n    worldLV = G4LogicalVolume(worldS, m_air, \"World\")\n    worldPV = G4PVPlacement(nothing, G4ThreeVector(), worldLV, \"World\", nothing, false, 0, checkOverlaps)\n\n    chamberS  = G4Tubs(\"chamber\", 0, chamberDiameter/2, 7.5cm, 0, 2π)\n    chamberLV = G4LogicalVolume(chamberS, m_lh2, \"chamber\")\n    G4PVPlacement(nothing, G4ThreeVector(), chamberLV, \"chamber\", worldLV, false, 0, checkOverlaps)\n    SetUserLimits(chamberLV, G4UserLimits(5mm))\n\n    windowS  = G4Tubs(\"window\", 0, chamberDiameter/2, 1.5cm, 0, 2π)\n    windowLV = G4LogicalVolume(windowS, m_glass, \"window\")\n    G4PVPlacement(nothing, G4ThreeVector(0, 0, 7.5cm+1.5cm), windowLV, \"window1\", worldLV, false, 0, checkOverlaps)\n    G4PVPlacement(nothing, G4ThreeVector(0, 0, -7.5cm-1.5cm), windowLV, \"window2\", worldLV, false, 0, checkOverlaps)\n\n    targetS = G4Tubs(\"target\", 0, 1cm, targetLength/2, 0, 2π)\n    targetLV = G4LogicalVolume(targetS, m_air, \"target\")\n    rot = G4RotationMatrix()\n    rotateX(rot, π/2)\n    trans = G4Transform3D(rot,G4ThreeVector(0, chamberDiameter/2+targetLength/2, 0))\n    G4PVPlacement(trans, targetLV, \"target\", worldLV, false, 0, checkOverlaps)\n\n    # Visualization attributes\n    boxVisAtt = G4VisAttributes(G4Colour(1.0, 1.0, 1.0, 0.0))\n    targetVisAtt = G4VisAttributes(G4Colour(1.0, 1.0, 1.0, 0.9))\n    chamberVisAtt = G4VisAttributes(G4Colour(1.0, 1.0, 0.0, 0.1))\n    windowVisAtt = G4VisAttributes(G4Colour(0.0, 0.0, 1.0, 0.05))\n    SetVisAttributes(worldLV, boxVisAtt)\n    SetVisAttributes(targetLV, targetVisAtt)\n    SetVisAttributes(chamberLV, chamberVisAtt)\n    SetVisAttributes(windowLV, windowVisAtt)\n\n    # Always return the physical world-------------------------------------------------------------\n    return worldPV\nend\n\nGeant4.getConstructor(::HBC30)::Function = HBC30Construct","category":"section"},{"location":"examples/TestEm3Detector/#TestEm3Detector.jl","page":"TestEm3Detector.jl","title":"TestEm3Detector.jl","text":"using Geant4\nusing Geant4.SystemOfUnits\n\n#--------------------------------------------------------------------------------------------------\n# TestEm3 Detector definition\n#--------------------------------------------------------------------------------------------------\n\nmutable struct TestEm3Detector <: G4JLDetector\n    # main input parameters\n    const fNbOfAbsor::Int64\n    const fNbOfLayers::Int64\n    const fCalorSizeYZ::Float64\n    const fAbsorThickness::Vector{Float64}\n\n    # mutable (computed) detector data\n    fLayerThickness::Float64\n    fCalorThickness::Float64\n    fWorldSizeYZ::Float64\n    fWorldSizeX::Float64\n\n    fAbsorMaterial::Vector{CxxPtr{G4Material}}\n    fWorldMaterial::CxxPtr{G4Material}\n\n    fSolidWorld::G4Box\n    fLogicWorld::G4LogicalVolume\n    fPhysiWorld::CxxPtr{G4VPhysicalVolume}\n  \n    fSolidCalor::G4Box\n    fLogicCalor::G4LogicalVolume\n    fPhysiCalor::CxxPtr{G4VPhysicalVolume}\n  \n    fSolidLayer::G4Box\n    fLogicLayer::G4LogicalVolume\n    fPhysiLayer::CxxPtr{G4VPhysicalVolume}\n  \n    fSolidAbsor::Vector{G4Box}\n    fLogicAbsor::Vector{G4LogicalVolume}\n    fPhysiAbsor::Vector{CxxPtr{G4VPhysicalVolume}}\n\n    function TestEm3Detector(;nbOfLayers = 50, \n                              calorSizeYZ = 40cm,\n                              absorThickness = [2.3mm, 5.7mm],\n                              absorMaterial = [\"G4_Pb\", \"G4_lAr\"])\n        self = new(length(absorThickness), nbOfLayers, calorSizeYZ, absorThickness)\n\n        # Compute derived parameters of the calorimeter\n        self.fLayerThickness = 0.\n        for i in 1:self.fNbOfAbsor\n          self.fLayerThickness += self.fAbsorThickness[i]\n        end\n        self.fCalorThickness = self.fNbOfLayers * self.fLayerThickness     \n        self.fWorldSizeX = 1.2 * self.fCalorThickness \n        self.fWorldSizeYZ = 1.2 * self.fCalorSizeYZ\n\n        DefineMaterials!(self)\n\n        nist = G4NistManager!Instance()\n        self.fWorldMaterial = FindOrBuildMaterial(nist,\"Galactic\")\n        self.fAbsorMaterial = [FindOrBuildMaterial(nist, mat) for mat in absorMaterial]\n        self\n    end\n\nend      \n\nusing Geant4.SystemOfUnits:cm3, mole, kelvin, atmosphere, eV, pascal, bar\nconst perCent=0.01\n\nfunction DefineMaterials!(det::TestEm3Detector)\n    # to avoid warnings of redefinitions\n    G4Material!GetMaterial(\"liquidH2\", false) != C_NULL && return\n\n    nist = G4NistManager!Instance()\n    H  = FindOrBuildElement(nist,1)\n    C  = FindOrBuildElement(nist,6)\n    N  = FindOrBuildElement(nist,7)\n    O  = FindOrBuildElement(nist,8)\n    Si = FindOrBuildElement(nist,14)\n    Ge = FindOrBuildElement(nist,32)\n    Sb = FindOrBuildElement(nist,51)\n    I  = FindOrBuildElement(nist,53)\n    Cs = FindOrBuildElement(nist,55)\n    Pb = FindOrBuildElement(nist,82)\n    Bi = FindOrBuildElement(nist,83)\n\n    U5 = G4Isotope(\"U235\", z=92, n=235, a=235.01*g/mole)\n    U8 = G4Isotope(\"U238\", z=92, n=238, a=238.03*g/mole)\n  \n    U  = G4Element(\"enriched Uranium\", \"U\", 2)\n    AddIsotope(U, move!(U5), 0.90)\n    AddIsotope(U, move!(U8), 0.10)\n\n    G4Material(\"liquidH2\",    z=1.,  a= 1.008*g/mole,  density= 70.8*mg/cm3)\n    G4Material(\"Aluminium\",   z=13., a= 26.98*g/mole,  density= 2.700*g/cm3)\n    G4Material(\"Titanium\",    z=22., a= 47.867*g/mole, density= 4.54*g/cm3)\n    G4Material(\"Iron\",        z=26., a= 55.85*g/mole,  density= 7.870*g/cm3)\n    G4Material(\"Copper\",      z=29., a= 63.55*g/mole,  density= 8.960*g/cm3)\n    G4Material(\"Tungsten\",    z=74., a= 183.85*g/mole, density= 19.30*g/cm3)\n    G4Material(\"Gold\",        z=79., a= 196.97*g/mole, density= 19.32*g/cm3)\n    G4Material(\"Uranium\",     z=92., a= 238.03*g/mole, density= 18.95*g/cm3)\n\n    # define a material from elements.   case 1: chemical molecule\n  \n    H₂O = G4Material(\"Water\", density=1.000*g/cm3, ncomponents=2)\n\n    AddElement(H₂O, H, natoms=2)\n    AddElement(H₂O, O, natoms=1)\n    #SetMeanExcitationEnergy(GetIonisation(H₂O), 78.0*eV)\n    SetChemicalFormula(H₂O, \"H_2O\")\n    \n    CH = G4Material(\"Polystyrene\", density= 1.032*g/cm3, ncomponents=2)\n    AddElement(CH, C, natoms=1)\n    AddElement(CH, H, natoms=1)\n \n    Sci = G4Material(\"Scintillator\", density= 1.032*g/cm3, ncomponents=2)\n    AddElement(Sci, C, natoms=9)\n    AddElement(Sci, H, natoms=10)\n    #SetBirksConstant(GetIonisation(Sci), 0.126*mm/MeV)\n  \n    Lct = G4Material(\"Lucite\", density= 1.185*g/cm3, ncomponents=3)\n    AddElement(Lct, C, fractionmass=.5997)\n    AddElement(Lct, H, fractionmass=.0807)\n    AddElement(Lct, O, fractionmass=.3196)\n  \n    Sili = G4Material(\"Silicon\", density= 2.330*g/cm3, ncomponents=1)\n    AddElement(Sili, Si, natoms=1)\n  \n    SiO₂ = G4Material(\"quartz\", density= 2.200*g/cm3, ncomponents=2)\n    AddElement(SiO₂, Si, natoms=1)\n    AddElement(SiO₂, O , natoms=2)\n  \n    G10 = G4Material(\"NemaG10\", density= 1.700*g/cm3, ncomponents=4)\n    AddElement(G10, Si, natoms=1)\n    AddElement(G10, O , natoms=2)\n    AddElement(G10, C , natoms=3)\n    AddElement(G10, H , natoms=3)\n  \n    CsI = G4Material(\"CsI\", density= 4.534*g/cm3, ncomponents=2)\n    AddElement(CsI, Cs, natoms=1)\n    AddElement(CsI, I , natoms=1)\n    #SetMeanExcitationEnergy(GetIonisation(CsI), 553.1*eV)\n  \n    BGO = G4Material(\"BGO\", density= 7.10*g/cm3, ncomponents=3)\n    AddElement(BGO, O , natoms=12)\n    AddElement(BGO, Ge, natoms= 3)\n    AddElement(BGO, Bi, natoms= 4)\n  \n    SiNx= G4Material(\"SiNx\", density= 3.1 *g/cm3, ncomponents=3)\n    AddElement(SiNx, Si, natoms=300)\n    AddElement(SiNx, N, natoms=310)\n    AddElement(SiNx, H, natoms=6)\n\n    # define gaseous materials using G4 NIST database \n    Air = FindOrBuildMaterial(nist, \"G4_AIR\")\n    ConstructNewGasMaterial(nist, \"Air20\",\"G4_AIR\", 293kelvin, 1atmosphere)\n\n    lAr = FindOrBuildMaterial(nist, \"G4_lAr\")\n    lArEm3 = G4Material(\"liquidArgon\", density= 1.390g/cm3, ncomponents=1)\n    AddMaterial(lArEm3, lAr, fractionmass=1.0)\n\n    # define a material from elements and others materials (mixture of mixtures)\n    Lead = G4Material(\"Lead\", density=11.35*g/cm3, ncomponents=1)\n    AddElement(Lead, Pb, fractionmass=1.0)\n  \n    LeadSb = G4Material(\"LeadSb\", density=11.35*g/cm3, ncomponents=2)\n    AddElement(LeadSb, Sb, fractionmass=4perCent)\n    AddElement(LeadSb, Pb, fractionmass=96perCent)\n  \n    Aerog = G4Material(\"Aerogel\", density= 0.200*g/cm3, ncomponents=3)\n    AddMaterial(Aerog, SiO₂, fractionmass=62.5*perCent)\n    AddMaterial(Aerog, H₂O , fractionmass=37.4*perCent)\n    AddElement(Aerog, C , fractionmass= 0.1*perCent)\n  \n    # examples of gas in non STP conditions\n    CO₂ = G4Material(\"CarbonicGas\", density= 27*mg/cm3, ncomponents=2, state=kStateGas, temperature= 325*kelvin, pressure= 50*atmosphere)\n    AddElement(CO₂, C, natoms=1)\n    AddElement(CO₂, O, natoms=2)\n  \n    steam = G4Material(\"WaterSteam\", density= 1.0*mg/cm3, ncomponents=1, state=kStateGas, temperature= 273*kelvin, pressure= 1*atmosphere)\n    AddMaterial(steam, H₂O, fractionmass=1.)\n    \n    G4Material(\"ArgonGas\", z=18., a=39.948*g/mole, density= 1.782*mg/cm3, state=kStateGas, temperature=273.15*kelvin, pressure=1*atmosphere)\n\n    # examples of vacuum\n    universe_mean_density = 1.e-25*g/cm3\n    move!(G4Material(\"Galactic\", z=1., a=1.008*g/mole, density=universe_mean_density, state=kStateGas, temperature=2.73*kelvin, pressure=3.e-18*pascal))\n  \n    beam = G4Material(\"Beam\", density=1.e-5*g/cm3, ncomponents=1, state=kStateGas, temperature=273.15*kelvin, pressure=2e-2*bar)\n    AddMaterial(beam, Air, fractionmass=1.)\n\nend\n\nfunction TestEm3Construct(det::TestEm3Detector)::CxxPtr{G4VPhysicalVolume}\n    (; fNbOfAbsor, fNbOfLayers, fCalorSizeYZ, fAbsorThickness, fLayerThickness, fCalorThickness, fWorldSizeYZ, fWorldSizeX, fWorldMaterial, fAbsorMaterial) = det\n\n    #isdefined(det,:fSolidWorld) && return det.fPhysiWorld\n    println(\"Building Geometry now!!!\")\n    \n    #---World--------------------------------------------------------------------------------------\n    det.fSolidWorld = G4Box(\"World\", fWorldSizeX/2,fWorldSizeYZ/2,fWorldSizeYZ/2)\n    det.fLogicWorld = G4LogicalVolume(CxxPtr(det.fSolidWorld), fWorldMaterial, \"World\")\n    det.fPhysiWorld = G4PVPlacement(nothing,              # no rotation\n                                    G4ThreeVector(),      # at (0,0,0)\n                                    det.fLogicWorld,      # its fLogical volume\n                                    \"World\",              # its name\n                                    nothing,              # its mother  volume\n                                    false,                # no boolean operation\n                                    0)                    #copy number\n\n    #---Calorimeter--------------------------------------------------------------------------------\n    det.fSolidCalor = G4Box(\"Calorimeter\", fCalorThickness/2,fCalorSizeYZ/2,fCalorSizeYZ/2)\n    det.fLogicCalor = G4LogicalVolume(CxxPtr(det.fSolidCalor), fWorldMaterial, \"Calorimeter\")      \n    det.fPhysiCalor = G4PVPlacement(nothing,               # no rotation\n                                    G4ThreeVector(),       # at (0,0,0)\n                                    det.fLogicCalor,       # its fLogical volume\n                                    \"Calorimeter\",         # its name\n                                    det.fLogicWorld,       # its mother  volume\n                                    false,                 # no boolean operation\n                                    0)                     # copy number\n\n    #---Layers-------------------------------------------------------------------------------------\n    det.fSolidLayer = G4Box(\"Layer\", fLayerThickness/2,fCalorSizeYZ/2,fCalorSizeYZ/2)\n    det.fLogicLayer = G4LogicalVolume(CxxPtr(det.fSolidLayer), fWorldMaterial, \"Layer\")              \n    if fNbOfLayers > 1\n        det.fPhysiLayer = G4PVReplica(\"Layer\",              \n                                      det.fLogicLayer,     \n                                      det.fLogicCalor,      \n                                      kXAxis,              \n                                      fNbOfLayers,            \n                                      fLayerThickness)     \n    else\n        det.fPhysiLayer = G4PVPlacement(nothing,                   \n                                        G4ThreeVector(),     \n                                        det.fLogicLayer,           \n                                        \"Layer\",             \n                                        det.fLogicCalor,         \n                                        false,             \n                                        0)                    \n    end\n\n    #---Absorbers----------------------------------------------------------------------------------\n    det.fSolidAbsor = [G4Box(\"Absorber\", fAbsorThickness[k]/2,fCalorSizeYZ/2,fCalorSizeYZ/2) for k in 1:fNbOfAbsor]\n    det.fLogicAbsor = [G4LogicalVolume(CxxPtr(det.fSolidAbsor[k]), fAbsorMaterial[k], GetName(fAbsorMaterial[k])) for  k in 1:fNbOfAbsor]\n\n    xcenter = zeros(fNbOfAbsor)\n    xfront = -0.5*fLayerThickness\n    for k in 1:fNbOfAbsor\n        xcenter[k] = xfront + 0.5*fAbsorThickness[k]\n        xfront += fAbsorThickness[k]\n    end\n    det.fPhysiAbsor = [G4PVPlacement(nothing,              \n                                     G4ThreeVector(xcenter[k],0.,0.),\n                                     det.fLogicAbsor[k],               \n                                     String(GetName(fAbsorMaterial[k])),\n                                     det.fLogicLayer,                  \n                                     false,                      \n                                     k) for  k in 1:fNbOfAbsor]\n    return det.fPhysiWorld\nend\n\nGeant4.getConstructor(::TestEm3Detector)::Function = TestEm3Construct","category":"section"},{"location":"releases/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releases/#0.2.4-16-Dec-2025","page":"Release Notes","title":"0.2.4 - 16-Dec-2025","text":"New Features:\nAdded new G4 classes to the Wrapper: G4VTwistedFaceted, G4Hype, G4TessellatedSolid, G4TriangularFacet, G4Polyhedron, HepPolyhedron\nChange the way to create the meshes of Solids for G4Vis using the GetPolyhedron() virtual function. Remove all obsolete code.\nWhen drawing recursive geometry hierarchies, merging meshes is done before drawing them.\nAdded B4a example (thanks to @Chetan-379)","category":"section"},{"location":"releases/#0.2.3-29-Aug-2025","page":"Release Notes","title":"0.2.3 - 29-Aug-2025","text":"New Features:\nUpgraded to CxxWrap version 0.17\nTested with Makie 0.24\nFixes:\n#37 Removed from exports the ones clashing with Base: \"length\", \"size\", \"angle\", \"decompose\", \"contains\"\nFix type piracy in Transformation3D.jl (removed +(Point3, Point3)). It was breaking Makie 0.24 ","category":"section"},{"location":"releases/#0.2.2-20-June-2025","page":"Release Notes","title":"0.2.2 - 20-June-2025","text":"New Features:\nUsing new version of Geant4_jll v11.3.2\nAdded CompatHelper\nFixes:\nTestEm3 particle gun needs to be inside world volume\nlength is also a method of Geant4 (removed from exports)\nUpdate G4Vis to breaking changes in GeometryBasics@0.5","category":"section"},{"location":"releases/#0.2.1","page":"Release Notes","title":"0.2.1","text":"New Features\nAdded wrappers for classes LBE, G4GenericPolycone\nAdded Visualization for G4GenericPolycone\nNew Examples:\nUserLib: how to build and call a user custom library providing additional Geant4 functionally that is not provided by the set of wrapped classes\nJuliaAction: embedding Julia in a C++ application. In this example we call user actions implemented in Julia","category":"section"},{"location":"releases/#0.2.0","page":"Release Notes","title":"0.2.0","text":"New Features\nAdapted to CxxWrap 0.16\nChanged gen/build.jl to generate the code first and then call cmake (not yet using WrapIt.jl package)\nAdded new example advanced/AlephTPC to integrate Geant4 with PYTHIA8\nChanged the documentation to generate examples as markdown, as notebook and as julia script using the package Literate.jl ","category":"section"},{"location":"releases/#0.1.17","page":"Release Notes","title":"0.1.17","text":"New Features\nAdded wrapper for G4StepLimiterPhysics","category":"section"},{"location":"releases/#0.1.15","page":"Release Notes","title":"0.1.15","text":"Fixes:\nReturned threadid is -2 for non-multithreaded builds of Geant4","category":"section"},{"location":"releases/#0.1.14","page":"Release Notes","title":"0.1.14","text":"New Features:\nAdded function getfield(pos::G4ThreeVector, bfield::G4JLMagneticField)\nAdded G4JLEmptyDetector as default detector (for testing and tutorials)\nbuild some protection to re-use physics lists in case re-creating an G4JLApplication ","category":"section"},{"location":"releases/#0.1.13","page":"Release Notes","title":"0.1.13","text":"New Features:\nAdded wrappers for PhysicsLists classes: G4DecayPhysics, G4EmStandardPhysics, G4RadioactiveDecayPhysics\nImplemented user stacking action\nAdded examples basic/B3a","category":"section"},{"location":"releases/#0.1.12","page":"Release Notes","title":"0.1.12","text":"Moved the examples to new repository https://github.com/JuliaHEP/G4Examples.jl\nFixes:\nVeto CLHEP::HepRandomEngine::get to avoid clash with Base.get\nDisable finalizer for class G4JLStateDependent. Fixes event display.","category":"section"},{"location":"releases/#0.1.11","page":"Release Notes","title":"0.1.11","text":"Migrated to Julia 1.10\nUsing the latest version of WrapIt to generate the CxxWrap wrappers\nNew features\nAdded G4JLGeneralParticleSource, which makes use of the Geant4 G4GeneralParticleSource class for generation of primary particles for simulations. See documentation.\nAdded a new extension module G4Hist that defines convenient histogram types (H1D and H2D) on top of FHist.jl. See documentation. ","category":"section"},{"location":"releases/#0.1.10","page":"Release Notes","title":"0.1.10","text":"New features\nProvide an EventDisplay as a building block of the application. New evtdisplay argument in the constructor. \nAdded new wrapped classes to support event displays: G4EventManager, G4TrajectoryContainer, G4VTrajectory, G4VTrajectoryPoint, G4StateManager, G4VStateDependent G4ApplicationState","category":"section"},{"location":"releases/#0.1.9","page":"Release Notes","title":"0.1.9","text":"Changes needed for running ATLTileCalTB example ","category":"section"},{"location":"releases/#0.1.8","page":"Release Notes","title":"0.1.8","text":"New features:\nAdded all example scripts as tests, so that the CI will systematically execute them.\nAdded new wrapped classes: G4LogicalVolumeStore, G4MaterialPropertiesTable, G4OpticalParameters, G4OpticalSurface, G4LogicalBorderSurface, G4LogicalSkinSurface, G4VProcess, G4ProcessType, G4Random, G4EmStandardPhysics_option4, G4OpticalPhysics, G4OpBoundaryProcess, G4ProcessManager, G4ProcessVector\nAdded Geant4.PhysicalConstants sub-module\nAdded testRandom to the test suite\nAdded Scintillation example with scintillating crystals and optical photons\nFixes:\nFixed broken [visualization] examples\nImprove HBC30 example to visualize trajectories in a more smooth manner. Moved it under ext/G4Vis/examples","category":"section"},{"location":"releases/#0.1.7","page":"Release Notes","title":"0.1.7","text":"New features:\nSupport for ARM64 (MacOS M1). Implemented workaround for closures in @safe_cfunction, which were for supported in this  platform. \nAdded support for magnetic field. Additional keyword argument in the G4JLApplication. Added example HBC30 for a simulation of a liquid hydrogen bubble chamber.\nAdded drawing capabilities for G4Polyhedra, G4EllipticalTube, G4Ellipsoid\nFixes:\nFix example WaterPhantom to added to new callback closures","category":"section"},{"location":"releases/#0.1.6","page":"Release Notes","title":"0.1.6","text":"New features:\nRestructured G4Vis as an extension of Geant4.jl. It is automatically loaded when all the required weak dependencies are satisfied (e.g. \"Makie\", \"Colors\", \"StaticArrays\", \"Rotations\", \"LinearAlgebra\")\nAdded missing basic solids including the BooleanSolid\nUsing the IGLWrap_jll binary wrapper to libigl C++ library to draw boolean solids.\nAdded notebook ext/G4Vis/Solids.ipynb to exercise and draw all possible solids (some are still missing)","category":"section"},{"location":"releases/#0.1.5","page":"Release Notes","title":"0.1.5","text":"New features:\nSupport for Multi-threading. New parameter in G4JLApplication to set the number of threads. Default is serial, nthreads = 0\nAdded verbosity level with the argument verbose in G4JLApplication\nFixes:\nFix continuous pre-compilation after moving to Julia 1.9\nFix for embedded figures in notebooks","category":"section"},{"location":"releases/#0.1.4","page":"Release Notes","title":"0.1.4","text":"Added support for scoring with G4JLScoringMesh function\nAdded generation of documentation including running the jupyter notebooks","category":"section"},{"location":"examples/JuliaAction/#Calling-G4-actions-in-Julia","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"This is a very simple example of calling user actions in Julia from a C++ Geant4 application. We define the user actions in Julia language in the file MyCode.jl and call them from the C++ application. The name and signatures of the functions are important since the C++ will associate them in the corresponding inherited classes.\n\nThe C++ code is a single file G4example.cpp that defines the Geant4 the minimal set of classes to run a simulation.\n\nThe main program is responsible of initializing Julia by calling julia_init and loading the Julia code executing.\njl_init()\njl_eval_string(\"include(\\\"MyCode.jl\\\")\");\nEach constructor of a user action class needs to initialize a C++ function pointer to the corresponding Julia function. This is done in the constructor to avoid any dynamic dispatch at runtime. For example, for the EventAction class:\ntypedef  void (*eventaction_f)(const G4Event*);\nclass EventAction : public G4UserEventAction {\n  public:\n    EventAction() {\n        beginevent_jl = (eventaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(begin_of_event_action, Nothing, (CxxPtr{G4Event},))\")));\n        endevent_jl = (eventaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(end_of_event_action, Nothing, (CxxPtr{G4Event},))\")));\n    }\n    ...\n  private:\n    eventaction_f beginevent_jl;\n    eventaction_f endevent_jl;\n};\nFinally the actions are called in the corresponding Geant4 classes. For example in the EventAction class:\nvoid EventAction::BeginOfEventAction(const G4Event* event) {\n    beginevent_jl(event);\n}\n...\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.The C++ code is available as a source file and the Julia code is available as a source file.","category":"section"},{"location":"examples/JuliaAction/#Table-of-contents","page":"Calling G4 actions in Julia","title":"Table of contents","text":"Pages = [\"JuliaAction.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/JuliaAction/#Loading-the-necessary-Julia-modules","page":"Calling G4 actions in Julia","title":"Loading the necessary Julia modules","text":"using Geant4_jll   # Needed to locate the Geant4 installation directory","category":"section"},{"location":"examples/JuliaAction/#Building-G4Example-Application","page":"Calling G4 actions in Julia","title":"Building G4Example Application","text":"The custom library is defined in the C++ file G4example.cpp. It is a single file to facilitate the building of the executable.\n\nThe attribute Geant4_jll.artifact_dir provides the path to the Geant4 installation directory. Sources are in the same location as this script.\n\ncd(@__DIR__)\ng4prefix = Geant4_jll.artifact_dir\njlprefix = dirname(Sys.BINDIR);\n\nWe use the executables geant4-config and julia-config.jl to get the needed libraries and compiler/linker flags.\n\ng4libs = read(`$g4prefix/bin/geant4-config --libs`, String) |> split\nfilter!(x -> x != \"-lG4gdml\", g4libs)\njllibs = read(`$jlprefix/share/julia/julia-config.jl --ldlibs`, String) |> split\nappend!(jllibs, [\"-L$jlprefix/lib\"])\ncflags = read(`$g4prefix/bin/geant4-config --cflags`, String) |> split\nldflags = [\"-Wl,-rpath,$g4prefix/lib\", \"-Wl,-rpath,$jlprefix/lib\"];\nSys.KERNEL == :Linux  && append!(ldflags, [\"-Wl,--no-as-needed\"]);\n\nRun the compilation and link command\n\nBase.run(`c++ -O2 -fPIC $cflags -I$jlprefix/include/julia $ldflags $g4libs $jllibs\n          -o G4example.exe $(@__DIR__)/G4example.cpp`).exitcode == 0 || error(\"Compilation failed\");\n\nIn file included from /opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia.h:73,\n                 from /home/runner/work/Geant4.jl/Geant4.jl/docs/src/examples/G4example.cpp:18:\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/gc-interface.h: In function ‘void jl_gc_wb_fresh(const void*, const void*)’:\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/gc-interface.h:243:47: warning: unused parameter ‘parent’ [-Wunused-parameter]\n  243 | STATIC_INLINE void jl_gc_wb_fresh(const void *parent, const void *ptr) JL_NOTSAFEPOINT {}\n      |                                   ~~~~~~~~~~~~^~~~~~\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/gc-interface.h:243:67: warning: unused parameter ‘ptr’ [-Wunused-parameter]\n  243 | STATIC_INLINE void jl_gc_wb_fresh(const void *parent, const void *ptr) JL_NOTSAFEPOINT {}\n      |                                                       ~~~~~~~~~~~~^~~\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/gc-interface.h: In function ‘void jl_gc_wb_knownold(const void*, const void*)’:\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/gc-interface.h:246:50: warning: unused parameter ‘parent’ [-Wunused-parameter]\n  246 | STATIC_INLINE void jl_gc_wb_knownold(const void *parent, const void *ptr) JL_NOTSAFEPOINT {}\n      |                                      ~~~~~~~~~~~~^~~~~~\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/gc-interface.h:246:70: warning: unused parameter ‘ptr’ [-Wunused-parameter]\n  246 | STATIC_INLINE void jl_gc_wb_knownold(const void *parent, const void *ptr) JL_NOTSAFEPOINT {}\n      |                                                          ~~~~~~~~~~~~^~~\nIn file included from /opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia.h:2446:\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h: In constructor ‘jl_unique_gcsafe_lock::jl_unique_gcsafe_lock(std::mutex&)’:\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h:115:48: warning: declaration of ‘native’ shadows a member of ‘jl_unique_gcsafe_lock’ [-Wshadow]\n  115 |     explicit jl_unique_gcsafe_lock(std::mutex &native) JL_NOTSAFEPOINT_ENTER\n      |                                    ~~~~~~~~~~~~^~~~~~\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h:114:34: note: shadowed declaration is here\n  114 |     std::unique_lock<std::mutex> native;\n      |                                  ^~~~~~\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h: In constructor ‘jl_unique_gcsafe_lock::jl_unique_gcsafe_lock(std::mutex&)’:\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h:115:48: warning: declaration of ‘native’ shadows a member of ‘jl_unique_gcsafe_lock’ [-Wshadow]\n  115 |     explicit jl_unique_gcsafe_lock(std::mutex &native) JL_NOTSAFEPOINT_ENTER\n      |                                    ~~~~~~~~~~~~^~~~~~\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h:114:34: note: shadowed declaration is here\n  114 |     std::unique_lock<std::mutex> native;\n      |                                  ^~~~~~\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h: In constructor ‘jl_unique_gcsafe_lock::jl_unique_gcsafe_lock(std::mutex&)’:\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h:115:48: warning: declaration of ‘native’ shadows a member of ‘jl_unique_gcsafe_lock’ [-Wshadow]\n  115 |     explicit jl_unique_gcsafe_lock(std::mutex &native) JL_NOTSAFEPOINT_ENTER\n      |                                    ~~~~~~~~~~~~^~~~~~\n/opt/hostedtoolcache/julia/1.12.3/x64/include/julia/julia_locks.h:114:34: note: shadowed declaration is here\n  114 |     std::unique_lock<std::mutex> native;\n      |                                  ^~~~~~\n","category":"section"},{"location":"examples/JuliaAction/#Run-the-application","page":"Calling G4 actions in Julia","title":"Run the application","text":"We need to set the variable JULIA_PROJECT pointing to correctly setup Julia environment.\n\nwithenv(\"JULIA_PROJECT\" => \"@.\", \"G4NUMTHREADS\" => \"4\") do\n   Base.run(`./G4example.exe`).exitcode == 0 || error(\"Execution failed\")\nend\n\ntrue","category":"section"},{"location":"examples/JuliaAction/#Display-the-results","page":"Calling G4 actions in Julia","title":"Display the results","text":"println(\"=====> The file edepHist.png should have been saved\")\n\n=====> The file edepHist.png should have been saved\n\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/B4a/#Basic/B4a-Example","page":"Basic/B4a Example","title":"Basic/B4a Example","text":"This example simulates a simple Sampling Calorimeter setup. To demonstrate several possible ways of data scoring, the example is provided in four variants: %B4a, %B4b, %B4c, %B4d. See README file for the example.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/B4a/#Table-of-contents","page":"Basic/B4a Example","title":"Table of contents","text":"Pages = [\"B4a.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/B4a/#Loading-the-necessary-Julia-modules","page":"Basic/B4a Example","title":"Loading the necessary Julia modules","text":"Load the Geant4 and Geant4.SystemOfUnits modules.\n\nusing Geant4\nusing Geant4.SystemOfUnits:  cm, cm3, mm, pGy, eplus, keV, g, eV, MeV, mole\nusing FHist, Plots\n\n# to force loading G4Vis extension we need to load the following module\nusing CairoMakie","category":"section"},{"location":"examples/B4a/#Define-Detector-Parameters-struct","page":"Basic/B4a Example","title":"Define Detector Parameters struct","text":"The B4Detector structure is defined with the default detector parameters.\n\nmutable struct B4aDetector <: G4JLDetector\n    # main input parameters\n    const nofLayers::Int\n    const checkOverlaps::Bool\n    const absoThickness::Float64\n    const gapThickness::Float64\n    const calorSizeXY::Float64\n\n    # constructor with defaults values for parameters\n    function B4aDetector(;      nofLayers::Int=10,\n                                checkOverlaps::Bool=true,\n                                absoThickness::Float64=10mm,\n                                gapThickness::Float64=5mm,\n                                calorSizeXY::Float64=10cm)\n            self = new(nofLayers, checkOverlaps, absoThickness, gapThickness, calorSizeXY)\n        return self\n    end\nend\n_layerThickness(d::B4aDetector) = d.absoThickness + d.gapThickness\n_calorThickness(d::B4aDetector) = d.nofLayers * _layerThickness(d)\n_worldSizeZ(d::B4aDetector) = 1.2 * _calorThickness(d)\n_worldSizeXY(d::B4aDetector) = 1.2 * d.calorSizeXY\n\n_worldSizeXY (generic function with 1 method)","category":"section"},{"location":"examples/B4a/#Defining-the-geometry-constructor","page":"Basic/B4a Example","title":"Defining the geometry constructor","text":"function B4aConstruct(det::B4aDetector)::CxxPtr{G4VPhysicalVolume}\n    (; nofLayers, checkOverlaps, absoThickness, gapThickness, calorSizeXY) = det\n    nist = G4NistManager!Instance()\n\n\n    layerThickness = _layerThickness(det)\n    calorThickness = _calorThickness(det)\n    worldSizeXY = _worldSizeXY(det)\n    worldSizeZ = _worldSizeZ(det)\n\n    G4Material(\"liquidArgon\", z = 18., a = 30.95g/mole, density = 1.390g/cm3)\n\n    defaultMaterial = FindOrBuildMaterial(nist, \"G4_Galactic\")\n    absorberMaterial = FindOrBuildMaterial(nist, \"G4_Pb\")\n    gapMaterial = FindOrBuildMaterial(nist, \"liquidArgon\")\n\n\n\n    worldS = G4Box(\"World\", 0.5 * worldSizeXY, 0.5 * worldSizeXY, 0.5 * worldSizeZ)\n\n    worldLV = G4LogicalVolume(worldS, defaultMaterial, \"WorldLV\")\n\n    worldPV = G4PVPlacement(nothing,          # no rotation\n                            G4ThreeVector(),  # at (0,0,0)\n                            worldLV,          # its logical volume\n                            \"World\",          # its name\n                            nothing,          # its mother volume\n                            false,            # no boolean operation\n                            0,                # copy number\n                            checkOverlaps)    # overlaps checking\n\n##---------------------------------------\n    calorimeterS = G4Box(\"Calorimeter\", 0.5 * calorSizeXY, 0.5 * calorSizeXY, 0.5 * calorThickness)\n\n\n    calorLV = G4LogicalVolume(calorimeterS, defaultMaterial, \"CalorLV\")\n\n    println(calorLV)\n\n    G4PVPlacement(nothing,\n                    G4ThreeVector(),\n                    calorLV,\n                    \"CalorPV\",\n                    worldLV,\n                    false,\n                    0,\n                    checkOverlaps)\n##----------------------------------------------\n\n     layerS = G4Box(\"Layer\",\n                    0.5*calorSizeXY, 0.5*calorSizeXY, 0.5*layerThickness)\n\n     layerLV = G4LogicalVolume(layerS,\n                           defaultMaterial,\n                           \"Layer\")\n\n    G4PVReplica(\"Layer\",\n                  layerLV,\n                  calorLV,\n                  kZAxis,\n                  nofLayers,\n                  layerThickness)\n\n##---------------------------------------------------\n   absorberS = G4Box(\"Abso\",\n                      0.5*calorSizeXY, 0.5*calorSizeXY, 0.5*absoThickness)\n\n    absorberLV = G4LogicalVolume(absorberS, absorberMaterial, \"AbsoLV\")\n\n    G4PVPlacement(nothing,\n                  G4ThreeVector(0., 0., -0.5*gapThickness),\n                    absorberLV,\n                    \"AbsPV\",\n                    layerLV,\n                    false,\n                    0,\n                    checkOverlaps)\n##--------------------------------------\n\n  gapS = G4Box(\"Gap\", 0.5*calorSizeXY, 0.5*calorSizeXY, 0.5*gapThickness)\n\n  gapLV = G4LogicalVolume(gapS, gapMaterial, \"Gap\")\n\n  G4PVPlacement(nothing,\n                G4ThreeVector(0., 0., 0.5*absoThickness),\n                gapLV,\n                \"GapPV\",\n                layerLV,\n                false,\n                0,\n                checkOverlaps)\n\n\n##------------------------------------------\n##Visualization attributes\n    SetVisAttributes(worldLV, G4VisAttributes!GetInvisible())\n    SetVisAttributes(calorLV, G4VisAttributes!GetInvisible())\n\nreturn worldPV              # return a pointer to the G4PhysicalVolume\nend\n\nB4aConstruct (generic function with 1 method)\n\nInstantiate the detector\n\ndetector = B4aDetector()\n\nMain.var\"##277\".B4aDetector(10, true, 10.0, 5.0, 100.0)","category":"section"},{"location":"examples/B4a/#Primary-Particle-Generator","page":"Basic/B4a Example","title":"Primary Particle Generator","text":"worldZHalfLength = _worldSizeZ(detector)/2\nparticlegun = G4JLGunGenerator(particle = \"e-\",\n                               energy = 300MeV,\n                               direction = G4ThreeVector(0., 0., 1.),\n                               position = G4ThreeVector(0,0,-worldZHalfLength))\n\nGeant4.G4JLGunGenerator(\"ParticleGun\", Geant4.G4JLParticleGunData(nothing, \"e-\", G4ThreeVector(0.0,0.0,1.0), G4ThreeVector(0.0,0.0,-90.0), 300.0), Geant4.var\"#init#19\"(), Geant4.var\"#gen#20\"(), Geant4.G4JLGeneratorAction[])","category":"section"},{"location":"examples/B4a/#Defining-the-simulation-data","page":"Basic/B4a Example","title":"Defining the simulation data","text":"const Hist1D64 = Hist1D{Float64}\nmutable struct B4aSimData <: G4JLSimulationData\n    fEnergyDeposit_Abs::Float64\n    fEnergyDeposit_Gap::Float64\n\n    fStepLength_Abs::Float64\n    fStepLength_Gap::Float64\n\n    fEdepHist_Abs::Hist1D64\n    fStepLenHist_Abs::Hist1D64\n\n    fEdepHist_Gap::Hist1D64\n    fStepLenHist_Gap::Hist1D64\n\n    B4aSimData() = new()\nend","category":"section"},{"location":"examples/B4a/#User-Actions","page":"Basic/B4a Example","title":"User Actions","text":"","category":"section"},{"location":"examples/B4a/#Begin-Run-Action","page":"Basic/B4a Example","title":"Begin Run Action","text":"function beginrun(run::G4Run, app::G4JLApplication)::Nothing\n    data = getSIMdata(app)\n\n    data.fEdepHist_Abs = Hist1D(;binedges=100.:1.:300.)\n    data.fStepLenHist_Abs = Hist1D(;binedges=0.:2.:500.)\n\n    data.fEdepHist_Gap = Hist1D(;binedges=0.:1.:200.)\n    data.fStepLenHist_Gap = Hist1D(;binedges=0.:2.:500.)\n    nothing\nend\n\nbeginrun (generic function with 1 method)","category":"section"},{"location":"examples/B4a/#End-Run-Action","page":"Basic/B4a Example","title":"End Run Action","text":"function endrun(run::G4Run, app::G4JLApplication)::Nothing\n    nothing\nend\n\nendrun (generic function with 1 method)","category":"section"},{"location":"examples/B4a/#Begin-Event-Action","page":"Basic/B4a Example","title":"Begin Event Action","text":"function beginevent(evt::G4Event, app::G4JLApplication)\n    G4JL_println(\"===============started event $(evt |> GetEventID)\")\n    data = getSIMdata(app)\n    data.fEnergyDeposit_Abs = 0.0\n    data.fStepLength_Abs = 0.0\n\n    data.fEnergyDeposit_Gap = 0.0\n    data.fStepLength_Gap = 0.0\n    return\nend\n\nbeginevent (generic function with 1 method)\n\n###End event action\n\nfunction endevent(evt::G4Event, app::G4JLApplication)\n    data = getSIMdata(app)\n#     G4JL_println(\"AbsEdep: $(data.fEnergyDeposit_Abs)\")\n#     println(\"AbsStepLength: \", data.fStepLength_Abs)\n\n    push!(data.fEdepHist_Abs, data.fEnergyDeposit_Abs)\n    push!(data.fStepLenHist_Abs, data.fStepLength_Abs)\n\n    push!(data.fEdepHist_Gap, data.fEnergyDeposit_Gap)\n    push!(data.fStepLenHist_Gap, data.fStepLength_Gap)\n\n    println(\"Total Energy deposited in Absorber: \",data.fEnergyDeposit_Abs)\n    println(\"Total Energy deposited in Gaps: \", data.fEnergyDeposit_Gap)\n    G4JL_println(\"================event ended $(evt |> GetEventID) \\n\")\n    return\nend\n\nendevent (generic function with 1 method)","category":"section"},{"location":"examples/B4a/#Stepping-Action","page":"Basic/B4a Example","title":"Stepping Action","text":"function stepaction(step::G4Step, app::G4JLApplication)\n    data = getSIMdata(app)\n\n    volume = step |> GetPreStepPoint |> GetPhysicalVolume |> GetName\n    edep = step |> GetTotalEnergyDeposit\n\n    stepLength = 0\n    if step |> GetTrack |> GetDefinition |> GetPDGCharge != 0.\n        stepLength = step |> GetStepLength\n    end\n\n    if volume[] == \"AbsPV\"\n        data.fEnergyDeposit_Abs += edep\n        data.fStepLength_Abs += stepLength\n    end\n\n    if volume[] == \"GapPV\"\n        data.fEnergyDeposit_Gap += edep\n        data.fStepLength_Gap += stepLength\n    end\n    return\nend\n\nstepaction (generic function with 1 method)","category":"section"},{"location":"examples/B4a/#Making-the-Application","page":"Basic/B4a Example","title":"Making the Application","text":"evtdisplay   = G4JLEventDisplay(joinpath(@__DIR__, \"B4aVis.jl\"))\nGeant4.getConstructor(::B4aDetector)::Function = B4aConstruct\napp = G4JLApplication(detector = detector,               # detector with parameters\n                      simdata = B4aSimData(),            # simulation data\n                      generator = particlegun,           # primary particle generator\n                      nthreads = 0,                      # # of threads (0 = no MT)\n                      physics_type = FTFP_BERT,          # what physics list to instantiate\n                      evtdisplay   = evtdisplay,         # event display\n                      stepaction_method = stepaction,\n                      beginrunaction_method = beginrun,  # begin-run action (initialize counters and histograms)\n                      endrunaction_method = endrun,\n                      begineventaction_method=beginevent,\n                      endeventaction_method = endevent\n                     )\n\nconfigure(app)\ninitialize(app)\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\nGeant4.G4LogicalVolumeAllocated(Ptr{Nothing}(0x0000000007311e60))\nChecking overlaps for volume CalorPV:0 (G4Box) ... OK! \nChecking overlaps for volume AbsPV:0 (G4Box) ... OK! \nChecking overlaps for volume GapPV:0 (G4Box) ... OK! \n","category":"section"},{"location":"examples/B4a/#Run-the-Example","page":"Basic/B4a Example","title":"Run the Example","text":"Run a single event and display it\n\n# ui`/tracking/verbose 1`\nbeamOn(app,1)\n\n(Image: )\n\nRun for 100 events\n\nbeamOn(app, 100)\n\n===============started event 0\nTotal Energy deposited in Absorber: 271.5302704609608\nTotal Energy deposited in Gaps: 22.247044337367168\n================event ended 0 \n\n===============started event 1\nTotal Energy deposited in Absorber: 274.6097012437138\nTotal Energy deposited in Gaps: 8.849499385274473\n================event ended 1 \n\n===============started event 2\nTotal Energy deposited in Absorber: 272.96409020278264\nTotal Energy deposited in Gaps: 7.620688171941664\n================event ended 2 \n\n===============started event 3\nTotal Energy deposited in Absorber: 276.3075115649578\nTotal Energy deposited in Gaps: 14.617492816857656\n================event ended 3 \n\n===============started event 4\nTotal Energy deposited in Absorber: 271.30106988196525\nTotal Energy deposited in Gaps: 9.649821775814084\n================event ended 4 \n\n===============started event 5\nTotal Energy deposited in Absorber: 277.50875635543196\nTotal Energy deposited in Gaps: 12.028791713243322\n================event ended 5 \n\n===============started event 6\nTotal Energy deposited in Absorber: 276.2774023842731\nTotal Energy deposited in Gaps: 10.873744405847377\n================event ended 6 \n\n===============started event 7\nTotal Energy deposited in Absorber: 272.58335738273445\nTotal Energy deposited in Gaps: 16.504516172365314\n================event ended 7 \n\n===============started event 8\nTotal Energy deposited in Absorber: 268.56514501628266\nTotal Energy deposited in Gaps: 9.374397195957695\n================event ended 8 \n\n===============started event 9\nTotal Energy deposited in Absorber: 266.60954854589994\nTotal Energy deposited in Gaps: 20.03420842145821\n================event ended 9 \n\n===============started event 10\nTotal Energy deposited in Absorber: 264.6632888805728\nTotal Energy deposited in Gaps: 19.89085973304624\n================event ended 10 \n\n===============started event 11\nTotal Energy deposited in Absorber: 261.1659043839921\nTotal Energy deposited in Gaps: 25.96207683323858\n================event ended 11 \n\n===============started event 12\nTotal Energy deposited in Absorber: 263.9113355442207\nTotal Energy deposited in Gaps: 12.086460646878681\n================event ended 12 \n\n===============started event 13\nTotal Energy deposited in Absorber: 275.47935757157643\nTotal Energy deposited in Gaps: 5.585884189308387\n================event ended 13 \n\n===============started event 14\nTotal Energy deposited in Absorber: 266.66981722234993\nTotal Energy deposited in Gaps: 17.708362841557456\n================event ended 14 \n\n===============started event 15\nTotal Energy deposited in Absorber: 265.13480458927836\nTotal Energy deposited in Gaps: 5.078813905447857\n================event ended 15 \n\n===============started event 16\nTotal Energy deposited in Absorber: 280.14444323065277\nTotal Energy deposited in Gaps: 13.517502162242703\n================event ended 16 \n\n===============started event 17\nTotal Energy deposited in Absorber: 273.90318511946424\nTotal Energy deposited in Gaps: 13.841553385175665\n================event ended 17 \n\n===============started event 18\nTotal Energy deposited in Absorber: 285.46817801987845\nTotal Energy deposited in Gaps: 7.1652911510377315\n================event ended 18 \n\n===============started event 19\nTotal Energy deposited in Absorber: 285.42631393208654\nTotal Energy deposited in Gaps: 10.866951511295085\n================event ended 19 \n\n===============started event 20\nTotal Energy deposited in Absorber: 264.32736231604133\nTotal Energy deposited in Gaps: 7.495083390595656\n================event ended 20 \n\n===============started event 21\nTotal Energy deposited in Absorber: 269.46034862233734\nTotal Energy deposited in Gaps: 19.89924842626208\n================event ended 21 \n\n===============started event 22\nTotal Energy deposited in Absorber: 255.9006794410447\nTotal Energy deposited in Gaps: 28.224088019024187\n================event ended 22 \n\n===============started event 23\nTotal Energy deposited in Absorber: 274.8331245850757\nTotal Energy deposited in Gaps: 13.10464787804353\n================event ended 23 \n\n===============started event 24\nTotal Energy deposited in Absorber: 275.6724503633872\nTotal Energy deposited in Gaps: 9.339361020438217\n================event ended 24 \n\n===============started event 25\nTotal Energy deposited in Absorber: 273.14975600312204\nTotal Energy deposited in Gaps: 7.898540249163019\n================event ended 25 \n\n===============started event 26\nTotal Energy deposited in Absorber: 277.0518247299117\nTotal Energy deposited in Gaps: 13.686805942376653\n================event ended 26 \n\n===============started event 27\nTotal Energy deposited in Absorber: 268.4485795022632\nTotal Energy deposited in Gaps: 9.262851680748316\n================event ended 27 \n\n===============started event 28\nTotal Energy deposited in Absorber: 274.56249975416995\nTotal Energy deposited in Gaps: 14.93133636957628\n================event ended 28 \n\n===============started event 29\nTotal Energy deposited in Absorber: 273.26332532863916\nTotal Energy deposited in Gaps: 6.758370170409846\n================event ended 29 \n\n===============started event 30\nTotal Energy deposited in Absorber: 263.28576822444046\nTotal Energy deposited in Gaps: 18.868108272301328\n================event ended 30 \n\n===============started event 31\nTotal Energy deposited in Absorber: 263.9778187057986\nTotal Energy deposited in Gaps: 14.938126535798482\n================event ended 31 \n\n===============started event 32\nTotal Energy deposited in Absorber: 268.53954399514924\nTotal Energy deposited in Gaps: 10.715023637743306\n================event ended 32 \n\n===============started event 33\nTotal Energy deposited in Absorber: 265.1286202168488\nTotal Energy deposited in Gaps: 15.258216100981054\n================event ended 33 \n\n===============started event 34\nTotal Energy deposited in Absorber: 283.369632056252\nTotal Energy deposited in Gaps: 9.059658581663804\n================event ended 34 \n\n===============started event 35\nTotal Energy deposited in Absorber: 265.69368231913654\nTotal Energy deposited in Gaps: 25.457531655081898\n================event ended 35 \n\n===============started event 36\nTotal Energy deposited in Absorber: 287.29181810181876\nTotal Energy deposited in Gaps: 9.81425407940541\n================event ended 36 \n\n===============started event 37\nTotal Energy deposited in Absorber: 279.82455974625196\nTotal Energy deposited in Gaps: 9.515392827128693\n================event ended 37 \n\n===============started event 38\nTotal Energy deposited in Absorber: 274.830992769914\nTotal Energy deposited in Gaps: 22.05029324833358\n================event ended 38 \n\n===============started event 39\nTotal Energy deposited in Absorber: 280.2751679219884\nTotal Energy deposited in Gaps: 8.185210446275084\n================event ended 39 \n\n===============started event 40\nTotal Energy deposited in Absorber: 268.431546034184\nTotal Energy deposited in Gaps: 21.10387110732702\n================event ended 40 \n\n===============started event 41\nTotal Energy deposited in Absorber: 276.51491505734293\nTotal Energy deposited in Gaps: 11.831995291496469\n================event ended 41 \n\n===============started event 42\nTotal Energy deposited in Absorber: 275.91548644033065\nTotal Energy deposited in Gaps: 13.836939077590575\n================event ended 42 \n\n===============started event 43\nTotal Energy deposited in Absorber: 266.1100444061175\nTotal Energy deposited in Gaps: 10.463924297030259\n================event ended 43 \n\n===============started event 44\nTotal Energy deposited in Absorber: 235.38805703709855\nTotal Energy deposited in Gaps: 14.368025269709882\n================event ended 44 \n\n===============started event 45\nTotal Energy deposited in Absorber: 280.73941056822775\nTotal Energy deposited in Gaps: 10.821263658533569\n================event ended 45 \n\n===============started event 46\nTotal Energy deposited in Absorber: 252.7537458555065\nTotal Energy deposited in Gaps: 18.86936281697088\n================event ended 46 \n\n===============started event 47\nTotal Energy deposited in Absorber: 262.6618329377232\nTotal Energy deposited in Gaps: 10.881715980763683\n================event ended 47 \n\n===============started event 48\nTotal Energy deposited in Absorber: 267.5603007432256\nTotal Energy deposited in Gaps: 16.081054176471376\n================event ended 48 \n\n===============started event 49\nTotal Energy deposited in Absorber: 247.69734357784904\nTotal Energy deposited in Gaps: 31.20048383086373\n================event ended 49 \n\n===============started event 50\nTotal Energy deposited in Absorber: 287.54933045810725\nTotal Energy deposited in Gaps: 7.660629990581378\n================event ended 50 \n\n===============started event 51\nTotal Energy deposited in Absorber: 276.2145872190434\nTotal Energy deposited in Gaps: 8.823261810096348\n================event ended 51 \n\n===============started event 52\nTotal Energy deposited in Absorber: 282.9363728704208\nTotal Energy deposited in Gaps: 10.509016573086056\n================event ended 52 \n\n===============started event 53\nTotal Energy deposited in Absorber: 280.1348800668081\nTotal Energy deposited in Gaps: 12.211694301407004\n================event ended 53 \n\n===============started event 54\nTotal Energy deposited in Absorber: 268.4454006318798\nTotal Energy deposited in Gaps: 26.633374332581337\n================event ended 54 \n\n===============started event 55\nTotal Energy deposited in Absorber: 265.63042192729864\nTotal Energy deposited in Gaps: 26.9953598950771\n================event ended 55 \n\n===============started event 56\nTotal Energy deposited in Absorber: 262.8087617810532\nTotal Energy deposited in Gaps: 23.24308472322126\n================event ended 56 \n\n===============started event 57\nTotal Energy deposited in Absorber: 281.8425818009749\nTotal Energy deposited in Gaps: 7.137476093932297\n================event ended 57 \n\n===============started event 58\nTotal Energy deposited in Absorber: 243.86358870779446\nTotal Energy deposited in Gaps: 28.573968849496776\n================event ended 58 \n\n===============started event 59\nTotal Energy deposited in Absorber: 275.5898767996863\nTotal Energy deposited in Gaps: 8.329332678242565\n================event ended 59 \n\n===============started event 60\nTotal Energy deposited in Absorber: 271.85918936550274\nTotal Energy deposited in Gaps: 19.34917606355801\n================event ended 60 \n\n===============started event 61\nTotal Energy deposited in Absorber: 271.2447400994799\nTotal Energy deposited in Gaps: 9.949441514710973\n================event ended 61 \n\n===============started event 62\nTotal Energy deposited in Absorber: 267.93068775530514\nTotal Energy deposited in Gaps: 5.725603223230712\n================event ended 62 \n\n===============started event 63\nTotal Energy deposited in Absorber: 257.2280915823931\nTotal Energy deposited in Gaps: 10.256436585685329\n================event ended 63 \n\n===============started event 64\nTotal Energy deposited in Absorber: 281.6129218959985\nTotal Energy deposited in Gaps: 12.996706339772318\n================event ended 64 \n\n===============started event 65\nTotal Energy deposited in Absorber: 251.20371209563345\nTotal Energy deposited in Gaps: 32.16117766217677\n================event ended 65 \n\n===============started event 66\nTotal Energy deposited in Absorber: 284.4041463408074\nTotal Energy deposited in Gaps: 10.090488441725848\n================event ended 66 \n\n===============started event 67\nTotal Energy deposited in Absorber: 263.96035778323574\nTotal Energy deposited in Gaps: 29.661540305699255\n================event ended 67 \n\n===============started event 68\nTotal Energy deposited in Absorber: 269.59921664642326\nTotal Energy deposited in Gaps: 18.631364935382752\n================event ended 68 \n\n===============started event 69\nTotal Energy deposited in Absorber: 278.5687630954204\nTotal Energy deposited in Gaps: 11.51049790485247\n================event ended 69 \n\n===============started event 70\nTotal Energy deposited in Absorber: 274.8020097846883\nTotal Energy deposited in Gaps: 10.387141954806443\n================event ended 70 \n\n===============started event 71\nTotal Energy deposited in Absorber: 274.7764611985769\nTotal Energy deposited in Gaps: 8.379843245123523\n================event ended 71 \n\n===============started event 72\nTotal Energy deposited in Absorber: 276.18848861009263\nTotal Energy deposited in Gaps: 13.810238428951555\n================event ended 72 \n\n===============started event 73\nTotal Energy deposited in Absorber: 279.7210296261763\nTotal Energy deposited in Gaps: 14.96372127532957\n================event ended 73 \n\n===============started event 74\nTotal Energy deposited in Absorber: 272.7647309025295\nTotal Energy deposited in Gaps: 14.71608231620604\n================event ended 74 \n\n===============started event 75\nTotal Energy deposited in Absorber: 276.59083247132884\nTotal Energy deposited in Gaps: 13.359287840739055\n================event ended 75 \n\n===============started event 76\nTotal Energy deposited in Absorber: 264.80242468370795\nTotal Energy deposited in Gaps: 29.84032267622901\n================event ended 76 \n\n===============started event 77\nTotal Energy deposited in Absorber: 284.68184990270333\nTotal Energy deposited in Gaps: 12.705001390678385\n================event ended 77 \n\n===============started event 78\nTotal Energy deposited in Absorber: 289.9678545924821\nTotal Energy deposited in Gaps: 4.54552596970594\n================event ended 78 \n\n===============started event 79\nTotal Energy deposited in Absorber: 273.3873666184511\nTotal Energy deposited in Gaps: 10.430262513371451\n================event ended 79 \n\n===============started event 80\nTotal Energy deposited in Absorber: 285.65292276101906\nTotal Energy deposited in Gaps: 6.5432094526258595\n================event ended 80 \n\n===============started event 81\nTotal Energy deposited in Absorber: 275.3393433817967\nTotal Energy deposited in Gaps: 6.92015130244125\n================event ended 81 \n\n===============started event 82\nTotal Energy deposited in Absorber: 270.0656844257361\nTotal Energy deposited in Gaps: 18.078974811282755\n================event ended 82 \n\n===============started event 83\nTotal Energy deposited in Absorber: 277.1458536549407\nTotal Energy deposited in Gaps: 10.296917367794205\n================event ended 83 \n\n===============started event 84\nTotal Energy deposited in Absorber: 276.89626825343134\nTotal Energy deposited in Gaps: 14.91789582027482\n================event ended 84 \n\n===============started event 85\nTotal Energy deposited in Absorber: 272.55492005653076\nTotal Energy deposited in Gaps: 14.266470394104385\n================event ended 85 \n\n===============started event 86\nTotal Energy deposited in Absorber: 288.0235261121361\nTotal Energy deposited in Gaps: 8.451586174889467\n================event ended 86 \n\n===============started event 87\nTotal Energy deposited in Absorber: 264.69907610278176\nTotal Energy deposited in Gaps: 9.55716411814127\n================event ended 87 \n\n===============started event 88\nTotal Energy deposited in Absorber: 278.4155437798181\nTotal Energy deposited in Gaps: 12.387640581532821\n================event ended 88 \n\n===============started event 89\nTotal Energy deposited in Absorber: 269.47328536785307\nTotal Energy deposited in Gaps: 7.260328638944791\n================event ended 89 \n\n===============started event 90\nTotal Energy deposited in Absorber: 260.4511929400287\nTotal Energy deposited in Gaps: 22.793401266537025\n================event ended 90 \n\n===============started event 91\nTotal Energy deposited in Absorber: 279.6722220733974\nTotal Energy deposited in Gaps: 12.755540091185122\n================event ended 91 \n\n===============started event 92\nTotal Energy deposited in Absorber: 270.87815689997666\nTotal Energy deposited in Gaps: 10.364716281417099\n================event ended 92 \n\n===============started event 93\nTotal Energy deposited in Absorber: 279.5137884708\nTotal Energy deposited in Gaps: 10.309408469483841\n================event ended 93 \n\n===============started event 94\nTotal Energy deposited in Absorber: 284.2969184748863\nTotal Energy deposited in Gaps: 14.137393326582005\n================event ended 94 \n\n===============started event 95\nTotal Energy deposited in Absorber: 286.76226032277134\nTotal Energy deposited in Gaps: 8.626755674946576\n================event ended 95 \n\n===============started event 96\nTotal Energy deposited in Absorber: 277.94654265404256\nTotal Energy deposited in Gaps: 14.942657765708086\n================event ended 96 \n\n===============started event 97\nTotal Energy deposited in Absorber: 259.93769471623136\nTotal Energy deposited in Gaps: 13.891338298218164\n================event ended 97 \n\n===============started event 98\nTotal Energy deposited in Absorber: 264.202396766432\nTotal Energy deposited in Gaps: 22.948150076431723\n================event ended 98 \n\n===============started event 99\nTotal Energy deposited in Absorber: 275.7902709947264\nTotal Energy deposited in Gaps: 17.515152162298065\n================event ended 99 \n\n","category":"section"},{"location":"examples/B4a/#Plotting-the-histograms","page":"Basic/B4a Example","title":"Plotting the histograms","text":"data = getSIMdata(app)\nlay = @layout [°; °; °; °]\nimg = Plots.plot(layout=lay, show=true, size=(800,1000))\n\nPlots.plot!(subplot=1, data.fEdepHist_Abs, title=\"Total EDep in Absorber\", xlabel=\"Edep (MeV)\", label=\"Abs Edep\", show=true)\nPlots.plot!(subplot=2, data.fEdepHist_Gap, title=\"Total EDep in Gaps\", xlabel=\"Edep (MeV)\", label=\"Gap_Edep\", show=true)\n\nPlots.plot!(subplot=3, data.fStepLenHist_Abs, title=\"Total StepLeng in Absorbers\", xlabel=\"Step Length (mm)\", label=\"Abs_StepLen\", show=true)\nPlots.plot!(subplot=4, data.fStepLenHist_Gap, title=\"Total StepLeng in Gaps\", xlabel=\"Step Length (mm)\", label=\"Gap_StepLen\", show=true)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"Documentation for Geant4.jl public interface.","category":"section"},{"location":"api/#Index-Types","page":"Public API","title":"Index - Types","text":"Pages   = [\"api.md\"]\nModules = [Geant4]\nOrder   = [:type]","category":"section"},{"location":"api/#Index-Functions","page":"Public API","title":"Index - Functions","text":"Pages   = [\"api.md\"]\nModules = [Geant4]\nOrder   = [:function]","category":"section"},{"location":"api/#Types","page":"Public API","title":"Types","text":"","category":"section"},{"location":"api/#Functions","page":"Public API","title":"Functions","text":"","category":"section"},{"location":"api/#Geant4.G4JLApplication-Tuple{}","page":"Public API","title":"Geant4.G4JLApplication","text":"G4JLApplication(<keyword arguments>)\n\nInitialize a G4JLApplication with its associated tyopes and methods.\n\nArguments\n\ndetector::G4JLDetector: detector description object\nsimdata=G4JLNoData(): simulation data object\ngenerator=G4JLParticleGun(): primary particle generator\nfield=nothing: magnetic field\nevtdisplay=nothing: event display (visualization)\nnthreads=0: number of Geant4 worker threads ( >0 implies MT)\nverbose=0 : default verbority level (physics, ...)\nrunmanager_type=G4RunManager: run manager type\nbuilder_type=G4JLDetectorConstruction: detector builder type (the default should be fine most cases)\nphysics_type=FTFP_BERT: physics list type\nstepaction_type=G4JLSteppingAction: stepping action type (the default should be fine most cases)\ntrackaction_type=G4JLTrackingAction: rtacking action type (the default should be fine most cases)\nrunaction_type=G4JLRunAction: run action type (the default should be fine most cases)\neventaction_type=G4JLEventAction: event action type (the default should be fine most cases)\nstepaction_method=nothing: stepping action method with signature (::G4Step, ::G4JLApplication)::Nothing\npretrackaction_method=nothing: pre-tracking action method with signature (::G4Track, ::G4JLApplication)::Nothing\nposttrackaction_method=nothing: post-tracking action method with signature (::G4Track, ::G4JLApplication)::Nothing\nbeginrunaction_method=nothing: begin run action method with signature (::G4Run, ::G4JLApplication)::Nothing\nendrunaction_method=nothing: end run action method with signature (::G4Run, ::G4JLApplication)::Nothing\nbegineventaction_method=nothing: begin event action method with signature (::G4Event, ::G4JLApplication)::Nothing\nendeventaction_method=nothing: end event action method with signature (::G4Event, ::G4JLApplication)::Nothing\nstackaction_method=nothing: stacking classification of new track with signature (::G4Track, ::G4JLApplication)::G4ClassificationOfNewTrack\nstatechange_method=nothing: state change notifycation method with  signature (from::G4ApplicationState, to::G4ApplicationState, ::G4JLApplication)::Bool\nsdetectors::Vector{}=[]: vector of pairs lv::String => sd::G4JLSensitiveDetector to associate logical volumes to sensitive detector\nscorers::Vector{}=[]: vector of G4JLScoringMeshs\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLDetectorGDML-Tuple{String}","page":"Public API","title":"Geant4.G4JLDetectorGDML","text":"G4JLDetectorGDML(gdmlfile::String; check_overlap::Bool, validate_schema::Bool, init_method::Union{Function,Nothing})\n\nInitialize a G4JLDetector from a GDML file. The GDML file is parsed at this moment.\n\nArguments\n\ngdmlfile::String: GDML file name\ncheck_overlap::Bool=false: check for overlaps\nvalidate_schema::Bool=true: validate the schema\ninit_method::Union{Function,Nothing}=nothing: initialization method to be called when the detector is constructed\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLMagneticField","page":"Public API","title":"Geant4.G4JLMagneticField","text":"Custom Magnetic Field\n\n\n\n\n\n","category":"type"},{"location":"api/#Geant4.G4JLMagneticField-Union{Tuple{CLHEP!Hep3Vector}, Tuple{G4JLUniformMagFieldData}} where G4JLUniformMagFieldData","page":"Public API","title":"Geant4.G4JLMagneticField","text":"G4JLUniformMagField(field::G4ThreeVector)\n\nCreate a Uniform magnetic field\n\nArguments\n\nfield::G4ThreeVector: magnetic field vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLMagneticField-Union{Tuple{T}, Tuple{String, T}} where T<:G4JLFieldData","page":"Public API","title":"Geant4.G4JLMagneticField","text":"G4JLMagneticField(name::String, data::DATA; <keyword arguments>) where DATA<:G4JLGeneratorData\n\nCreate a G4JLMagneticField with its name and associated DATA structure\n\nArguments\n\nname::String: magnetic field name\ndata::DATA: data structure associated to the magnetic field\ngetfield_method=nothing: user provided getfield function with signature: (result::G4ThreeVector, position::G4ThreeVector, ::DATA)\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLPrimaryGenerator-Union{Tuple{T}, Tuple{String, T}} where T<:G4JLGeneratorData","page":"Public API","title":"Geant4.G4JLPrimaryGenerator","text":"G4JLPrimaryGenerator(name::String, data::DATA; <keyword arguments>) where DATA<:G4JLGeneratorData\n\nCreatre a G4JLPrimaryGenerator with its name and associated DATA structure\n\nArguments\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLScoringMesh-Union{Tuple{M}, Tuple{String, M}} where M<:Geant4.AbstractMesh","page":"Public API","title":"Geant4.G4JLScoringMesh","text":"G4JLScoringMesh(name, mesh; <keyword arguments>)\n\nCreate a scoring mesh to be added to the Geant4 application.\n\nArguments\n\nname::String: scoring mech name\nmesh::AbstractMesh: mesh instance. Either a BoxMesh or CylinderMesh\nbins::Tuple: tuple with number on bins in x, y, z (default 30, 30, 30)\ntranslation::Tuple: position (x,y,z) with respect the mesh respect to the world volume. Default is  (0,0,0).\nrotation::Tuple: rotation of the mesh with respect the world volume. Default (0,0,0)\nquantities::Vector: vector of quanties to be scored (e.g. energyDeposit, doseDeposit, nOfStep)\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLSensitiveDetector-Union{Tuple{T}, Tuple{String, T}} where T<:G4JLSDData","page":"Public API","title":"Geant4.G4JLSensitiveDetector","text":"G4JLSensitiveDetector(name::String, data::DATA; <keyword arguments>) where DATA<:G4JLSDData\n\nInitialize a G4JLSensitiveDetector with its name and associated DATA structure.\n\nArguments\n\nname::String: Sensitive detector name\ndata::DATA: Data structure associted to the sensitive detector\nprocesshits_method=nothing: processHit function with signature: (data::DATA, step::G4Step, ::G4TouchableHistory)::Bool\ninitialize_method=nothing: intialize function with signature: (data::DATA, ::G4HCofThisEvent)::Nothing\nendofevent_method=nothing: endOfEvent function with signature: (data::DATA, ::G4HCofThisEvent)::Nothing \n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JL_println","page":"Public API","title":"Geant4.G4JL_println","text":"G4JL_println(::AbstractString)\n\nPrint the string to the Geant4 output in a thread safe manner prefixing the string with the thread ID.\n\nArguments\n\ns::AbstractString: string to be printed\n\n\n\n\n\n","category":"function"},{"location":"api/#Geant4.GetVolume-Tuple{String}","page":"Public API","title":"Geant4.GetVolume","text":"GetVolume(name::String)\n\nGet the  the G4LogicalVolume with this name.\n\nArguments\n\nname::String: logical volume name\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.GetWorldVolume-Tuple{}","page":"Public API","title":"Geant4.GetWorldVolume","text":"GetWorldVolume()\n\nGet the world volume of the currently instantiated detector geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.beamOn-Tuple{G4JLApplication, Int64}","page":"Public API","title":"Geant4.beamOn","text":"beamOn(app::G4JLApplication, nevents::Int)\n\nStart a new run with nevents events. In case of multi-threading, the function enters a GC safe state before starting the run.\n\nArguments\n\napp::G4JLApplication: Geant4 application\nnevents::Int: number of events\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.configure-Tuple{G4JLApplication}","page":"Public API","title":"Geant4.configure","text":"configure(app::G4JLApplication)\n\nConfigure the Geant4 application. It sets the declared user actions, event generator, and physcis list.\n\nArguments\n\napp::G4JLApplication: Geant4 application\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.getSDdata-Tuple{Any, Any}","page":"Public API","title":"Geant4.getSDdata","text":"getSDdata(app::G4JLApplication, name::String)\n\nGet the data associated to the Sentitive Detector with a given name taking into account the current worker thread ID\n\nArguments\n\napp::G4JLApplication: Geant4 application\nname::String: sensitive detector name\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.getSIMdata-Tuple{Any}","page":"Public API","title":"Geant4.getSIMdata","text":"getSIMdata(app::G4JLApplication)\n\nGet the Simulation Data taking into account the current worker thread ID\n\nArguments\n\napp::G4JLApplication: Geant4 application\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.getfield-Tuple{CLHEP!Hep3Vector, G4JLMagneticField}","page":"Public API","title":"Geant4.getfield","text":"getfield(pos::G4ThreeVector, bfield::G4JLMagneticField)\n\nFunction to exercise a custom magnetic field\n\nArguments\n\npos::G4ThreeVector: position\nbfield::G4JLMagneticField: magnetic field object\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.initialize-Tuple{G4JLApplication}","page":"Public API","title":"Geant4.initialize","text":"initialize(app::G4JLApplication)\n\nInitialize the Geant4 application. It initializes the G4RunManager, which constructs the detector geometry, and sets  the declared sensitive detectors. In case of multi-threading, the function enters a GC safe state before initializing the application, which will be calling thebuild()` functions by the worker threads.\n\nArguments\n\napp::G4JLApplication: Geant4 application\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.move!-Tuple{Any}","page":"Public API","title":"Geant4.move!","text":"move!(o)\n\nMove ownerhip of C++ object to receiver. The object cannot not be used anymore after this call.\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.reinitialize-Tuple{G4JLApplication, G4JLDetector}","page":"Public API","title":"Geant4.reinitialize","text":"reinitialize(app::G4JLApplication, det::G4JLDetector)\n\nRe-initialize the Geant4 application with a new detector defintion.\n\nArguments\n\napp::G4JLApplication: Geant4 application\ndet::G4JLDetector: new detector definition\n\n\n\n\n\n","category":"method"},{"location":"examples/B1/#Basic/B1-Example","page":"Basic/B1 Example","title":"Basic/B1 Example","text":"In this example is based on the Geant4 basic/B1 example of the Geant4 distribution. It is a simple example that shows how to interact with the Geant4 classes. The example uses the native interface emulating the C++ code.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/B1/#Table-of-contents","page":"Basic/B1 Example","title":"Table of contents","text":"Pages = [\"B1.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/B1/#Loading-the-necessary-Julia-modules","page":"Basic/B1 Example","title":"Loading the necessary Julia modules","text":"Load the Geant4 and Geant4.SystemOfUnits modules\n\nusing Geant4\nusing Geant4.SystemOfUnits","category":"section"},{"location":"examples/B1/#Define-the-Detector-Construction","page":"Basic/B1 Example","title":"Define the Detector Construction","text":"Define the function that will construct the detector geometry. The setup consists of a an envelope of box shape containing two volumes: a spherical cone and a trapezoid.\n\nIn this example we use  some common materials materials for medical applications. The envelope is made of water and the two inner volumes are made from tissue and bone materials. The materials are created with the help of the G4NistManager class, which allows to build a material from the NIST database using their names. All available materials can be found in the Geant4 User's Guide for Application Developers, Appendix 10: Geant4 Materials Database. detector construction class B1DetectorConstruction that inherits from G4VUserDetectorConstruction\n\nfunction constructB1Detector(::Nothing)::CxxPtr{G4VPhysicalVolume}\n    nist = G4NistManager!Instance()\n\n    # Envelope parameters\n    env_sizeXY = 20cm\n    env_sizeZ  = 30cm\n    env_mat    = FindOrBuildMaterial(nist, \"G4_WATER\")\n\n    # Option to switch on/off checking of volumes overlaps\n    checkOverlaps = true\n\n    # World\n    world_sizeXY = 1.2*env_sizeXY\n    world_sizeZ  = 1.2*env_sizeZ\n    world_mat = FindOrBuildMaterial(nist, \"G4_AIR\")\n\n    solidworld = G4Box(\"World\", 0.5 * world_sizeXY, 0.5 * world_sizeXY, 0.5 * world_sizeZ)\n    logicworld = G4LogicalVolume(solidworld, world_mat, \"World\")\n\n    physWorld = G4PVPlacement(nothing,          ## no rotation\n                              G4ThreeVector(),  ## at (0,0,0)\n                              logicworld,       ## its logical volume\n                              \"World\",          ## its name\n                              nothing,          ## its mother volume\n                              false,            ## no boolean operation\n                              0,                ## copy number\n                              checkOverlaps)    ## overlaps checking\n\n    # Envelope\n    solidEnv = G4Box(\"Envelope\", 0.5 * env_sizeXY, 0.5 * env_sizeXY, 0.5 * env_sizeZ)\n    logicEnv = G4LogicalVolume(solidEnv, env_mat, \"Envelope\")\n\n    G4PVPlacement(nothing,           ## no rotation\n                  G4ThreeVector(),   ## at (0,0,0)\n                  logicEnv,          ## its logical volume\n                  \"Envelope\",        ## its name\n                  logicworld,        ## its mother  volume\n                  false,             ## no boolean operation\n                  0,                 ## copy number\n                  checkOverlaps)     ## overlaps checking\n    # shape 1\n    shape1_mat = FindOrBuildMaterial(nist, \"G4_A-150_TISSUE\")\n    pos1 = G4ThreeVector(0, 2cm, -7cm)\n\n    # Conical section shape\n    shape1_rmina =  0cm; shape1_rmaxa = 2cm\n    shape1_rminb =  0cm; shape1_rmaxb = 4cm\n    shape1_hz = 3cm\n    shape1_phimin = 0deg; shape1_phimax = 360deg\n\n    solidShape1 = G4Cons(\"Shape1\", shape1_rmina, shape1_rmaxa, shape1_rminb, shape1_rmaxb,\n                  shape1_hz, shape1_phimin, shape1_phimax)\n\n    logicShape1 = G4LogicalVolume(solidShape1, shape1_mat, \"Shape1\")\n    G4PVPlacement(nothing,      ## no rotation\n                  pos1,         ## at position\n                  logicShape1,  ## its logical volume\n                  \"Shape1\",     ## its name\n                  logicEnv,     ## its mother  volume\n                  false,        ## no boolean operation\n                  0,            ## copy number\n                  checkOverlaps)## overlaps checking\n    # Shape 2\n    shape2_mat = FindOrBuildMaterial(nist, \"G4_BONE_COMPACT_ICRU\")\n    pos2 = G4ThreeVector(0, -1cm, 7cm)\n\n    # Trapezoid shape\n    shape2_dxa = 12cm; shape2_dxb = 12cm\n    shape2_dya = 10cm; shape2_dyb = 16cm\n    shape2_dz  = 6cm\n    solidShape2 = G4Trd(\"Shape2\", 0.5 * shape2_dxa, 0.5 * shape2_dxb, 0.5 * shape2_dya, 0.5 * shape2_dyb, 0.5 * shape2_dz)\n    logicShape2 = G4LogicalVolume(solidShape2, shape2_mat, \"Shape2\")\n    G4PVPlacement(nothing,        ## no rotation\n                  pos2,           ## at position\n                  logicShape2,    ## its logical volume\n                  \"Shape2\",       ## its name\n                  logicEnv,       ## its mother  volume\n                  false,          ## no boolean operation\n                  0,              ## copy number\n                  checkOverlaps)  ## overlaps checking\n\n    # Visualization attributes\n    SetVisAttributes(logicworld, G4VisAttributes!GetInvisible())\n    SetVisAttributes(logicEnv, G4VisAttributes!GetInvisible())\n    SetVisAttributes(logicShape1, G4VisAttributes(G4Colour(1.0, 1.0, 0.0)))\n    SetVisAttributes(logicShape2, G4VisAttributes(G4Colour(0.0, 0.0, 1.0)))\n\n    return physWorld              ## return a pointer to the G4PhysicalVolume\nend\n\nconstructB1Detector (generic function with 1 method)\n\ncrate an instance of the detector construction and physics list to be used in the simulation\n\ndetctor = G4JLDetectorConstruction(constructB1Detector)\nphysics = QBBC()\n\nGeant4.QBBCAllocated(Ptr{Nothing}(0x000000003ce19ad0))","category":"section"},{"location":"examples/B1/#Define-User-Actions","page":"Basic/B1 Example","title":"Define User Actions","text":"function buildApp(self::G4JLActionInitialization, ::Nothing)\n    # Create particle gun\n    particle_gun = G4JLParticleGun()\n    # Setup particle gun\n    pg = GetGun(particle_gun)\n    SetParticleByName(pg, \"e-\")\n    SetParticleEnergy(pg, 100MeV)\n    SetParticleMomentumDirection(pg, G4ThreeVector(0,0,1))\n    SetParticlePosition(pg, G4ThreeVector(0,0,-16cm))\n    # Register and relinquish ownership\n    SetUserAction(self, move!(particle_gun))\nend\napp = G4JLActionInitialization(buildApp)\n\nGeant4.G4JLActionInitializationAllocated(Ptr{Nothing}(0x000000003c9c21b0))","category":"section"},{"location":"examples/B1/#Instantiate-RunManager-and-initialize","page":"Basic/B1 Example","title":"Instantiate RunManager and initialize","text":"# Construct the default run manager and set initializers\nrunManager = G4RunManager()\n\n# Register User initialization objects and relinquish ownership\nSetUserInitialization(runManager, move!(detctor))\nSetUserInitialization(runManager, move!(physics))\nSetUserInitialization(runManager, move!(app))\n\n# Get the pointer to the User Interface manager\nUImanager = G4UImanager!GetUIpointer();\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\n","category":"section"},{"location":"examples/B1/#Execute-the-commands-to-initialize-the-simulation","page":"Basic/B1 Example","title":"Execute the commands to initialize the simulation","text":"# Initialize kernel\nApplyCommand(UImanager, \"/run/initialize\")\n\n# Change verbosity\n#ApplyCommand(UImanager, \"/control/verbose 2\")\n#ApplyCommand(UImanager, \"/run/verbose 2\")\n#ApplyCommand(UImanager, \"/event/verbose 0\")\nApplyCommand(UImanager, \"/tracking/verbose 1\")\n\n# gamma 6 MeV to the direction (0.,0.,1.)\nApplyCommand(UImanager, \"/gun/particle gamma\")\nApplyCommand(UImanager, \"/gun/energy 6 MeV\")\n\n# go\nApplyCommand(UImanager, \"/run/beamOn 1\")\n\n0\n\nChange the energy and run again\n\nApplyCommand(UImanager, \"/gun/particle e+\")\nApplyCommand(UImanager, \"/gun/energy 60 MeV\")\nApplyCommand(UImanager, \"/run/beamOn 1\")\n\n0\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/B2a/#Basic/B2a-Example","page":"Basic/B2a Example","title":"Basic/B2a Example","text":"In this example is based on the Geant4 basic/B2 example of the Geant4 distribution. It is a simple example that shows how to interact with the Geant4 classes.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/B2a/#Table-of-contents","page":"Basic/B2a Example","title":"Table of contents","text":"Pages = [\"B2a.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/B2a/#Loading-the-necessary-Julia-modules","page":"Basic/B2a Example","title":"Loading the necessary Julia modules","text":"Load the Geant4 and Geant4.SystemOfUnits modules. We will also use the Printf and GeometryBasics modules to format the output and handle the geometry.ß\n\nusing Geant4\nusing Geant4.SystemOfUnits\nusing Printf, GeometryBasics","category":"section"},{"location":"examples/B2a/#Define-Detector-Parameters-structure","page":"Basic/B2a Example","title":"Define Detector Parameters structure","text":"The B2aDetector structure is defined with the default detector parameters. We include the B2aDetector.jl file not to clutter the example.\n\ninclude(joinpath(@__DIR__, \"B2aDetector.jl\"))","category":"section"},{"location":"examples/B2a/#Define-Tracker-Hit","page":"Basic/B2a Example","title":"Define Tracker Hit","text":"We will extract the hits from the tracker and store them in a TrackerHit structure that ius custom defined\n\nstruct TrackerHit\n  trackID::Int32\n  chamberNb::Int32\n  edep::Float64\n  pos::Point3{Float64}\nend\n\nProviding a custom Base.show method to print the hits in a nice way\n\nfunction Base.show(io::IO, hit::TrackerHit)\n  (;trackID, chamberNb, edep, pos) = hit\n  @printf(io, \"\\ntrackID: %3d chamberNb: %2d Edep: %.3f MeV Position: (%3f, %3f, %3f)\", trackID, chamberNb, edep/MeV, pos...)\nend","category":"section"},{"location":"examples/B2a/#Define-Sensitive-Detector","page":"Basic/B2a Example","title":"Define Sensitive Detector","text":"First we define the data structure that will hold the hits. In this case we will store the hits in a vector of TrackerHit structures.\n\nstruct B2aSDData <: G4JLSDData\n  trackerHits::Vector{TrackerHit}\n  B2aSDData() = new([])\nend\n\nThen we define the methods that will be called by the Geant4 simulation _initialize (to initialize), _endOfEvent (at the end of the event) and _processHits (called when a hit is detected in that sensitive detector)\n\n# Initialize method\nfunction _initialize(::G4HCofThisEvent, data::B2aSDData)::Nothing\n  empty!(data.trackerHits)\n  return\nend\n# End of event method\nfunction _endOfEvent(::G4HCofThisEvent, data::B2aSDData)::Nothing\n  return\nend\n# Process Hit method\nfunction _processHits(step::G4Step, ::G4TouchableHistory, data::B2aSDData)::Bool\n  edep = step |> GetTotalEnergyDeposit\n  edep <  0. && return false\n  pos = step |> GetPostStepPoint |> GetPosition\n  push!(data.trackerHits, TrackerHit(step |> GetTrack |> GetTrackID,\n                                     step |> GetPreStepPoint |> GetTouchable |> GetCopyNumber,\n                                     edep,\n                                     Point3{Float64}(x(pos),y(pos),z(pos))))\n  return true\nend\n\n_processHits (generic function with 1 method)\n\nFinally, create the sensitive detector instance of the type G4JLSensitiveDetector with the name Chamber_SD and the associated data structure B2aSDData. The three previously defined methods are passed as arguments to the constructor.\n\nchamber_SD = G4JLSensitiveDetector(\"Chamber_SD\", B2aSDData();           ## SD name an associated data are mandatory\n                                    processhits_method=_processHits,    ## process hist method (also mandatory)\n                                    initialize_method=_initialize,      ## intialize method\n                                    endofevent_method=_endOfEvent)      ## end of event method\n\nGeant4.G4JLProtoSD{Main.var\"##277\".B2aSDData}(\"Chamber_SD\", Main.var\"##277\".B2aSDData(Main.var\"##277\".TrackerHit[]), Main.var\"##277\"._processHits, Main.var\"##277\"._initialize, Main.var\"##277\"._endOfEvent)","category":"section"},{"location":"examples/B2a/#Define-End-Event-Action","page":"Basic/B2a Example","title":"Define End Event Action","text":"This user function will be called at the end of each event. It will print the number of hits in the tracker for each event.\n\nfunction endeventaction(evt::G4Event, app::G4JLApplication)\n  hits = getSDdata(app, \"Chamber_SD\").trackerHits\n  eventID = evt |> GetEventID\n  if eventID < 10 || eventID % 1000 == 0\n    G4JL_println(\"Event: $eventID with $(length(hits)) hits stored in this event\")\n  end\n  return\nend\n\nendeventaction (generic function with 1 method)","category":"section"},{"location":"examples/B2a/#Particle-Gun-initialization","page":"Basic/B2a Example","title":"Particle Gun initialization","text":"particlegun = G4JLGunGenerator(particle = \"proton\",\n                               energy = 3GeV,\n                               direction = G4ThreeVector(0,0,1),\n                               position = G4ThreeVector(0,0,-2940.0))\n\nGeant4.G4JLGunGenerator(\"ParticleGun\", Geant4.G4JLParticleGunData(nothing, \"proton\", G4ThreeVector(0.0,0.0,1.0), G4ThreeVector(0.0,0.0,-2940.0), 3000.0), Geant4.var\"#init#19\"(), Geant4.var\"#gen#20\"(), Geant4.G4JLGeneratorAction[])","category":"section"},{"location":"examples/B2a/#Define-Physics-List","page":"Basic/B2a Example","title":"Define Physics List","text":"We define a new physics list that is based on the FTFP_BERT physics list and adds a G4StepLimiterPhysics to limit the step length of the particles.\n\nstruct B2PhysicsList <: G4VUserPhysicsList\n  function B2PhysicsList(verbose)\n      pl = FTFP_BERT(verbose)\n      lp = G4StepLimiterPhysics()\n      SetApplyToAll(lp, true)            ## Apply to all particles\n      RegisterPhysics(pl, move!(lp))     ## Register to the physics list\n      return pl                          ## We need to return the physics list instance\n  end\nend","category":"section"},{"location":"examples/B2a/#Create-the-Application","page":"Basic/B2a Example","title":"Create the Application","text":"We put all together in the G4JLApplication structure. We define the detector, the primary generator, the number of threads, the physics list, the end event action and the sensitive detectors.\n\napp = G4JLApplication(;detector = B2aDetector(nChambers=5),          ## detector with parameters\n                       generator = particlegun,                      ## primary particle generator\n                       nthreads = 0,                                 ## # of threads (0 = no MT)\n                       physics_type = B2PhysicsList,                 ## what physics list to instantiate\n                       endeventaction_method = endeventaction,       ## end event action\n                       sdetectors = [\"Chamber_LV+\" => chamber_SD]    ## mapping of LVs to SDs (+ means multiple LVs with same name)\n                      )\n\nGeant4.G4JLApplication{Main.var\"##277\".B2aDetector, Geant4.G4JLNoData}(Geant4.G4RunManagerAllocated(Ptr{Nothing}(0x0000000039953350)), Main.var\"##277\".B2aDetector(5, true, 800.0, 200.0, 50.0, 2940.0), [Geant4.G4JLNoData()], Geant4.G4JLGunGenerator(\"ParticleGun\", Geant4.G4JLParticleGunData(nothing, \"proton\", G4ThreeVector(0.0,0.0,1.0), G4ThreeVector(0.0,0.0,-2940.0), 3000.0), Geant4.var\"#init#19\"(), Geant4.var\"#gen#20\"(), Geant4.G4JLGeneratorAction[]), nothing, nothing, 0, 0, Geant4.G4RunManager, Geant4.G4JLDetectorConstruction, Main.var\"##277\".B2PhysicsList, Geant4.G4JLRunAction, Geant4.G4JLEventAction, Geant4.G4JLTrackingAction, Geant4.G4JLSteppingAction, nothing, nothing, nothing, nothing, nothing, nothing, Main.var\"##277\".endeventaction, nothing, nothing, Dict{String, Geant4.G4JLProtoSD}(\"Chamber_LV+\" => Geant4.G4JLProtoSD{Main.var\"##277\".B2aSDData}(\"Chamber_SD\", Main.var\"##277\".B2aSDData(Main.var\"##277\".TrackerHit[]), Main.var\"##277\"._processHits, Main.var\"##277\"._initialize, Main.var\"##277\"._endOfEvent)), Dict{String, Vector{Geant4.G4JLSensitiveDetector}}(), Geant4.G4JLScoringMesh[], nothing, nothing)","category":"section"},{"location":"examples/B2a/#Configure,-Initialize-and-Run","page":"Basic/B2a Example","title":"Configure, Initialize and Run","text":"configure(app)\ninitialize(app)\n\nChecking overlaps for volume Target:0 (G4Tubs) ... OK! \nChecking overlaps for volume Tracker:0 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:1 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:2 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:3 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:4 (G4Tubs) ... OK! \nChecking overlaps for volume Chamber_PV:5 (G4Tubs) ... OK! \n","category":"section"},{"location":"examples/B2a/#Run-the-simulation","page":"Basic/B2a Example","title":"Run the simulation","text":"# ui`/tracking/verbose 1`\nbeamOn(app,100)\n\nEvent: 0 with 130 hits stored in this event\nEvent: 1 with 677 hits stored in this event\nEvent: 2 with 76 hits stored in this event\nEvent: 3 with 13 hits stored in this event\nEvent: 4 with 18 hits stored in this event\nEvent: 5 with 86 hits stored in this event\nEvent: 6 with 124 hits stored in this event\nEvent: 7 with 97 hits stored in this event\nEvent: 8 with 59 hits stored in this event\nEvent: 9 with 111 hits stored in this event\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/B3Detector/#B3Detector.jl","page":"B3Detector.jl","title":"B3Detector.jl","text":"using Parameters\n#--------------------------------------------------------------------------------------------------\n# Implementation of the B3::DetectorConstruction class\n#--------------------------------------------------------------------------------------------------\n@with_kw mutable struct B3Detector <: G4JLDetector\n    cryst_dX::Float64 = 6cm\n    cryst_dY::Float64 = 6cm\n    cryst_dZ::Float64 = 3cm\n    nb_cryst::Int32 = 32\n    nb_rings::Int32 = 9\n    patient_radius::Float64 = 8cm\n    patient_dZ::Float64 = 10cm\n    checkOverlaps::Bool = true\nend\n\nfunction construct(det::B3Detector)::CxxPtr{G4VPhysicalVolume}\n    (; cryst_dX, cryst_dY, cryst_dZ, nb_cryst, nb_rings, patient_radius, checkOverlaps, patient_dZ) = det\n\n    #---Derived parameters-------------------------------------------------------------------------\n    dPhi = 2π/nb_cryst \n    half_dPhi = 0.5*dPhi\n    cosdPhi = cos(half_dPhi)\n    tandPhi = tan(half_dPhi)\n    ring_R1 = 0.5*cryst_dY/tandPhi\n    ring_R2 = (ring_R1+cryst_dZ)/cosdPhi\n    detector_dZ = nb_rings*cryst_dX\n    world_sizeXY = 2.4*ring_R2\n    world_sizeZ  = 1.2*detector_dZ\n  \n    #---Materials----------------------------------------------------------------------------------\n    nist = G4NistManager!Instance()\n    default_mat = FindOrBuildMaterial(nist, \"G4_AIR\")\n\n    O = FindOrBuildElement(nist, \"O\" , false)\n    Si = FindOrBuildElement(nist, \"Si\", false)\n    Lu = FindOrBuildElement(nist, \"Lu\", false)\n    Lu2SiO5 = G4Material(\"Lu2SiO5\", density=7.4*g/cm3, ncomponents=3)\n    AddElement(Lu2SiO5, Lu, natoms=2)\n    AddElement(Lu2SiO5, Si, natoms=1)\n    AddElement(Lu2SiO5, O, natoms=5)\n  \n    cryst_mat   = FindOrBuildMaterial(nist, \"Lu2SiO5\")\n    @show cryst_mat\n\n    #---Volumes------------------------------------------------------------------------------------\n    solidWorldS = G4Box(\"world\", world_sizeXY/2, world_sizeXY/2, world_sizeZ/2)\n    logicWorld  = G4LogicalVolume(solidWorldS, default_mat, \"World\")\n    physWorld   = G4PVPlacement(nothing, \n                                G4ThreeVector(),                # at (0,0,0)\n                                logicWorld,                     # its logical volume\n                                \"World\",                        # its name\n                                nothing,                        # its mother  volume\n                                false,                          # no boolean operations\n                                0,                              # copy number\n                                checkOverlaps)                  # checking overlaps\n\n    solidRing = G4Tubs(\"Ring\", ring_R1, ring_R2, cryst_dX/2, 0., 2π)\n    logicRing = G4LogicalVolume(solidRing, default_mat, \"Ring\")\n\n    gap = 0.5mm \n    dX = cryst_dX - gap\n    dY = cryst_dY - gap\n    solidCryst = G4Box(\"crystal\", dX/2, dY/2, cryst_dZ/2)\n    logicCryst = G4LogicalVolume(solidCryst, cryst_mat, \"CrystalLV\")\n\n    # place crystals within a ring\n    for icrys in 0:nb_cryst-1\n      ϕ = icrys*dPhi\n      rotm  = G4RotationMatrix()\n      rotateY(rotm, π/2)\n      rotateZ(rotm, ϕ)\n      position = (ring_R1 + cryst_dZ/2) * G4ThreeVector(cos(ϕ), sin(ϕ), 0)\n      transform = G4Transform3D(rotm, position)\n  \n      G4PVPlacement(transform,             # rotation,position\n                    logicCryst,            # its logical volume\n                    \"crystal\",             # its name\n                    logicRing,             # its mother  volume\n                    false,                 # no boolean operation\n                    icrys,                 # copy number\n                    checkOverlaps)         # checking overlaps\n    end\n  \n    # full detector\n    solidDetector = G4Tubs(\"Detector\", ring_R1, ring_R2, detector_dZ/2, 0., 2π)\n    logicDetector = G4LogicalVolume(solidDetector, default_mat, \"Detector\")\n\n    # place rings within detector\n    OG = -0.5*(detector_dZ + cryst_dX)\n    for iring in 0:nb_rings-1\n      OG += cryst_dX\n      G4PVPlacement(nothing,                  # no rotation\n                    G4ThreeVector(0, 0, OG),  # position\n                    logicRing,                # its logical volume\n                    \"ring\",                   # its name\n                    logicDetector,            # its mother  volume\n                    false,                    # no boolean operation\n                    iring,                    # copy number\n                    checkOverlaps)            # checking overlaps\n    end\n    \n    # place detector in world\n    G4PVPlacement(nothing,                  # no rotation\n                  G4ThreeVector(),          # at (0,0,0)\n                  logicDetector,            # its logical volume\n                  \"Detector\",               # its name\n                  logicWorld,               # its mother  volume\n                  false,                    # no boolean operation\n                  0,                        # copy number\n                  checkOverlaps)            # checking overlaps\n\n    # patient\n    patient_mat = FindOrBuildMaterial(nist, \"G4_BRAIN_ICRP\")\n    solidPatient = G4Tubs(\"Patient\", 0., patient_radius, patient_dZ/2, 0., 2π)\n    logicPatient = G4LogicalVolume(solidPatient, patient_mat,\"PatientLV\")\n    G4PVPlacement(nothing  ,                # no rotation\n                  G4ThreeVector(),          # at (0,0,0)\n                  logicPatient,             # its logical volume\n                  \"Patient\",                # its name\n                  logicWorld,               # its mother  volume\n                  false,                    # no boolean operation\n                  0,                        # copy number\n                  checkOverlaps)            # checking overlaps\n                \n\n    #---Visualization attributes-------------------------------------------------------------------\n    SetVisAttributes(logicWorld, G4VisAttributes!GetInvisible())\n    SetVisAttributes(logicRing, G4VisAttributes!GetInvisible())\n    SetVisAttributes(logicDetector, G4VisAttributes!GetInvisible())\n\n    #---Always return the physical world-----------------------------------------------------------\n    return physWorld\nend\n\nGeant4.getConstructor(::B3Detector)::Function = construct","category":"section"},{"location":"examples/GPSDetector/#GPSDetector.jl","page":"GPSDetector.jl","title":"GPSDetector.jl","text":"# Implementation of the exgps::DetectorConstruction class\n#--------------------------------------------------------------------------------------------------\n@with_kw mutable struct GPSDetector <: G4JLDetector\n    world_r::Float64 = 18*cm\n    box_x::Float64 = 10*cm\n    box_y::Float64 = 10*cm\n    box_z::Float64 = 10*cm\n    sphere_r::Float64 = 5*cm\nend\n\nfunction construct(det::GPSDetector)::CxxPtr{G4VPhysicalVolume}\n    #---Materials----------------------------------------------------------------------------------\n    VacMat = G4Material(\"Vacuum\", z=1., a=1.01g/mole, density=universe_mean_density, state=kStateGas, \n                        temperature=2.73*kelvin, pressure=3.e-18*pascal)\n    AlMat = G4Material(\"Aluminium\", z=13., a=26.98154*g/mole, density=2.70*g/cm3)\n    Si = G4Element(\"Silicon\", \"Si\", 14., 28.0855*g/mole)\n    O = G4Element(\"Oxygen\", \"O\", 8., 16.00*g/mole)\n    SiO₂Mat = G4Material(\"Silicon oxide\", density=16.00*g/mole, ncomponents=2)\n    AddElement(SiO₂Mat, move!(Si), natoms=1)\n    AddElement(SiO₂Mat, move!(O), natoms=2)\n\n    #---World--------------------------------------------------------------------------------------\n    universe_s = G4Sphere(\"universe_s\", 0, det.world_r, 0, 2π, 0, π)\n    universe_log = G4LogicalVolume(universe_s, CxxPtr(VacMat), \"universe_L\")\n    universe_phys = G4PVPlacement(nothing, G4ThreeVector(), universe_log, \"universe_P\", nothing, false, 0)\n\n    #---define an aluminium box--------------------------------------------------------------------\n    Al_box = G4Box(\"Al_b\", det.box_x, det.box_y, det.box_z)\n    Al_log = G4LogicalVolume(Al_box, CxxPtr(AlMat), \"Box_log\")\n    G4PVPlacement(nothing, G4ThreeVector(), Al_log, \"Box_phys\", universe_log, false, 0)\n\n    #---Define an inner sphere---------------------------------------------------------------------\n    aSphere_sph = G4Sphere(\"aSphere\", 0, det.sphere_r, 0, 2π, 0, π)\n    aSphere_log = G4LogicalVolume(aSphere_sph, CxxPtr(SiO₂Mat), \"Sphere_log\")\n    G4PVPlacement(nothing, G4ThreeVector(), aSphere_log, \"Sphere_phys\", Al_log, false, 0)\n    \n    #---Visualization attributes-------------------------------------------------------------------\n    SetVisAttributes(universe_log, G4VisAttributes!GetInvisible())\n    aVisAtt = G4VisAttributes(G4Colour(0, 1.0, 1.0))\n    SetVisAttributes(Al_log, aVisAtt)\n    bVisAtt = G4VisAttributes(G4Colour(1.0,2.0,.0))\n    SetVisAttributes(aSphere_log, bVisAtt)\n\n    return universe_phys\nend\n\nGeant4.getConstructor(::GPSDetector)::Function = construct","category":"section"},{"location":"examples/HBC30/#CERN-Liquid-Hydrogen-Bubble-Chamber","page":"CERN Liquid Hydrogen Bubble Chamber","title":"CERN Liquid Hydrogen Bubble Chamber","text":"Example to simulate the CERN 30cm bubble chamber fill with liquid hydrogen and using a pion beam of 330 MeV from PS. The original device was like this:\n\n(Image: )\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/HBC30/#Table-of-contents","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Table of contents","text":"Pages = [\"HBC30.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/HBC30/#Loading-the-necessary-Julia-modules","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Loading the necessary Julia modules","text":"Geant4 and Geant4.SystemOfUnits for the Geant4 simulation\nPrintf and GeometryBasics to format the output and handle the geometry\n\nusing Geant4\nusing Geant4.SystemOfUnits\nusing Printf, GeometryBasics\nusing CairoMakie  # to force loading G4Vis extension","category":"section"},{"location":"examples/HBC30/#Define-the-Detector","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Define the Detector","text":"The HBC30 is cylinder of 30cm filled with liquid hydrogen We include the HBC30Detector.jl file not to clutter the example.\n\ninclude(joinpath(@__DIR__, \"HBC30Detector.jl\"))\nhbc30 = HBC30()\n\nMain.var\"##277\".HBC30(300.0, 50.0, false, 192.50000000000003)","category":"section"},{"location":"examples/HBC30/#Define-the-simulation-data","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Define the simulation data","text":"The data structure HBC30SimData will be filled by the user actions at the correct moment during the simulation. We collect the points for each track at the step boundaries together with the initial kinetic energy and particle name and charge.\n\n##---Define Simulation Data struct------------------------------------------------------------------\nstruct Track\n    particle::String\n    charge::Int\n    energy::Float64\n    points::Vector{Point3{Float64}}\nend\nmutable struct HBC30SimData <: G4JLSimulationData\n    ##---Run data-----------------------------------------------------------------------------------\n    fParticle::String\n    fEkin::Float64\n    ##---trigger/veto-------------------------------------------------------------------------------\n    veto::Bool\n    ##---tracks-------------------------------------------------------------------------------------\n    tracks::Vector{Track}\n    HBC30SimData() = new(\"\", 0.0, false, [])\nend","category":"section"},{"location":"examples/HBC30/#Define-the-user-actions","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Define the user actions","text":"beginrun stores the particle type and initial kinetic energy of the generated primary particle\nbeginevent clear the trigger veto and the list of tracks for the current event\npretrackaction pushes a new Track with the particle name, charge, intial energy and initial point\nposttackactkion is used exclusevily to set the veto if the initial particle exists the world without a sizeable interaction\nstepaction pushes points to the latest Track in the track list\n\n##---Step action------------------------------------------------------------------------------------\nfunction stepaction(step::G4Step, app::G4JLApplication)::Nothing\n    tracks = getSIMdata(app).tracks\n    p = step |> GetPostStepPoint |> GetPosition\n    auxpoints = step |> GetPointerToVectorOfAuxiliaryPoints\n    if auxpoints != C_NULL\n        for ap in auxpoints\n            push!(tracks[end].points, Point3{Float64}(x(ap),y(ap),z(ap)))\n        end\n    end\n    push!(tracks[end].points, Point3{Float64}(x(p),y(p),z(p)))\n    return\nend\n##---Tracking pre-action----------------------------------------------------------------------------\nfunction pretrackaction(track::G4Track, app::G4JLApplication)::Nothing\n    tracks = getSIMdata(app).tracks\n    p = GetPosition(track)[]\n    particle = track |> GetParticleDefinition\n    name = particle |> GetParticleName |> String\n    charge = particle |> GetPDGCharge |> Int\n    energy = track |> GetKineticEnergy\n    push!(tracks, Track(name, charge, energy, [Point3{Float64}(x(p),y(p),z(p))]))\n    return\nend\n##---Tracking post-action----------------------------------------------------------------------------\nfunction posttrackaction(track::G4Track, app::G4JLApplication)::Nothing\n    data = getSIMdata(app)\n    id = track |> GetTrackID\n    energy = track |> GetKineticEnergy\n    if id == 1 && energy > 0.80 * data.fEkin # primary particle did not losse any energy\n        if track |> GetStep |> GetPostStepPoint |> GetPhysicalVolume == C_NULL  # Only if outside world\n            data.veto = true\n        end\n    end\n    return\nend\n##---Begin-event-action----------------------------------------------------------------------------\nfunction beginevent(::G4Event, app::G4JLApplication)::Nothing\n    data = getSIMdata(app)\n    data.veto = false\n    empty!(data.tracks)\n    return\nend\n##---Begin Run Action-------------------------------------------------------------------------------\nfunction beginrun(run::G4Run, app::G4JLApplication)::Nothing\n    data = getSIMdata(app)\n    gun = app.generator.data.gun\n    data.fParticle = gun |> GetParticleDefinition |> GetParticleName |> String\n    data.fEkin = gun |> GetParticleEnergy\n    return\nend;","category":"section"},{"location":"examples/HBC30/#Define-the-primary-particle-generator","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Define the primary particle generator","text":"import Geant4.SystemOfUnits:tesla\nparticlegun = G4JLGunGenerator(particle = \"pi+\",\n                               energy = 330MeV,\n                               direction = G4ThreeVector(0,-1,0),\n                               position = G4ThreeVector(0, hbc30.worldZHalfLength,0));","category":"section"},{"location":"examples/HBC30/#Create-Magnetic-Field","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Create Magnetic Field","text":"bfield = G4JLUniformMagField(G4ThreeVector(0,0, 1.5tesla));","category":"section"},{"location":"examples/HBC30/#Create-the-Application","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Create the Application","text":"app = G4JLApplication(; detector = hbc30,                             # detector with parameters\n                        simdata = HBC30SimData(),                     # simulation data structure\n                        generator = particlegun,                      # primary particle generator\n                        field = bfield,                               # uniform magnetic field\n                        nthreads = 0,                                 # # of threads (0 = no MT)\n                        physics_type = FTFP_BERT,                     # what physics list to instantiate\n                        stepaction_method = stepaction,               # step action method\n                        begineventaction_method = beginevent,         # begin-event action (initialize per-event data)\n                        pretrackaction_method = pretrackaction,       # pre-tracking action\n                        posttrackaction_method = posttrackaction,     # post-tracking action\n                        beginrunaction_method = beginrun              # begin run action\n                      );\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\n","category":"section"},{"location":"examples/HBC30/#Draw-and-trigger-functions","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Draw and trigger functions","text":"# Draw detector\nfunction drawdetector(s, app)\n    world = GetWorldVolume()\n    Geant4.draw!(s, world)\nend\n# Draw event\nfunction drawevent(s, app)\n    data = app.simdata[1]\n    # clear previous plots from previous event\n    tobe = [p for p in plots(s) if p isa Lines || p isa Makie.Text]  # The event is made of lines and text\n    for p in tobe\n        delete!(s,p)\n    end\n    # draw new event\n    for t in data.tracks\n        style = abs(t.charge) > 0. ? :solid : :dot\n        lines!(s, t.points, linestyle=style)\n        if t.energy > data.fEkin/20\n            text!(s, t.points[end], text=t.particle)\n        end\n    end\nend\n\n# Very simplistic trigger to get interesting events to plot\nfunction nexttrigger(app)\n    data = app.simdata[1]\n    beamOn(app,1)\n    n = 1\n    while data.veto\n        beamOn(app,1)\n        n += 1\n    end\n    println(\"Got a trigger after $n generated particles\")\nend;","category":"section"},{"location":"examples/HBC30/#Configure-and-Initialize","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Configure and Initialize","text":"configure(app)\ninitialize(app)\n\nui`/tracking/storeTrajectory 2` ## store auxiliary points to smooth the trajectory\n\n0","category":"section"},{"location":"examples/HBC30/#Draw-detector-and-first-event-that-triggers","page":"CERN Liquid Hydrogen Bubble Chamber","title":"Draw detector and first event that triggers","text":"fig = Figure(size=(2048,2028))\ns = LScene(fig[1,1])\n\ndrawdetector(s, app)\nnexttrigger(app); drawevent(s, app)\n\nPNG(fig)\n\n(Image: )\n\nChange the energy and type of particle and draw the next event that triggers\n\nSetParticleEnergy(particlegun, 1GeV)\nSetParticleByName(particlegun, \"e-\")\n\nfig = Figure(size=(2048,2028))\ns = LScene(fig[1,1])\n\ndrawdetector(s, app)\nnexttrigger(app); drawevent(s, app)\n\nPNG(fig)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/RE03Detector/#RE03Detector.jl","page":"RE03Detector.jl","title":"RE03Detector.jl","text":"# Implementation of the RE03::DetectorConstruction class\n#--------------------------------------------------------------------------------------------------\nmutable struct RE03Detector <: G4JLDetector\nend\n\nfunction construct(::RE03Detector)::CxxPtr{G4VPhysicalVolume}\n    #---Materials----------------------------------------------------------------------------------\n    nist = G4NistManager!Instance()\n    fAir = FindOrBuildMaterial(nist, \"G4_AIR\")\n    fWater = FindOrBuildMaterial(nist, \"G4_WATER\")\n\n    #---World--------------------------------------------------------------------------------------\n    worldSolid = G4Box(\"World\",2m, 2m, 2m)\n    worldLogical = G4LogicalVolume(worldSolid,fAir,\"World\")\n    worldPhys = G4PVPlacement(nothing, G4ThreeVector(), worldLogical, \"World\", nothing,false,0)\n    \n    #---Phantom------------------------------------------------------------------------------------\n    phantomSolid = G4Box(\"Phantom\", 1m, 1m, 1m)\n    phantomLogical = G4LogicalVolume(phantomSolid, fWater, \"Phantom\");\n    phantomPhys = G4PVPlacement(nothing, G4ThreeVector(), phantomLogical, \"Phantom\", worldLogical, false, 0)\n    \n    #---Visualization attributes-------------------------------------------------------------------\n    SetVisAttributes(worldLogical, G4VisAttributes!GetInvisible())\n    simpleBoxVisAtt = G4VisAttributes(G4Colour(1.0, 1.0, 1.0))\n    SetVisibility(simpleBoxVisAtt, true)\n    SetVisAttributes(phantomLogical, simpleBoxVisAtt)\n\n    return worldPhys\nend\n\nGeant4.getConstructor(::RE03Detector)::Function = construct","category":"section"},{"location":"examples/TPCSim/#Simulation-of-the-Aleph-TPC","page":"Simulation of the Aleph TPC","title":"Simulation of the Aleph TPC","text":"In this example we demonstrate how to connect the PYTHIA MC generator to a to a Geant4 application that implements a very simplistic model of the ALEPH TPC.\n\nThe TPC detector is a simple cylinder filled with a mixture of Argon and Methane gas inside an axial 1.5 tesla magnetic field. The primary particles are generated by PYTHIA8 with the the LEP collision settings.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/TPCSim/#Table-of-contents","page":"Simulation of the Aleph TPC","title":"Table of contents","text":"Pages = [\"TPCSim.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/TPCSim/#Loading-the-necessary-Julia-modules","page":"Simulation of the Aleph TPC","title":"Loading the necessary Julia modules","text":"Geant4 and Geant4.SystemOfUnits for the Geant4 simulation\nParameters for the parameter handling in the detector definition\nPYTHIA8 for the PYTHIA8 generator\n\nusing Geant4\nusing Geant4.SystemOfUnits\nusing Parameters\nusing PYTHIA8\n\n# to force loading G4Vis extension we need to load the following modules\nusing CairoMakie\nusing PYTHIA8: px, py, pz\nimport DisplayAs: PNG","category":"section"},{"location":"examples/TPCSim/#Define-the-TPC-Detector","page":"Simulation of the Aleph TPC","title":"Define the TPC Detector","text":"The TPC detector is a simple cylinder filled with a mixture of Ar and CH4 gas\n\nusing Geant4.SystemOfUnits: m, cm, mole,cm3\n\nThe data structure AlephTPC is defined with the default detector parameters\n\n@with_kw mutable struct AlephTPC <: G4JLDetector\n    totalL::Float64 = 4.4m      # total length of the TPC\n    innerR::Float64 = 0.31m     # inner radius of the TPC\n    outerR::Float64 = 1.8m      # outer radius of the TPC\n    checkOverlaps::Bool = false # do check overlaps when creating the geometry\nend\n\nMain.var\"##277\".AlephTPC\n\nThe function construct is defined to create the geometry of the TPC detector. It receives an instance of the AlephTPC structure and returns a pointer to the physical volume of the world.\n\nfunction construct(det::AlephTPC)::CxxPtr{G4VPhysicalVolume}\n    (; totalL, innerR, outerR, checkOverlaps) = det\n\n    ##---Materials----------------------------------------------------------------------------------\n    nist = G4NistManager!Instance()\n    m_Ar     = FindOrBuildMaterial(nist, \"G4_Ar\")\n    m_CH₄    = FindOrBuildMaterial(nist, \"G4_METHANE\")\n    ArCH₄  = G4Material(\"ArCH₄\", 3.491*mg/cm3, 2)\n    AddMaterial( ArCH₄, m_Ar, 0.91 )\n    AddMaterial( ArCH₄, m_CH₄,0.09 )\n    m_ArCH₄  = FindOrBuildMaterial(nist, \"ArCH₄\")\n    m_air    = FindOrBuildMaterial(nist, \"G4_AIR\")\n    m_Al     = FindOrBuildMaterial(nist, \"G4_Al\")\n\n    ##---Volumes------------------------------------------------------------------------------------\n    worldZHalfLength = 1.1 * totalL/2\n    worldS  = G4Box(\"world\", worldZHalfLength, worldZHalfLength, worldZHalfLength)\n    worldLV = G4LogicalVolume(worldS, m_air, \"World\")\n    worldPV = G4PVPlacement(nothing, G4ThreeVector(), worldLV, \"World\", nothing, false, 0, checkOverlaps)\n\n    fcOuterS  = G4Tubs(\"fcOuter\", outerR, outerR + 1.8cm, totalL/2, 0, 2π)\n    fcOuterLV = G4LogicalVolume(fcOuterS, m_Al, \"fcOuter\")\n    fcInnerS  = G4Tubs(\"fcInner\", innerR - 0.8cm, innerR, totalL/2, 0, 2π)\n    fcInnerLV = G4LogicalVolume(fcInnerS, m_Al, \"fcInner\")\n\n    chamberS  = G4Tubs(\"chamber\", innerR, outerR, totalL/2, 0, 2π)\n    chamberLV = G4LogicalVolume(chamberS, m_ArCH₄, \"chamber\")\n    G4PVPlacement(nothing, G4ThreeVector(), fcOuterLV, \"fcOuter\", worldLV, false, 0, checkOverlaps)\n    G4PVPlacement(nothing, G4ThreeVector(), fcInnerLV, \"fcInner\", worldLV, false, 0, checkOverlaps)\n    G4PVPlacement(nothing, G4ThreeVector(), chamberLV, \"chamber\", worldLV, false, 0, checkOverlaps)\n    ##SetUserLimits(chamberLV, G4UserLimits(5mm))\n\n    ##---Visualization attributes------------------------------------------------------------------\n    boxVisAtt = G4VisAttributes(G4Colour(1.0, 1.0, 1.0, 0.0))\n    chamberVisAtt = G4VisAttributes(G4Colour(0.0, 1.0, 1.0, 0.2))\n    fcVisAtt = G4VisAttributes(G4Colour(0.0, 1.0, 0.0, 0.1))\n    SetVisAttributes(worldLV, boxVisAtt)\n    SetVisAttributes(chamberLV, chamberVisAtt)\n    SetVisAttributes(fcInnerLV, fcVisAtt)\n    SetVisAttributes(fcOuterLV, fcVisAtt)\n\n    ##---Always return the physical world-------------------------------------------------------------\n    return worldPV\nend\nGeant4.getConstructor(::AlephTPC)::Function = construct\n\nFinally, the detector is created with the default parameters\n\ntpc = AlephTPC()          # create the detector\n\nMain.var\"##277\".AlephTPC\n  totalL: Float64 4400.0\n  innerR: Float64 310.0\n  outerR: Float64 1800.0\n  checkOverlaps: Bool false\n","category":"section"},{"location":"examples/TPCSim/#Magnetic-Field-initialization","page":"Simulation of the Aleph TPC","title":"Magnetic Field initialization","text":"bfield = G4JLUniformMagField(G4ThreeVector(0,0, 1.5tesla))\n\nGeant4.G4JLUniformMagField(\"UnifiormB\", Geant4.G4JLUniformMagFieldData(G4ThreeVector(0.0,0.0,0.0015)), Geant4.var\"#getfield!#getfield!##0\"(), Geant4.G4JLMagField[])","category":"section"},{"location":"examples/TPCSim/#Primary-Particle-Generator","page":"Simulation of the Aleph TPC","title":"Primary Particle Generator","text":"@with_kw mutable struct PythiaGenerator <: G4JLGeneratorData\n    eCM::Float64 = 91.2*GeV\n    pythia = nothing\nend\n\nfunction LEPCollision()\n    data = PythiaGenerator()\n    function LEPinit(data::PythiaGenerator, app::G4JLApplication)\n        data.pythia = PYTHIA8.Pythia(\"\", false)\n        data.pythia << \"Beams:idA = -11\" # positron\n        data.pythia << \"Beams:idB = 11\"  # electron\n        data.pythia << \"Beams:eCM = $(data.eCM/GeV)\" # CM energy\n        data.pythia << \"PDF:lepton = off\" # no lepton PDFs\n        # Process: hadronic decays of Z0. Initialize. Histogram.\n        data.pythia << \"WeakSingleBoson:ffbar2gmZ = on\"\n        data.pythia << \"23:onMode = off\"\n        data.pythia << \"23:onIfAny = 1 2 3 4 5\"\n        # If Pythia fails to initialize, exit with error.\n        data.pythia |> init || error(\"Pythia initialization failed\")\n    end\n    function LEPgenerate(g4evt::G4Event, data::PythiaGenerator)::Nothing\n        # Generate event. Skip if error. List first one.\n        data.pythia |> next || return\n        evt = data.pythia |> event\n        # Define primary vertex\n        vertex = G4PrimaryVertex(G4ThreeVector(0,0,0), 0)\n        # Loop over the particles in the Pythia event\n        for p in evt\n            if isFinal(p)\n                primary = G4PrimaryParticle(p |> PYTHIA8.id, px(p)*GeV, py(p)*GeV, pz(p)*GeV)\n                SetPrimary(vertex, move!(primary))    ## note that we give up ownership of the objects just created\n            end\n        end\n        AddPrimaryVertex(g4evt, move!(vertex))  ## note that we give up ownership of the objects just created\n    end\n    G4JLPrimaryGenerator(\"LEPCollision\", data; init_method=LEPinit, generate_method=LEPgenerate)\nend\n\nLEPCollision (generic function with 1 method)","category":"section"},{"location":"examples/TPCSim/#Event-Display","page":"Simulation of the Aleph TPC","title":"Event Display","text":"Overwriting the default drawEvent function defined in the G4Vis extension\n\nconst G4Vis = Base.get_extension(Geant4, :G4Vis)\nfunction G4Vis.drawEvent(evtdisp::G4Vis.G4JLEventDisplay)\n    println(\"Drawing event\", typeof(evtdisp))\n    s = evtdisp.lscene.scene\n    settings = evtdisp.settings\n    trajectories = G4EventManager!GetEventManager() |> GetConstCurrentEvent |> GetTrajectoryContainer\n    if trajectories != C_NULL\n        points = Point3{Float64}[]\n        for t in trajectories\n            t |> GetCharge == 0 && continue # skip neutral particles\n            npoints = GetPointEntries(t)\n            npoints < 3 && continue         # skip particles with less than 3 points\n            for i in 1:npoints\n                pos = GetPoint(t, i-1) |> GetPosition\n                r = sqrt(pos[0]^2 + pos[1]^2)\n                z = pos[2]\n                (r > 1.8m || abs(z) > 2.4m) && break  # kill particle outside the TPC\n                if r > 0.38m                # skip points inside the beam pipe\n                    push!(points, convert(Point3{Float64}, pos))\n                else\n                    push!(points, Point3{Float64}(NaN, NaN, NaN))\n                end\n            end\n            push!(points, Point3{Float64}(NaN, NaN, NaN))\n        end\n        lines!(s, points, color=settings.trajectories.color, transparency=false, overdraw=false)\n    end\n    ##wait_for_key(\"Press any key to continue with next event\")\nend\nevtdisplay = G4JLEventDisplay(joinpath(@__DIR__, \"TPCSimVisSettings.jl\"))\n\nG4Vis.G4JLEventDisplay((display = (backgroundcolor = :black, resolution = (1280, 720), show_axis = false, camera_rotation = (0, 0, -1.5707963267948966), camera_zoom = 0.1), trajectories = (color = :yellow,), detector = (show_detector = true,)), G4Vis.stateChange, G4Vis.initDisplay, #undef, #undef)","category":"section"},{"location":"examples/TPCSim/#Create-the-Application","page":"Simulation of the Aleph TPC","title":"Create the Application","text":"app = G4JLApplication(detector     = tpc,                       # detector defined above\n                      generator    = LEPCollision(),            # primary generator to instantiate\n                      field        = bfield,                    # magnetic field\n                      physics_type = FTFP_BERT,                 # what physics list to instantiate\n                      evtdisplay   = evtdisplay                 # event display\n                     );\nconfigure(app)\ninitialize(app)\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\n\n *-------  PYTHIA Process Initialization  --------------------------*\n |                                                                  |\n | We collide e+ with e- at a CM energy of 9.120e+01 GeV            |\n |                                                                  |\n |------------------------------------------------------------------|\n |                                                    |             |\n | Subprocess                                    Code |   Estimated |\n |                                                    |    max (mb) |\n |                                                    |             |\n |------------------------------------------------------------------|\n |                                                    |             |\n | f fbar -> gamma*/Z0                            221 |   4.352e-05 |\n |                                                                  |\n *-------  End PYTHIA Process Initialization -----------------------*\n\n *-------  PYTHIA Flag + Mode + Parm + Word + FVec + MVec + PVec + WVec Settings (changes only)  ------------------* \n |                                                                                                                 | \n | Name                                          |                      Now |      Default         Min         Max | \n |                                               |                          |                                      | \n | Beams:eCM                                     |                 91.20000 |    14000.000         0.0             | \n | Beams:idA                                     |                      -11 |         2212                         | \n | Beams:idB                                     |                       11 |         2212                         | \n | PDF:lepton                                    |                      off |           on                         | \n | WeakSingleBoson:ffbar2gmZ                     |                       on |          off                         | \n |                                                                                                                 | \n *-------  End PYTHIA Flag + Mode + Parm + Word + FVec + MVec + PVec + WVec Settings  -----------------------------* \n\n --------  PYTHIA Particle Data Table (changed only)  ------------------------------------------------------------------------------\n \n      id   name            antiName         spn chg col      m0        mWidth      mMin       mMax       tau0    res dec ext vis wid\n             no onMode   bRatio   meMode     products \n\n      23  Z0                                  3   0   0   91.18760    2.50419   10.00000    0.00000  7.87987e-14   1   1   0   0   0\n              0     1   0.1540492    0        1       -1 \n              1     1   0.1194935    0        2       -2 \n              2     1   0.1540386    0        3       -3 \n              3     1   0.1193325    0        4       -4 \n              4     1   0.1523269    0        5       -5 \n              5     0   0.0335480    0       11      -11 \n              6     0   0.0667305    0       12      -12 \n              7     0   0.0335477    0       13      -13 \n              8     0   0.0667305    0       14      -14 \n              9     0   0.0334720    0       15      -15 \n             10     0   0.0667305    0       16      -16 \n\n --------  End PYTHIA Particle Data Table  -----------------------------------------------------------------------------------------\n\n G4ChordFinder: stepperDriverId: 2\n","category":"section"},{"location":"examples/TPCSim/#Run-the-Application","page":"Simulation of the Aleph TPC","title":"Run the Application","text":"beamOn(app, 1)\nPNG(evtdisplay.figure)\n\n(Image: )\n\nAnother event\n\nbeamOn(app, 1)\nPNG(evtdisplay.figure)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/UserLib/#Calling-Custom-C-library","page":"Calling Custom C++ library","title":"Calling Custom C++ library","text":"An example of calling user libraries that can provide additional Geant4 functionally that is not provided by the set of wrapped classes. In this example we define a custom solid called RoundCube, which is a cube with rounded edges and vertices. The cube is defined by the side length a and the radius of the rounded edges and vertices r.\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/UserLib/#Table-of-contents","page":"Calling Custom C++ library","title":"Table of contents","text":"Pages = [\"UserLib.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/UserLib/#Loading-the-necessary-Julia-modules","page":"Calling Custom C++ library","title":"Loading the necessary Julia modules","text":"using Geant4\nusing Geant4.SystemOfUnits\nusing Libdl\nusing CairoMakie  # to force loading G4Vis extension","category":"section"},{"location":"examples/UserLib/#Building-the-custom-library","page":"Calling Custom C++ library","title":"Building the custom library","text":"The custom library is defined in the C++ file UserLibrary.cpp. The library provides a function to create a custom solid RoundCube and some additional functions to interact with the solid.\n\nThe attribute Geant4_jll.artifact_dir provides the path to the Geant4 installation directory. We use only a sub-set of libraries needed to link shared library.\n\nprefix = Geant4.Geant4_jll.artifact_dir\ndlext = Libdl.dlext;\nif Sys.KERNEL == :Linux\n    ldflags = \"-Wl,-rpath,$prefix/lib -Wl,--no-as-needed\"\nelse\n    ldflags = \"-Wl,-rpath,$prefix/lib -Wl\"\nend\n# Compilation of the custom library\n\n\"-Wl,-rpath,/home/runner/.julia/artifacts/a29502682ae2904a6931c61f0fa34e562e6d6ed5/lib -Wl,--no-as-needed\"\n\nThe custom library is defined in the C++ file UserLibrary.cpp. Please note that the callable functions are defined with the extern \"C\" attribute to avoid name mangling.\n\nBase.run(`c++ -O2 -shared -fPIC -std=c++17 -I$prefix/include/Geant4 $ldflags\n         -L$prefix/lib -lG4geometry -lG4materials -lG4global -lG4clhep\n         -o UserLibrary.$dlext $(@__DIR__)/UserLibrary.cpp`).exitcode == 0 || error(\"Compilation failed\")\n\ntrue","category":"section"},{"location":"examples/UserLib/#Define-Julia-functions-to-interact-with-the-custom-library","page":"Calling Custom C++ library","title":"Define Julia functions to interact with the custom library","text":"The @call macro provides a very convenient way to call C functions (or extern \"C\"). We define the following functions to interact with the custom library in a more Julia-friendly way:\n\nconst lib = \"./UserLibrary.$(Libdl.dlext)\"\ncreateRoundCube(a,r) = @ccall lib.createRoundCube(a::Float64, r::Float64)::CxxPtr{G4VSolid}\ndeleteRoundCube(s::CxxPtr{G4VSolid}) = @ccall lib.deleteRoundCube(s::CxxPtr{G4VSolid})::Cvoid\ninfoRoundCube(s::CxxPtr{G4VSolid}) = (@ccall lib.infoRoundCube(s::CxxPtr{G4VSolid})::Cstring) |> unsafe_string\n\ninfoRoundCube (generic function with 1 method)","category":"section"},{"location":"examples/UserLib/#Testing-the-custom-library","page":"Calling Custom C++ library","title":"Testing the custom library","text":"We create a RoundCube with side length 100 and radius 10 and draw the distance to the outside of the solid from a number of randomly distributed points in a random directions. This should get a nice image of the surface RoundCube. It is exercising Inside and DistanceToOut methods of the custom solid.\n\nrcube = createRoundCube(10cm, 1cm)        # returns a CxxPtr{G4VSolid}\nimg = drawDistanceToOut(rcube[], 100000)  # implemented in G4Vis ext. It expects a G4VSolid.\n\n(Image: )\n\nGet the information about the RoundCube\n\ninfo = infoRoundCube(rcube)\nprintln(info)\n\nRoundCube with a = 100 r = 10\n\n\nDelete the RoundCube\n\ndeleteRoundCube(rcube)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/B2aVisSettings/#B2aVisSettings.jl","page":"B2aVisSettings.jl","title":"B2aVisSettings.jl","text":"(\n    display = (\n        backgroundcolor = :white,\n        show_axis = true,\n    ),\n    trajectories = (\n        color = :black,\n    ),\n)","category":"section"},{"location":"examples/WaterPhantom/#Water-Phantom-with-Scoring","page":"Water Phantom with Scoring","title":"Water Phantom with Scoring","text":"note: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.\n\nExample originated from the example in Geant4Py. It is using a very simple phantom model (a box of water) and exercises the scoring interface.\n\nusing Geant4\nusing Geant4.SystemOfUnits\nusing Plots\nimport DisplayAs: PNG","category":"section"},{"location":"examples/WaterPhantom/#Detector-description","page":"Water Phantom with Scoring","title":"Detector description","text":"The main parameters are stored in the RE03Detector struct with some default values.\n\nmutable struct RE03Detector <: G4JLDetector\n    const worldXY::Float64\n    const worldZ::Float64\n    const phantomXY::Float64\n    const phantomZ::Float64\n    RE03Detector(;worldXY=100cm, worldZ=300cm, phantomXY=30.5cm, phantomZ=30cm) = new(worldXY, worldZ, phantomXY, phantomZ)\nend\n\nfunction construct(det::RE03Detector)::CxxPtr{G4VPhysicalVolume}\n    ##---Materials----------------------------------------------------------------------------------\n    nist = G4NistManager!Instance()\n    fAir = FindOrBuildMaterial(nist, \"G4_AIR\")\n    fWater = FindOrBuildMaterial(nist, \"G4_WATER\")\n\n    ##---World--------------------------------------------------------------------------------------\n    worldSolid = G4Box(\"World\",det.worldXY/2, det.worldXY/2, det.worldZ/2)\n    worldLogical = G4LogicalVolume(worldSolid,fAir,\"World\")\n    worldPhys = G4PVPlacement(nothing, G4ThreeVector(), worldLogical, \"World\", nothing,false,0)\n\n    ##---Phantom------------------------------------------------------------------------------------\n    phantomSolid = G4Box(\"Phantom\", det.phantomXY/2, det.phantomXY/2, det.phantomZ/2)\n    phantomLogical = G4LogicalVolume(phantomSolid, fWater, \"Phantom\");\n    phantomPhys = G4PVPlacement(nothing, G4ThreeVector(), phantomLogical, \"Phantom\", worldLogical, false, 0)\n\n    ##---Visualization attributes-------------------------------------------------------------------\n    SetVisAttributes(worldLogical, G4VisAttributes!GetInvisible())\n    simpleBoxVisAtt = G4VisAttributes(G4Colour(1.0, 1.0, 1.0))\n    SetVisibility(simpleBoxVisAtt, true)\n    SetVisAttributes(phantomLogical, simpleBoxVisAtt)\n\n    return worldPhys\nend\nGeant4.getConstructor(::RE03Detector)::Function = construct","category":"section"},{"location":"examples/WaterPhantom/#Define-the-primary-particle-generator","page":"Water Phantom with Scoring","title":"Define the primary particle generator","text":"We define the MedicalBeam particle generator. This is similar to the particle gun but with direction of the particles randomly distributed within some aperture cone. It consists of\n\nMedicalBeamData data structure with the parameters of the beam\nAn init function that will be called at initialization time.\nAn generate function hat is called at each event and create the primary particle and primary vertex.\nA set of setter functions (SetParticleByName, SetParticleEnergy) to change parameters at run time\n\nThe function to construct the generator is MedicalBeam(...).\n\nmutable struct MedicalBeamData <: G4JLGeneratorData\n    particleName::String\n    particlePtr::CxxPtr{G4ParticleDefinition}\n    energy::Float64\n    ssd::Float64\n    fieldXY::Float64\n    surfaceZ::Float64\n  end\n\n  function generateBeamDir(ssd::Float64, fxy::Float64)\n    dr = √2/2*fxy\n    R = √(ssd^2 + dr^2)\n    cos0 = ssd/R\n    xymax = fxy/ssd/2\n    dx = dy = dz = 0.\n    while true\n      dz = rand()*(1-cos0)+ cos0\n      dsin = √(1-dz^2)\n      dphi = rand()*2π\n      dx = dsin * cos(dphi)\n      dy = dsin * sin(dphi)\n      if abs(dx) < xymax*dz && abs(dy) < xymax*dz\n        break\n      end\n    end\n    G4ThreeVector(dx, dy, dz)\n  end\n\n  function MedicalBeam(;particle=\"e-\", energy=10MeV, ssd=100cm, fieldXY=10cm)\n    data = MedicalBeamData(particle, CxxPtr{G4ParticleDefinition}(C_NULL), energy, ssd, fieldXY, 0.)\n    function init(data::MedicalBeamData, app::G4JLApplication)\n      data.particlePtr = FindParticle(data.particleName)\n      data.surfaceZ = -app.detector.phantomZ/2\n    end\n    function generate( evt::G4Event, data::MedicalBeamData)::Nothing\n      mass = data.particlePtr |> GetPDGMass\n      momemtum = √((mass + data.energy)^2 - mass^2)\n      pvec = momemtum * generateBeamDir(data.ssd, data.fieldXY);\n      primary = G4PrimaryParticle(data.particlePtr, pvec |> x, pvec |> y, pvec |> z )\n      vertex = G4PrimaryVertex(G4ThreeVector(0, 0, data.surfaceZ - data.ssd), 0ns)\n      SetPrimary(vertex, move!(primary))    # note that we give up ownership of the objects just created\n      AddPrimaryVertex(evt, move!(vertex))  # note that we give up ownership of the objects just created\n    end\n    G4JLPrimaryGenerator(\"MedicalBeam\", data; init_method=init, generate_method=generate)\n  end\n  function SetParticleByName(gen::G4JLPrimaryGenerator{MedicalBeamData}, particle::String)\n    gen.data.particleName = particle\n    gen.data.particlePtr = FindParticle(particle)\n    return\n  end\n  function SetParticleEnergy(gen::G4JLPrimaryGenerator{MedicalBeamData}, energy::Float64)\n    gen.data.energy = energy\n    return\n  end;","category":"section"},{"location":"examples/WaterPhantom/#Setup-the-scoring-with-the-the-scoring-interface","page":"Water Phantom with Scoring","title":"Setup the scoring with the the scoring interface","text":"Create a box shaped mesh and define the number of bins. The quantity to be monitor is dose. Later accessing the attribute dose on the scoring mesh will return a tuple with the sum of dose, sum square and number of entries for each mesh cell.\n\nsc1 = G4JLScoringMesh(\"boxMesh_1\",\n                      BoxMesh(15.25cm, 15.25cm, 15cm),\n                      bins = (61, 61, 150),\n                      quantities = [ doseDeposit(\"dose\") ]\n                      );","category":"section"},{"location":"examples/WaterPhantom/#Create-the-Application","page":"Water Phantom with Scoring","title":"Create the Application","text":"app = G4JLApplication(;detector = RE03Detector(),                    # detector with parameters\n                       generator = MedicalBeam(),                    # promary partcile generator\n                       nthreads = 8,                                 # define the number of threads\n                       physics_type = FTFP_BERT,                     # what physics list to instantiate\n                       scorers = [sc1]                               # list of scorers\n                      );\n\n\n**************************************************************\n Geant4 version Name: geant4-11-03-patch-02 [MT]   (25-April-2025)\n  << in Multi-threaded mode >> \n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\n","category":"section"},{"location":"examples/WaterPhantom/#Configure,-Initialize-and-Run","page":"Water Phantom with Scoring","title":"Configure, Initialize and Run","text":"configure(app)\ninitialize(app)\nbeamOn(app, 0)\n\n--- G4CoupledTransportation is used \n.... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4ScoringManager has 1 scoring meshes.\nG4ScoringBox : boxMesh_1 --- Shape: Box mesh\n Size (x, y, z): (15.25, 15.25, 15) [cm]\n # of segments: (61, 61, 150)\n displacement: (0, 0, 0) [cm]\n registered primitve scorers : \n   0  dose\nG4WT3 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT0 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT3 > G4ScoringManager has 1 scoring meshes.\nG4WT3 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT3 >  Size (x, y, z): (15.25, 15.25, 15) [cm]\nG4WT4 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT3 >  # of segments: (61, 61, 150)\nG4WT3 >  displacement: (0, 0, 0) [cm]\nG4WT3 >  registered primitve scorers : \nG4WT3 >    0  dose\nG4WT6 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT4 > G4ScoringManager has 1 scoring meshes.\nG4WT4 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT4 >  Size (x, y, z): (15.25, 15.25, 15) [cm]\nG4WT4 >  # of segments: (61, 61, 150)\nG4WT4 >  displacement: (0, 0, 0) [cm]\nG4WT4 >  registered primitve scorers : \nG4WT4 >    0  dose\nG4WT6 > G4ScoringManager has 1 scoring meshes.\nG4WT6 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT2 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT6 >  Size (x, y, z): (15.25, 15.25, 15) [cm]\nG4WT6 >  # of segments: (61, 61, 150)\nG4WT6 >  displacement: (0, 0, 0) [cm]\nG4WT6 >  registered primitve scorers : \nG4WT6 >    0  dose\nG4WT2 > G4ScoringManager has 1 scoring meshes.\nG4WT2 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT2 >  Size (x, y, z): (15.25, 15.25, 15) [cm]\nG4WT2 >  # of segments: (61, 61, 150)\nG4WT2 >  displacement: (0, 0, 0) [cm]\nG4WT2 >  registered primitve scorers : \nG4WT2 >    0  dose\nG4WT1 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT1 > G4ScoringManager has 1 scoring meshes.\nG4WT1 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT1 >  Size (x, y, z): (15.25, 15.25, 15) [cm]\nG4WT1 >  # of segments: (61, 61, 150)\nG4WT1 >  displacement: (0, 0, 0) [cm]\nG4WT1 >  registered primitve scorers : \nG4WT1 >    0  dose\nG4WT7 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT7 > G4ScoringManager has 1 scoring meshes.\nG4WT7 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT7 >  Size (x, y, z): (15.25, 15.25, 15) [cm]\nG4WT7 >  # of segments: (61, 61, 150)\nG4WT7 >  displacement: (0, 0, 0) [cm]\nG4WT7 >  registered primitve scorers : \nG4WT7 >    0  dose\nG4WT0 > G4ScoringManager has 1 scoring meshes.\nG4WT0 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT0 >  Size (x, y, z): (15.25, 15.25, 15) [cm]\nG4WT0 >  # of segments: (61, 61, 150)\nG4WT0 >  displacement: (0, 0, 0) [cm]\nG4WT0 >  registered primitve scorers : \nG4WT0 >    0  dose\nG4WT5 > .... G4ScoringMessenger::MeshBinCommand - G4ScoringBox\nG4WT5 > G4ScoringManager has 1 scoring meshes.\nG4WT5 > G4ScoringBox : boxMesh_1 --- Shape: Box mesh\nG4WT5 >  Size (x, y, z): (15.25, 15.25, 15) [cm]\nG4WT5 >  # of segments: (61, 61, 150)\nG4WT5 >  displacement: (0, 0, 0) [cm]\nG4WT5 >  registered primitve scorers : \nG4WT5 >    0  dose\n","category":"section"},{"location":"examples/WaterPhantom/#Define-plotting-functions","page":"Water Phantom with Scoring","title":"Define plotting functions","text":"function do_plots(sc)\n    dose, dose2, nentry = sc.dose\n    xaxisvalues = range(0., sc.mesh.dx*2/cm, sc.bins[1])\n    zaxisvalues = range(0., sc.mesh.dz*2/cm, sc.bins[3])\n    cbin = round(Int, (sc.bins[1]+1)/2)\n    fig = plot( layout=(2,1), size=(800,800),\n                heatmap(zaxisvalues, xaxisvalues, dose[cbin,:,:], title=\"Dose (XZ)\", color=:thermal, xlabel=\"Z (cm)\", ylabel=\"X (cm)\"),\n                plot(zaxisvalues, dose[cbin,cbin,:], title=\"Depth Dose (center)\", xlabel=\"Z (cm)\", label=\"dose\")\n    )\nend\n\ndo_plots (generic function with 1 method)","category":"section"},{"location":"examples/WaterPhantom/#Electron-20-Mev","page":"Water Phantom with Scoring","title":"Electron 20 Mev","text":"SetParticleByName(app.generator, \"e-\")\nSetParticleEnergy(app.generator, 20MeV)\nbeamOn(app, 100000)\ndo_plots(sc1)\n\n(Image: )","category":"section"},{"location":"examples/WaterPhantom/#Proton-200-MeV","page":"Water Phantom with Scoring","title":"Proton 200 MeV","text":"SetParticleByName(app.generator, \"proton\")\nSetParticleEnergy(app.generator, 200MeV)\nbeamOn(app, 100000)\ndo_plots(sc1)\n\n(Image: )","category":"section"},{"location":"examples/WaterPhantom/#Csub12/sub-ion-3-GeV","page":"Water Phantom with Scoring","title":"C<sub>12</sub> ion 3 GeV","text":"SetParticleByName(app.generator, \"C12\")\nSetParticleEnergy(app.generator, 3GeV)\n\nbeamOn(app, 100000)\ndo_plots(sc1)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/G4example/#G4example.cpp","page":"G4example.cpp","title":"G4example.cpp","text":"#include \"G4VUserDetectorConstruction.hh\"\n#include \"G4VUserPrimaryGeneratorAction.hh\"\n#include \"G4UserEventAction.hh\"\n#include \"G4UserRunAction.hh\"\n#include \"G4ParticleGun.hh\"\n#include \"G4RunManager.hh\"\n#include \"G4UImanager.hh\"\n#include \"G4RunManagerFactory.hh\"\n#include \"QBBC.hh\"\n#include \"G4NistManager.hh\"\n#include \"G4Box.hh\"\n#include \"G4LogicalVolume.hh\"\n#include \"G4PVPlacement.hh\"\n//#include \"G4SystemOfUnits.hh\"\n#include \"globals.hh\"\n#include \"G4VUserActionInitialization.hh\"\n#include \"G4UserWorkerInitialization.hh\"\n#include <julia.h>\n#include <iostream>\n\n//---Detector construction class-------------------------------------------------------------------\nclass DetectorConstruction : public G4VUserDetectorConstruction\n{\n  public:\n    DetectorConstruction() = default;\n    ~DetectorConstruction() override = default;\n    G4VPhysicalVolume* Construct() override {\n        auto nist = G4NistManager::Instance();\n        auto world_mat = nist->FindOrBuildMaterial(\"G4_AIR\");\n        auto core_mat  = nist->FindOrBuildMaterial(\"G4_WATER\");\n        auto world_size = 1.0*CLHEP::m;\n        auto solidWorld = new G4Box(\"World\", world_size, world_size, world_size);\n        auto logicWorld = new G4LogicalVolume(solidWorld, world_mat, \"World\");\n        auto physWorld = new G4PVPlacement(0, G4ThreeVector(), logicWorld, \"World\", 0, false, 0);\n        auto core_size = 0.5*CLHEP::m;\n        auto solidCore = new G4Box(\"Core\", core_size, core_size, core_size);\n        auto logicCore = new G4LogicalVolume(solidCore, core_mat, \"Core\");\n        new G4PVPlacement(0, G4ThreeVector(), logicCore, \"Core\", logicWorld, false, 0);\n        return physWorld;\n    }\n    void ConstructSDandField() override {}\n};\n\n//---Primary generator action class----------------------------------------------------------------\nclass PrimaryGeneratorAction : public G4VUserPrimaryGeneratorAction\n{\npublic:\n    PrimaryGeneratorAction() { fParticleGun  = new G4ParticleGun(); }    \n    ~PrimaryGeneratorAction() { delete fParticleGun; }\n    void GeneratePrimaries(G4Event* anEvent) override {\n        fPrimaryParticleName = fParticleGun->GetParticleDefinition()->GetParticleName();\n        fParticleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));\n        fParticleGun->SetParticlePosition(G4ThreeVector(0.,0.,-1.*CLHEP::m));\n        fParticleGun->GeneratePrimaryVertex(anEvent);\n    }\n    G4ParticleGun* GetParticleGun() {return fParticleGun;};\n    const G4String& GetParticleName() { return fPrimaryParticleName;}\nprivate:\n    G4String fPrimaryParticleName;\n    G4ParticleGun* fParticleGun;\n};\n\ntypedef  void (*stepaction_f)(const G4Step*);\nclass SteppingAction : public G4UserSteppingAction\n{\npublic:\n    SteppingAction() {\n      action_jl = (stepaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(stepping_action, Nothing, (CxxPtr{G4Step},))\")));\n      std::cout << \"=====> \" << action_jl << std::endl;\n    } \n    ~SteppingAction() {}\n    void UserSteppingAction(const G4Step* step) override { action_jl(step); }\nprivate:\n    stepaction_f action_jl;\n};\n\ntypedef  void (*eventaction_f)(const G4Event*);\nclass EventAction : public G4UserEventAction\n{\n  public:\n    EventAction() {\n      beginevent_jl = (eventaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(begin_of_event_action, Nothing, (CxxPtr{G4Event},))\")));\n      endevent_jl = (eventaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(end_of_event_action, Nothing, (CxxPtr{G4Event},))\")));\n    }\n    ~EventAction() override = default;\n\n    void BeginOfEventAction(const G4Event* event) override { beginevent_jl(event); }\n    void EndOfEventAction(const G4Event* event) override { endevent_jl(event); }\n  private:\n    eventaction_f beginevent_jl;\n    eventaction_f endevent_jl;\n};\n\ntypedef  void (*runaction_f)(const G4Run*);\nclass RunAction : public G4UserRunAction\n{\n  public:\n    RunAction() {\n      beginrun_jl = (runaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(begin_of_run_action, Nothing, (CxxPtr{G4Run},))\")));\n      endrun_jl = (runaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(end_of_run_action, Nothing, (CxxPtr{G4Run},))\")));\n    }\n    ~RunAction() override = default;\n\n    void BeginOfRunAction(const G4Run* run) override { beginrun_jl(run); }\n    void EndOfRunAction(const G4Run* run) override { endrun_jl(run); }\n\n  private:\n    runaction_f beginrun_jl;\n    runaction_f endrun_jl;\n};\n\n\nclass WorkerInitialization : public G4UserWorkerInitialization {\n  public:\n    WorkerInitialization() = default;\n    virtual ~WorkerInitialization() = default;\n    virtual void WorkerInitialize() const override {\n      if (jl_get_pgcstack() == NULL) jl_adopt_thread();\n    }\n    virtual void WorkerStart() const override {}\n    virtual void WorkerRunStart() const override {}\n    virtual void WorkerRunEnd() const override {\n      jl_ptls_t ptls = jl_current_task->ptls;\n      jl_gc_safe_enter(ptls);\n    }\n    virtual void WorkerStop() const override {}\n};\n\n//---Action initialization class-------------------------------------------------------------------\nclass ActionInitialization : public G4VUserActionInitialization\n{\n  public:\n    ActionInitialization() = default;\n    ~ActionInitialization() override = default;\n    void BuildForMaster() const override {\n        SetUserAction(new RunAction);\n    }\n    void Build() const override {\n        SetUserAction(new PrimaryGeneratorAction);\n        SetUserAction(new RunAction);\n        SetUserAction(new EventAction);\n        SetUserAction(new SteppingAction);\n    }\n};\n\n\n\nJULIA_DEFINE_FAST_TLS // only define this once, in an executable (not in a shared library) if you want fast code.\n\n//----Main program---------------------------------------------------------------------------------\nint main(int, char**)\n{\n    int nthreads = 0; // Default number of threads\n    if (getenv(\"G4NUMTHREADS\")) nthreads = atoi(getenv(\"G4NUMTHREADS\"));\n\n    //--- Required to setup the Julia context------------------------------------------------------\n    jl_init();\n        /* run Julia commands */\n    jl_eval_string(\"include(\\\"MyCode.jl\\\")\");\n    if (jl_exception_occurred()) {\n        std::cout << \"=====> \" << jl_typeof_str(jl_exception_occurred()) << std::endl;\n    }\n\n    //---Construct the default run manager (taking into account the number of threads)-------------\n    G4RunManager* runManager;\n    if (nthreads > 0) { \n        runManager = G4RunManagerFactory::CreateRunManager(G4RunManagerType::MT);\n        runManager->SetNumberOfThreads(nthreads);\n        runManager->SetUserInitialization(new WorkerInitialization());\n    } else {\n        runManager = G4RunManagerFactory::CreateRunManager(G4RunManagerType::Serial);\n    }\n\n    //---Set mandatory initialization classes------------------------------------------------------\n    // Detector construction\n    runManager->SetUserInitialization(new DetectorConstruction());\n\n    // Physics list\n    runManager->SetUserInitialization(new QBBC(0));\n\n    // User action initialization\n    runManager->SetUserInitialization(new ActionInitialization());\n\n    // Initialize G4 kernel\n    runManager->Initialize();\n    \n    // Get the pointer to the User Interface manager\n    auto UImanager = G4UImanager::GetUIpointer();\n    UImanager->ApplyCommand(\"/control/verbose 1\");\n    UImanager->ApplyCommand(\"/run/verbose 1\");\n    //UImanager->ApplyCommand(\"/event/verbose 0\");\n    //UImanager->ApplyCommand(\"/tracking/verbose 1\");\n    UImanager->ApplyCommand(\"/gun/particle e+\");\n    UImanager->ApplyCommand(\"/gun/energy 100 MeV\");\n\n    // Start a run (we need to enter GC safe region here because the worker threads \n    // will enter a wait state while waiting for workers to finish and this can block GC\n    auto state = jl_gc_safe_enter(jl_current_task->ptls);\n    runManager->BeamOn(100000);\n    jl_gc_safe_leave(jl_current_task->ptls, state);\n\n    // Job termination---------------------------------------------------------------------------\n    delete runManager;\n\n    // strongly recommended: notify Julia that the program is about to terminate. \n    // this allows Julia time to cleanup pending write requests and run all finalizers\n    jl_atexit_hook(0);\n}","category":"section"},{"location":"examples/TestEm3/#Extended/TestEm3-Example","page":"Extended/TestEm3 Example","title":"Extended/TestEm3 Example","text":"This example is based on the Geant4 extended/TestEm3 example of the Geant4 distribution. It can be used to test the electromagnetic physics processes in Geant4.\n\nHow to collect energy deposition in a sampling calorimeter.\nHow to survey energy flow.\nHow to print stopping power.","category":"section"},{"location":"examples/TestEm3/#Geometry","page":"Extended/TestEm3 Example","title":"Geometry","text":"The calorimeter is a box made of a given number of layers. A layer consists of a sequence of various absorbers (maximum MaxAbsor=9). The layer is replicated.\n\nParameters defining the calorimeter :\n\nthe number of layers,\nthe number of absorbers within a layer,\nthe material of the absorbers,\nthe thickness of the absorbers,\nthe transverse size of the calorimeter (the input face is a square).\n\nIn addition a transverse uniform magnetic field can be applied.\n\nThe default geometry is constructed in DetectorConstruction class, but all of the above parameters can be modified interactively via the commands defined in the DetectorMessenger class.\n\n      |<----layer 0---------->|<----layer 1---------->|<----layer 2---------->|\n      |           |           |                       |                       |\n      ==========================================================================\n      ||          |           ||          |           ||          |           ||\n      ||          |           ||          |           ||          |           ||\n      ||   abs 1  | abs 2     ||   abs 1  | abs 2     ||   abs 1  | abs 2     ||\n      ||          |           ||          |           ||          |           ||\n      ||          |           ||          |           ||          |           ||\nbeam  ||          |           ||          |           ||          |           ||\n====> ||          |           ||          |           ||          |           ||\n      ||          |           ||          |           ||          |           ||\n      ||          |           ||          |           ||          |           ||\n      ||          |           ||          |           ||          |           ||\n      ||          |           ||          |           ||          |           ||\n      ||   cell 1 | cell 2    ||   cell 3 | cell 4    ||   cell 5 | cell 6    ||\n      ==========================================================================\n      ^           ^           ^           ^           ^           ^           ^\n      pln1        pln2        pln3       pln4        pln5        pln6       pln7\n\nnote: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"examples/TestEm3/#Table-of-contents","page":"Extended/TestEm3 Example","title":"Table of contents","text":"Pages = [\"TestEm3.md\"]\nDepth = 2:3","category":"section"},{"location":"examples/TestEm3/#Loading-the-necessary-Julia-modules","page":"Extended/TestEm3 Example","title":"Loading the necessary Julia modules","text":"Load the Geant4 and Geant4.SystemOfUnits modules. We will also use the FHist and Plots modules to handle the histograms and plots, and Printf to format the output.\n\nusing Geant4\nusing Geant4.SystemOfUnits\nusing FHist, Plots, Printf\nimport DisplayAs: PNG","category":"section"},{"location":"examples/TestEm3/#Define-Detector-structure","page":"Extended/TestEm3 Example","title":"Define Detector structure","text":"The detector is a sandwich calorimeter made of layers of sensitive and absorber materials. The detector is defined by the TestEm3Detector structure. We include the TestEm3Detector.jl file not to clutter the example. We can also use a GDML file to define the geometry. This is done by instantiating the G4JLDetectorGDML type with the GDML file as argument.\n\nconst useGdml = true\ninclude(joinpath(@__DIR__, \"TestEm3Detector.jl\"))\nif useGdml\n    detector = G4JLDetectorGDML(\"$(@__DIR__)/TestEm3.gdml\")\nelse\n    detector = TestEm3Detector()\nend\n\nGeant4.G4JLDetectorGDML(CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4VPhysicalVolume}(Ptr{Geant4.G4VPhysicalVolume}(0x000000000fe076b0)))","category":"section"},{"location":"examples/TestEm3/#Define-Simulation-Data-struct","page":"Extended/TestEm3 Example","title":"Define Simulation Data struct","text":"It consists on a number of counters and statistical accumulators to store the simulation results. In addition, it includes a number of histograms to store the results.\n\nconst Hist1D64 = Hist1D{Float64}\nmutable struct TestEm3SimData <: G4JLSimulationData\n    ##---Run data-----------------------------------------------------------------------------------\n    fParticle::CxxPtr{G4ParticleDefinition}\n    fEkin::Float64\n\n    ##fSumEAbs::Vector{Float64}\n    ##fSum2EAbs::Vector{Float64}\n    ##fSumLAbs::Vector{Float64}\n    ##fSum2LAbs::Vector{Float64}\n\n    ##fEdepTot::Float64\n    ##fEdepTot2::Float64\n    ##fEleakTot::Float64\n    ##fEleakTot2::Float64\n\n    ##fEtotal::Float64\n    ##fEtotal2::Float64\n\n    ##fEnergyFlow::Vector{Float64}\n    ##fLateralEleak::Vector{Float64}\n    ##fEnergyDeposit::Matrix{Float64}\n\n    fChargedStep::Int32\n    fNeutralStep::Int32\n\n    fN_gamma::Int32\n    fN_elec::Int32\n    fN_pos::Int32\n\n    fEnergyDeposit::Vector{Float64}     ## Energy deposit per event\n    fTrackLengthCh::Vector{Float64}     ## Track length per event\n\n    fEdepEventHistos::Vector{Hist1D64}\n    fTrackLengthChHistos::Vector{Hist1D64}\n    fEdepHistos::Vector{Hist1D64}\n    fAbsorLabel::Vector{String}\n\n    ##G4double fEdeptrue [kMaxAbsor];\n    ##G4double fRmstrue  [kMaxAbsor];\n    ##G4double fLimittrue[kMaxAbsor];\n    ##G4bool fApplyLimit;\n\n    ##fTimer::Float64\n\n    TestEm3SimData() = new()\nend\n\nWe also define the add! function to reduce the simulation results between the master and worker threads.\n\nfunction add!(x::TestEm3SimData, y::TestEm3SimData)\n    x.fChargedStep += y.fChargedStep\n    x.fNeutralStep += y.fNeutralStep\n    x.fN_gamma += y.fN_gamma\n    x.fN_elec += y.fN_elec\n    x.fN_pos += y.fN_pos\n    x.fEdepEventHistos += y.fEdepEventHistos\n    x.fTrackLengthChHistos += y.fTrackLengthChHistos\n    x.fEdepHistos += y.fEdepHistos\nend\n\nadd! (generic function with 1 method)\n\nDefine a function to plot the simulation data from the application\n\nfunction do_plot(data::TestEm3SimData)\n    (;fEdepHistos, fEdepEventHistos, fTrackLengthChHistos, fAbsorLabel) = data\n    lay = @layout [°; ° °]\n    img = plot(layout=lay, show=true, size=(1400,1000))\n    for (h, l) in zip(fEdepHistos, fAbsorLabel)\n        plot!(subplot=1, h, title=\"Energy Deposition\", xlabel=\"layer #\", label=l, show=true)\n    end\n    for (h, l) in zip(fEdepEventHistos, fAbsorLabel)\n        plot!(subplot=2, h, title=\"Energy/event Distribution\", label=l, xlabel=\"MeV\")\n    end\n    for (h, l) in zip(fTrackLengthChHistos, fAbsorLabel)\n        plot!(subplot=3, h, title=\"Track Lengh Distribution\", label=l, xlabel=\"mm\")\n    end\n    return img\nend\n\ndo_plot (generic function with 1 method)","category":"section"},{"location":"examples/TestEm3/#Particle-Gun-initialization","page":"Extended/TestEm3 Example","title":"Particle Gun initialization","text":"particlegun = G4JLGunGenerator(particle = \"e-\",\n                               energy = 1GeV,\n                               direction = G4ThreeVector(1,0,0),\n                               position = G4ThreeVector(0,0,0))  # temporary potition, will update once the detector is constructed\n\nGeant4.G4JLGunGenerator(\"ParticleGun\", Geant4.G4JLParticleGunData(nothing, \"e-\", G4ThreeVector(1.0,0.0,0.0), G4ThreeVector(0.0,0.0,0.0), 1000.0), Geant4.var\"#init#19\"(), Geant4.var\"#gen#20\"(), Geant4.G4JLGeneratorAction[])","category":"section"},{"location":"examples/TestEm3/#Define-the-Simulation-User-Actions","page":"Extended/TestEm3 Example","title":"Define the Simulation User Actions","text":"##---Step action------------------------------------------------------------------------------------\nfunction stepaction(step::G4Step, app::G4JLApplication)::Nothing\n    detector = app.detector\n    data = getSIMdata(app)\n    prepoint = GetPreStepPoint(step)\n    track = GetTrack(step)\n\n    # Return if step in not in the world volume\n    prepoint |> GetPhysicalVolume |> GetLogicalVolume |> GetMaterial == detector.fWorldMaterial && return nothing\n\n    particle = GetDefinition(track)\n    charge  = GetPDGCharge(particle)\n    stepl = 0.\n    if charge != 0.\n        stepl = GetStepLength(step)\n        data.fChargedStep += 1\n    else\n        data.fNeutralStep += 1\n    end\n    edep = GetTotalEnergyDeposit(step) * GetWeight(track)\n    absorNum  = GetCopyNumber(GetTouchable(prepoint), 0)\n    layerNum  = GetCopyNumber(GetTouchable(prepoint), 1) + 1  ## replicas copynumber starts at 0\n\n    data.fEnergyDeposit[absorNum] += edep\n    data.fTrackLengthCh[absorNum] += stepl\n\n    push!(data.fEdepHistos[absorNum], layerNum, edep)\n    nothing\nend\n\n##---Tracking pre-action----------------------------------------------------------------------------\nlet G4Gamma, G4Electron, G4Positron, first=true\nglobal function pretrackaction(track::G4Track, app::G4JLApplication)::Nothing\n    if first\n        G4Gamma    = FindParticle(\"gamma\")\n        G4Electron = FindParticle(\"e-\")\n        G4Positron = FindParticle(\"e+\")\n        first = false\n    end\n    data = getSIMdata(app)\n    d = GetDefinition(track)\n    if d === G4Gamma\n        data.fN_gamma += 1\n    elseif d === G4Electron\n        data.fN_elec +=1\n    elseif d === G4Positron\n        data.fN_pos += 1\n    end\n    nothing\nend\nend\n\n##---Tracking post-action---------------------------------------------------------------------------\nfunction posttrackaction(track::G4Track, ::G4JLApplication)::Nothing\n  nothing\nend\n\n##---Begin Run Action-------------------------------------------------------------------------------\nfunction beginrun(run::G4Run, app::G4JLApplication)::Nothing\n    data = getSIMdata(app)\n    (; fNbOfAbsor, fNbOfLayers, fAbsorMaterial, fAbsorThickness) = app.detector\n    gun = app.generator.data.gun\n    data.fParticle = GetParticleDefinition(gun)\n    data.fEkin = GetParticleEnergy(gun)\n    data.fN_gamma = data.fN_elec = data.fN_pos = 0\n    data.fChargedStep = data.fNeutralStep = 0\n    # init arrays\n    data.fEnergyDeposit = zeros(fNbOfAbsor)\n    data.fTrackLengthCh = zeros(fNbOfAbsor)\n    data.fEdepHistos = [Hist1D(;counttype=Float64,binedges=0.:1.0:fNbOfLayers) for i in 1:fNbOfAbsor]\n    data.fEdepEventHistos = [Hist1D(;binedges=0.:10.:1000.) for i in 1:fNbOfAbsor]\n    data.fTrackLengthChHistos = [Hist1D(;binedges=0.:20.:2000.) for i in 1:fNbOfAbsor]\n    data.fAbsorLabel = [\"$(fAbsorThickness[i])mm of $(fAbsorMaterial[i] |> GetName |> String)\" for i in 1:fNbOfAbsor]\n    nothing\nend\n##---End Run Action---------------------------------------------------------------------------------\nfunction endrun(run::G4Run, app::G4JLApplication)::Nothing\n    ##---end run action is called for each workwer thread and the master one\n    if G4Threading!G4GetThreadId() < 0\n        data = app.simdata[1]\n        ##---This is the master thread, so we need to add all the simuation results-----------------\n        for d in app.simdata[2:end]\n            add!(data, d)\n        end\n        nEvt = GetNumberOfEvent(run)\n        norm = nEvt > 0 ? 1/nEvt : 1.\n\n        @printf \"------------------------------------------------------------\\n\"\n        @printf \" Beam particle %s E = %.2f GeV\\n\" String(GetParticleName(data.fParticle)) data.fEkin/GeV\n        @printf \" Mean number of gamma          %.2f\\n\" data.fN_gamma*norm\n        @printf \" Mean number of e-             %.2f\\n\" data.fN_elec*norm\n        @printf \" Mean number of e+             %.2f\\n\" data.fN_pos*norm\n        @printf \" Mean number of charged steps  %f\\n\"   data.fChargedStep*norm\n        @printf \" Mean number of neutral steps  %f\\n\"   data.fNeutralStep*norm\n        @printf \"------------------------------------------------------------\"\n    else\n        G4JL_println(\"end-run  for worker $(G4Threading!G4GetThreadId())\")\n    end\nend\n\n##---Begin Event Action-----------------------------------------------------------------------------\nfunction beginevent(evt::G4Event, app::G4JLApplication)\n    data = getSIMdata(app)\n    fill!(data.fEnergyDeposit, 0.0)\n    fill!(data.fTrackLengthCh, 0.0)\n    nothing\nend\n\n##---End Event Action-------------------------------------------------------------------------------\nfunction endevent(evt::G4Event, app::G4JLApplication)\n    data = getSIMdata(app)\n    (; fNbOfAbsor, fNbOfLayers) = app.detector\n    for i in 1:fNbOfAbsor\n        push!(data.fEdepEventHistos[i], data.fEnergyDeposit[i])\n        push!(data.fTrackLengthChHistos[i], data.fTrackLengthCh[i])\n    end\n    nothing\nend\n\nendevent (generic function with 1 method)","category":"section"},{"location":"examples/TestEm3/#Create-the-Application","page":"Extended/TestEm3 Example","title":"Create the Application","text":"app = G4JLApplication(detector = TestEm3Detector(),               ## detector with parameters\n                      simdata = TestEm3SimData(),                 ## simulation data structure\n                      generator = particlegun,                    ## primary particle generator\n                      nthreads = VERSION > v\"1.9\" ? 4 : 0,        ## number of threads (MT)\n                      physics_type = FTFP_BERT,                   ## what physics list to instantiate\n                      ##----Actions--------------------------------\n                      stepaction_method = stepaction,             ## step action method\n                      pretrackaction_method = pretrackaction,     ## pre-tracking action\n                      posttrackaction_method = posttrackaction,   ## post-tracking action\n                      beginrunaction_method = beginrun,           ## begin-run action (initialize counters and histograms)\n                      endrunaction_method = endrun,               ## end-run action (print summary)\n                      begineventaction_method = beginevent,       ## begin-event action (initialize per-event data)\n                      endeventaction_method = endevent            ## end-event action (fill histogram per event data)\n                      )\n\nGeant4.G4JLApplication{Main.var\"##277\".TestEm3Detector, Main.var\"##277\".TestEm3SimData}(Geant4.G4MTRunManagerAllocated(Ptr{Nothing}(0x00000000110869c0)), Main.var\"##277\".TestEm3Detector(2, 50, 400.0, [2.3, 5.7], 8.0, 400.0, 480.0, 480.0, CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4Material}[CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4Material}(Ptr{Geant4.G4Material}(0x0000000010ca0210)), CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4Material}(Ptr{Geant4.G4Material}(0x000000000f9a2f50))], CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4Material}(Ptr{Geant4.G4Material}(0x000000000fccd4d0)), #undef, #undef, CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4VPhysicalVolume}(Ptr{Geant4.G4VPhysicalVolume}(0x00007f9e2d6f29f0)), #undef, #undef, CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4VPhysicalVolume}(Ptr{Geant4.G4VPhysicalVolume}(0x00007f9e1fcfcd90)), #undef, #undef, CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4VPhysicalVolume}(Ptr{Geant4.G4VPhysicalVolume}(0x00007f9e2d6f51a0)), #undef, #undef, #undef), Main.var\"##277\".TestEm3SimData[Main.var\"##277\".TestEm3SimData(CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4ParticleDefinition}(Ptr{Geant4.G4ParticleDefinition}(0x0000000000000003)), 6.93258630574366e-310, 1, 0, 0, 0, 1, #undef, #undef, #undef, #undef, #undef, #undef), Main.var\"##277\".TestEm3SimData(CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4ParticleDefinition}(Ptr{Geant4.G4ParticleDefinition}(0x0000000000000003)), 6.93258630574366e-310, 1, 0, 0, 0, 1, #undef, #undef, #undef, #undef, #undef, #undef), Main.var\"##277\".TestEm3SimData(CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4ParticleDefinition}(Ptr{Geant4.G4ParticleDefinition}(0x0000000000000003)), 6.93258630574366e-310, 1, 0, 0, 0, 1, #undef, #undef, #undef, #undef, #undef, #undef), Main.var\"##277\".TestEm3SimData(CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4ParticleDefinition}(Ptr{Geant4.G4ParticleDefinition}(0x0000000000000003)), 6.93258630574366e-310, 1, 0, 0, 0, 1, #undef, #undef, #undef, #undef, #undef, #undef), Main.var\"##277\".TestEm3SimData(CxxWrap.CxxWrapCore.CxxPtr{Geant4.G4ParticleDefinition}(Ptr{Geant4.G4ParticleDefinition}(0x0000000000000003)), 6.93258630574366e-310, 1, 0, 0, 0, 1, #undef, #undef, #undef, #undef, #undef, #undef)], Geant4.G4JLGunGenerator(\"ParticleGun\", Geant4.G4JLParticleGunData(nothing, \"e-\", G4ThreeVector(1.0,0.0,0.0), G4ThreeVector(0.0,0.0,0.0), 1000.0), Geant4.var\"#init#19\"(), Geant4.var\"#gen#20\"(), Geant4.G4JLGeneratorAction[]), nothing, nothing, 4, 0, Geant4.G4MTRunManager, Geant4.G4JLDetectorConstruction, Geant4.FTFP_BERT, Geant4.G4JLRunAction, Geant4.G4JLEventAction, Geant4.G4JLTrackingAction, Geant4.G4JLSteppingAction, Main.var\"##277\".stepaction, Main.var\"##277\".pretrackaction, Main.var\"##277\".posttrackaction, Main.var\"##277\".beginrun, Main.var\"##277\".endrun, Main.var\"##277\".beginevent, Main.var\"##277\".endevent, nothing, nothing, Dict{String, Geant4.G4JLProtoSD}(), Dict{String, Vector{Geant4.G4JLSensitiveDetector}}(), Geant4.G4JLScoringMesh[], nothing, nothing)","category":"section"},{"location":"examples/TestEm3/#Configure,-Initialize-and-Run","page":"Extended/TestEm3 Example","title":"Configure, Initialize and Run","text":"configure(app)\ninitialize(app)\nSetParticlePosition(particlegun, G4ThreeVector(-app.detector.fWorldSizeX/2 + 1mm,0,0))  ## Only now is known the size of the 'world'\n\nbeamOn(app, 1000)\n\nBuilding Geometry now!!!\nG4WT1 > end-run  for worker 1\nG4WT2 > end-run  for worker 2\nG4WT3 > end-run  for worker 3\nG4WT0 > end-run  for worker 0\n------------------------------------------------------------\n Beam particle e- E = 1.00 GeV\n Mean number of gamma          521.14\n Mean number of e-             897.74\n Mean number of e+             53.34\n Mean number of charged steps  3739.165000\n Mean number of neutral steps  3719.589000\n------------------------------------------------------------","category":"section"},{"location":"examples/TestEm3/#Plot-the-results","page":"Extended/TestEm3 Example","title":"Plot the results","text":"img = do_plot(app.simdata[1])\nPNG(img)\n\n(Image: )","category":"section"},{"location":"examples/TestEm3/#Change-the-primary-particle-enerqy-and-run-the-simulation-again","page":"Extended/TestEm3 Example","title":"Change the primary particle enerqy and run the simulation again","text":"SetParticleEnergy(particlegun, 100MeV)\nbeamOn(app, 1000)\nimg = do_plot(app.simdata[1])\nPNG(img)\n\n(Image: )","category":"section"},{"location":"examples/TestEm3/#Change-the-geometry-and-run-the-simulation-again","page":"Extended/TestEm3 Example","title":"Change the geometry and run the simulation again","text":"Add a new absorber layer\n\nreinitialize(app, TestEm3Detector(absorThickness = [2.3mm, 5.7mm, 1mm],\n                                  absorMaterial = [\"G4_Pb\", \"G4_lAr\", \"G4_Al\"]))\nbeamOn(app, 1000)\nimg = do_plot(app.simdata[1])\nPNG(img)\n\n(Image: )\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#Geant4.jl","page":"Introduction","title":"Geant4.jl","text":"Julia bindings for the Geant4 particle transportation toolkit. It is using CxxWrap.jl package to wrap C++ types and functions to Julia. Since the Geant4 toolkit is rather large and complex, writing the wrapper code by hand is not really an option. For this we use the package WrapIt that automates the generation of the wrapper code making use of the clang library.\n\nDocumentation of the concepts and how to write applications with the Geant4 toolkit can be found with the Application Developer Guide or the Classes and Members reference guide for a detailed description of each C++ class. In this document we will only highlight the differences between the Julia and the C++ API. We will document the additional types that have been added on top of the C++ classes to make the user interface more Julia friendly. To distinguish these new types from the types coming directly from C++ via the CxxWrap wrappers, these types are prefixed with G4JL.","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"The Geant4.jl package does no require any special installation. Stable releases are registered into the Julia general registry, and therefore can be deployed with the standard Pkg Julia package manager.\n\njulia> using Pkg\njulia> Pkg.add(\"Geant4\")\n\nExamples are located in a separate repository G4Examples to minimize dependencies since they use additional functionality such as graphics, plotting, analysis tools, etc. To use and play with the examples, the user can clone the examples repository and setup a complete Julia environment with:\n\n$ git clone https://github.com/JuliaHEP/G4Examples.jl.git\n$ julia --project=G4Examples.jl -e 'import Pkg; Pkg.instantiate()'","category":"section"},{"location":"#Getting-started","page":"Introduction","title":"Getting started","text":"Import the Geant4 module. All the wrapped Geant4 classes are exported since they are prefixed by G4 minimizing the chances of a name clash with other Julia symbols. \n\n\njulia> using Geant4\njulia> runManager = G4RunManager()\n**************************************************************\n Geant4 version Name: geant4-11-01-patch-01 [MT]   (10-February-2023)\n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\nGeant4.G4RunManagerAllocated(Ptr{Nothing} @0x00007f9fcb6f9c50)\n\njulia> methodswith(G4RunManager, supertypes=true)\n[1] convert(t::Type{G4RunManager}, x::T) where T<:G4RunManager in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:676\n[2] AbortEvent(arg1::Union{CxxWrap.CxxWrapCore.CxxRef{<:G4RunManager}, Union{CxxWrap.CxxWrapCore.SmartPointer{T2}, T2} where T2<:G4RunManager}) in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:618\n...\n[94] rndmSaveThisRun(arg1::Union{CxxWrap.CxxWrapCore.CxxRef{<:G4RunManager}, Union{CxxWrap.CxxWrapCore.SmartPointer{T2}, T2} where T2<:G4RunManager}) in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:618\n\njulia> v = GetVersionString(runManager)\nConstCxxRef{G4String}(Ptr{G4String} @0x00007ffed34df2d8)\n\njulia> String(v)\n\" Geant4 version Name: geant4-11-01-patch-01 [MT]   (10-February-2023)\"\n\nNote that class methods are called with the object instance as first argument. In C++ the GetVersionString method would be called as runManager->GetVersionString() while in Julia it is called as GetVersionString(runManager). Thanks to the Julia multi-dispatch we do not need to prefix the methods with the module name Geant4.GetVersionString(runManager), even for very common function names such as mag.\n\njulia> v = G4ThreeVector(1,2,3)\nGeant4.CLHEP!Hep3VectorAllocated(Ptr{Nothing} @0x00007f9fcaf2a710)\n\njulia> mag(v)\n3.7416573867739413","category":"section"},{"location":"#Geant4-Julia-interface","page":"Introduction","title":"Geant4 Julia interface","text":"The main goal for defining a Geant4 application in the Julia interface is to create an instance of the G4JLApplication type, where all the needed elements for running a Geant4 application are declared, such as the detector geometry, the physics list, the primary particle generator, the type of run manager, the user actions, etc. \n\n(Image: Figure)\n\nThese are the needed elements:\n\ndetector. An instance of a detector structure inheriting from the abstract type G4JLDetector, in which all the detector parameters are defined. The user should also provide a method specialization of Geant4.getConstructor(::G4JLDetector)::Function to return the Julia function that toolkit needs to call in order to construct the geometry and return the pointer of the 'world' physical volume. There is no default.\nfield. An instance of the magnetic field class. The G4JLUniformMagField(...) function provides a uniform magnetic field. See later how to define a custom one.\nsimdata. An instance of the simulation data structure that the program will need to collect during the simulation execution. This mutable structure needs to inherit from the abstract type G4JLSimulationData and is completely user defined with counters, data structures to collect the hits or doses, histograms, etc. The default is an instance of type G4JLNoData.\nnthreads. Number of worker threads to be used. The default is 0, which means serial mode. Any number > 0 will use the MT functionality of Geant4, and therefore the user would need to pay attention to the user actions that are run concurrently to avoid data races (see Julia doc on multi-threading)\nverbose. Verbosity level (for physics list). The default is 0.\nphysics_type. The physics list predefined type. Default is FTFP_BERT.\ngenerator_type. The primary generator generator type. The default is G4JLParticleGun, which encapsulates a G4ParticleGun. The underlying G4ParticleGun can be obtained by calling GetGun().\nuser actions. Julia methods defining the different possible user actions (e.g. stepping action, tracking action, run action, event action). The default is no action.\nsdetectors. List of sensitive detectors. This is given as a Vector of pairs lv::String => sd::G4JLSensitiveDetector to associate logical volumes by name to sensitive detector instances (see next section).\nscorers. List of scoring meshes defined with the function G4JLScoringMesh.\n\nOnce the G4JLApplication is instantiated (and implicitly an instance of the G4RunManager created), the user can control the application with the following commands:\n\nconfigure(::G4JLApplication). It associates the physics list, generator and user actions to the selected G4RunManager instance. \ninitialize(::G4JLApplication). It basically calls the Initialize() method of the run manager and associate the declared sensitive detectors.\nreinitialize(::G4JLApplication, ::G4JLDetector). It re-defines the declared detector geometry with a new instance of G4JLDetector. \nbeamOn(::G4JLApplication, ::Int). Starts a run with a given number of events.","category":"section"},{"location":"#Constructing-the-detector","page":"Introduction","title":"Constructing the detector","text":"Parameters of the detector are collected in a user defined mutable data structure inheriting from G4JLDetector. The user also needs to provide a Julia method for constructing the geometry. This method needs to have following the signature\n\n<User_Det_Constructor_Function>(::G4JLDetector)::CxxPtr{G4VPhysicalVolume}\n\nThe only argument of the function gives access to the user defined structure with all the detector parameters.\n\nnote: Note\nThe type CxxPtr{G4VPhysicalVolume} denotes a C++ pointer to the G4VPhysicalVolume type.\n\nThe user can use the native G4 classes for constructing the geometry such as the different type of solids (e.g. G4Box, G4Tubs, etc.), G4LogicalVolume, G4PVPlacement, G4PVReplica, etc. Alternatively, the user can use the type G4JLDetectorGDML to construct a detector from a GDML file.\n\nnote: Note\nNote that by default constructed C++ objects from Julia would get automatically deleted by the Julia garbage collector (GC) since a finalizer gets installed to the wrapper classes. This is particularly a problem when constructing the geometry.\n\nCurrently for the following classes have the finalizer disabled in the wrapper: G4PVPlacement, G4LogicalVolume, G4PVReplica, G4Material, G4Isotope, G4Element. This means that instances of them will not be deleted by Julia to avoid double deletion (often a crash) when the geometry gets deleted at the finalization of the application from the C++ side. \n\nA pointer to any of the G4Solid needs to be passed to the G4LogicalVolume using move!(objref) function to transfer the ownership of the referenced object to the C++ side. See the following example:\n\ntrackerS = G4Tubs(\"tracker\", 0, trackerSize, trackerSize, 0, 360deg)\ntrackerLV = G4LogicalVolume(move!(trackerS), m_air, \"Tracker\")\nG4PVPlacement(nothing,              # no rotation\n    G4ThreeVector(0,0,0),           # at (0,0,0)\n    trackerLV,                      # its logical volume\n    \"Tracker\",                      # its name\n    worldLV,                        # its mother  volume\n    false,                          # no boolean operations\n    0,                              # copy number\n    checkOverlaps)                  # checking overlaps","category":"section"},{"location":"#Physics-List","page":"Introduction","title":"Physics List","text":"The user can provide one of the pre-defined physics lists, such as QGS_BIC, QBBC or FTFP_BERT. Alternatively, the user can define a Julia structas a subtype ofG4VUserPhysicsList` and modify some of the physcis in the constructor. For example:\n\nstruct ScintPhysicsList <: G4VUserPhysicsList\n    function ScintPhysicsList(verbose)\n        pl = FTFP_BERT(verbose)\n        # replace G4EmStandardPhysics\n        ReplacePhysics(pl, move!(G4EmStandardPhysics_option4(verbose)))\n        # register G4OpticalPhysics\n        RegisterPhysics(pl, move!(G4OpticalPhysics(verbose)))\n        # activate  scintillation\n        optpar = G4OpticalParameters!Instance()\n        SetProcessActivation(optpar, \"Scintillation\", true)\n        # activate cherenkov radiation\n        SetProcessActivation(optpar, \"Cerenkov\", true)\n        return pl\n    end \nend","category":"section"},{"location":"#Magnetic-field","page":"Introduction","title":"Magnetic field","text":"The user can define either an uniform magnetic field or a custom one. To define an custom one:\n\ndefine first a user structure for the parameters that inherits from the abstract type G4JLFieldData\nthen, define a function with the signature (result::G4ThreeVector, position::G4ThreeVector, params::G4JLFieldData)::Nothing\nand finally, with all this, instantiate the magnetic field calling the function \n  G4JLMagneticField(<name>, <data>; getfield_method=<function>)","category":"section"},{"location":"#Primary-Particle-Generator","page":"Introduction","title":"Primary Particle Generator","text":"The user can define either a custom primary particle generator or use one of the two defined ones:\n\nG4JLGunGenerator. Uses the G4ParticleGun class of Geant4 that generates a single particle type with a fix kinetic energy, position and direction.\nG4JLGunGenerator(particle = \"proton\", \n                 energy = 3GeV, \n                 direction = G4ThreeVector(0,0,1), \n                 position = G4ThreeVector(0,0,-2940.0))\nG4JLGeneralParticleSource. Uses the G4GeneralParticleSource class of Geant4 to generate one of more sources of primary particles with predefined distributions for energy, position and direction. An example can be:\nsrc1 = (particle=\"e+\", intensity=0.5,\n        ene=(type=\"Exp\", min=2MeV, max=10MeV, ezero=2.),\n        pos=(type=\"Plane\", shape=\"Circle\", centre=G4ThreeVector(1cm,2cm,0cm), radius=3cm),\n        ang=(type=\"cos\", mintheta=0deg, maxtheta=180deg))\nsrc2 = (particle=\"gamma\", intensity=0.5,\n        ene=(type=\"Brem\", min=2MeV, max=10MeV, temp=2e12),\n        pos=(type=\"Plane\", shape=\"Ellipse\", centre=G4ThreeVector(3cm,1cm,0cm), halfx=1cm, halfy=2cm),\n        ang=(type=\"iso\", mintheta=0deg, maxtheta=180deg))\ngps = G4JLGeneralParticleSource(sources = [ src1, src2 ])\nthe standard particle gun parameters works as well:\nG4JLGeneralParticleSource(particle = \"proton\", \n                          energy = 3GeV, \n                          direction = G4ThreeVector(0,0,1), \n                          position = G4ThreeVector(0,0,0))\nCustom Generator. It is fairly simple to write a custom generator. It is needed to define a structure for the parameters to configure the generator, and a two functions to initialize and generate the primary particles called for each event. Here is an example:\n# define the data structure with the generator parameters\nmutable struct PlaneSourceData <: G4JLGeneratorData\n  particleName::String\n  particlePtr::CxxPtr{G4ParticleDefinition}\n  energy::Float64 \n  halfx::Float64\n  halfy::Float64\n  position::G4ThreeVector\n  direction::G4ThreeVector\nend\n\n# define the constructor with the default parameters\nfunction PlaneSource(;particle=\"gamma\", energy=0.07MeV, halfx=7cm, halfy=7cm, \n                                      position=G4ThreeVector(0,0,-14.9cm), direction=G4ThreeVector(0,0,1))\n  data = PlaneSourceData(particle, CxxPtr{G4ParticleDefinition}(C_NULL), energy, halfx, halfy, position, direction)\n  function init(data:: PlaneSourceData, app::G4JLApplication)\n      data.particlePtr = FindParticle(data.particleName)\n  end\n  function generate( evt::G4Event, data:: PlaneSourceData)::Nothing\n      mass = data.particlePtr |> GetPDGMass\n      momentum = √((mass + data.energy)^2 - mass^2)\n      pvec = momentum * data.direction\n      pos = data.position + G4ThreeVector( data.halfx * (rand() - 0.5),  data.halfy * (rand() - 0.5), 0)\n      primary = G4PrimaryParticle(data.particlePtr, pvec |> x, pvec |> y, pvec |> z )\n      vertex = G4PrimaryVertex(pos, 0ns)\n      SetPrimary(vertex, move!(primary))    # note that we give up ownership of the objects just created\n      AddPrimaryVertex(evt, move!(vertex))  # note that we give up ownership of the objects just created\n  end\n  G4JLPrimaryGenerator(\"PlaneSource\", data; init_method=init, generate_method=generate)\nend","category":"section"},{"location":"#User-Actions","page":"Introduction","title":"User Actions","text":"User actions are native Julia functions that are callbacks of the Geant4 toolkit. They are declared in the constructor of G4JLApplication, so they do not need to be associated to a specific function name. All user actions receive a reference to the G4JLApplication from which the user can obtain details of the actual application, such as the current detector, the physics, the generator, or the running simulation data. There are the available attributes of the application instance:\n\n    runmanager::G4RunManager    # The C++ G4RunManager instance\n    detector::DET               # User defined detector structure with all parameters\n    simdata::Vector{DAT}        # User defined simulation data structs (each worker has its own)\n    physics::G4VUserPhysicsList # Physics List\n    generator::G4JLPrimaryGenerator # Primary particle generator\n    field::Union{G4Field, G4JLMagneticField} # Magnetic field instance\n    evtdisplay::G4JLDisplay     # Event display instance\n    nthreads::Int32             # number of worker threads\n    verbose::Int32              # verbosity level for physics lists\n    sdetectors::Dict{String,Vector{G4JLSensitiveDetector}} # dictionary of sensitive detectors\n    scorers::Vector{G4JLScoringMesh} # vector of scoring meshes\n\nThe following are the currently defined possible user actions:\n\nstepping action. Called on each simulation step. The signature is (::G4Step, ::G4JLApplication)::Nothing. Consult the G4Step reference manual to see what you can get from it. \npre-tracking action. Called at the creation of a new participle being tracked. The signature is (::G4Track, ::G4JLApplication)::Nothing. Consult the G4Step reference manual to see what you can get from it.\npost-tracking action. Called at the end of the particle being tracked. The signature is (::G4Track, ::G4JLApplication)::Nothing. Consult the G4Track reference manual to see what you can get from it.\nbegin-event action. Called at the beginning of each event. The signature is (::G4Event, ::G4JLApplication)::Nothing. Consult the G4Event reference manual to see what you can get from it.\nend-event action. Called at the end of each event. The signature is (::G4Event, ::G4JLApplication)::Nothing. Consult the G4Event reference manual to see what you can get from it.\nbegin-run action. Called at the beginning of a run. The signature is (::G4Run, ::G4JLApplication)::Nothing. Consult the G4Run reference manual to see what you can get from it.\nend-run action. Called at the end of a run. The signature is (::G4Run, ::G4JLApplication)::Nothing. Consult the G4Run reference manual to see what you can get from it.","category":"section"},{"location":"#Sensitive-Detectors","page":"Introduction","title":"Sensitive Detectors","text":"The user can define sensitive detectors by defining a data structure and 3 callback functions, which will initialize, fill and dispose the defined data structure. Later, the instantiated sensitive detector would be associated to one or more logical volumes of the detector setup. Instantiating a G4JLSensitiveDetector will require the following arguments:\n\nname. A string to identify the sensitive detector. No default.\nsd data. A instance of a user defined G4JLSDData mutable data structure that will passed to each callback invocation.\ninitialize method. User method that is called at the beginning of each event. The signature is (::B2aSDData, ::G4HCofThisEvent)::Nothing.\nendOfEvent method. User method that is called at the end of each event. The signature is (::B2aSDData, ::G4HCofThisEvent)::Nothing.\nprocessHits method. User method that is called at simulation step that ends at the associated logical volume. The signature is (::B2aSDData, ::G4Step, ::G4TouchableHistory)::Bool. Consult the G4Step reference manual to see what you can get from the G4Step. It returns true if a true hit is generated.\n\nThe following is a example on how to define a sensitive detector\n\n#--------------------------------------------------------------------------------------------------\n#---Define Crystal Sensitive Detector--------------------------------------------------------------\n#--------------------------------------------------------------------------------------------------\n#---SD collected data------------------------------------------------------------------------------\nstruct CrystalSDData <: G4JLSDData\n    hitcollection::Vector{Hit}   # define a hit collection\n    CrystalSDData() = new(Hit[])\nend\n#---Initialize method------------------------------------------------------------------------------\nfunction crystal_initialize(::G4HCofThisEvent, data::CrystalSDData)::Nothing\n    empty!(data.hitcollection)   # empty the hit collection at every event\n    return\nend\n#---Process Hit method-----------------------------------------------------------------------------\nfunction crystal_processHits(step::G4Step, ::G4TouchableHistory, data::CrystalSDData)::Bool\n    part = step |> GetTrack |> GetParticleDefinition\n    part == G4OpticalPhoton && return false \n    edep = step |> GetTotalEnergyDeposit\n    edep <  0. && return false\n    pos = step |> GetPostStepPoint |> GetPosition\n    push!(data.hitcollection, Hit(0., pos, edep, ScintCryst))  # fill the collection with a new Hit\n    return true\nend\n#---Create SD instance-----------------------------------------------------------------------------\nG4JLSensitiveDetector(\"Crystal_SD\", CrystalSDData();           # name an associated data are mandatory\n                       processhits_method=crystal_processHits, # process hist method (also mandatory)\n                       initialize_method=crystal_initialize)   # intialize method","category":"section"},{"location":"#Scoring-meshes","page":"Introduction","title":"Scoring meshes","text":"The user can also specify scoring meshes to obtain quantities on the defined grid. In Geant4 this is achieved using a set of UI commands. In this Julia interface this functionality has been encapsulated in a number of data structures. The function to create a scoring mesh is G4JLScoringMesh and receive as arguments the the type and dimensions of the mesh, the position, the rotation, the number of bins in each dimension, and the quantities to accumulate with eventually some filter conditions. See for example the scoring mesh from RE03:\n\nsc1 = G4JLScoringMesh(\"boxMesh_1\",\n                      BoxMesh(1m,1m,1m),\n                      bins = (30, 30, 30),\n                      quantities = [ energyDeposit(\"eDep\")\n                                     nOfStep(\"nOfStepGamma\", filters=[ParticleFilter(\"gammafilter\", \"gamma\")])\n                                     nOfStep(\"nOfStepEMinus\", filters=[ParticleFilter(\"eMinusFilter\", \"e-\")])\n                                     nOfStep(\"nOfStepEPlus\", filters=[ParticleFilter(\"ePlusFilter\", \"e+\")])\n                                   ]\n                      )\n\nThe scoring mesh is added into the 'scorersargument when constructing a [G4JLApplication`](@ref). After a run hs been executed, the user can obtain the quantity values (sum, sum2,entries) on the 3D grid just calling by accessing the quantity as an attribute of the scoring mesh. The returned 3D Julia array is shaped to the declared bins. \n\njulia> beamOn(app,10000)\njulia> sum, sum2, entries = sc1.eDep\njulia> typeof(sum)\nArray{Float64, 3}\n\njulia> typeof(entries)\nArray{Int64, 3}\n\njulia> size(sum)\n(30, 30, 30)","category":"section"},{"location":"#Detector-and-Event-Display","page":"Introduction","title":"Detector and Event Display","text":"For visualization applications, the user can create an instance of G4JLEventDisplay([settings file]) and give it to the constructor of G4JLApplication in the evtdisplay attribute. The constructor accepts a visualization settings file that will overwrite the default settings in the file Geant4.jl/ext/G4Vis/settings.jl. The format of the settings is Julia NamedTuple. Here is an example:\n\n(\n    display = (\n        show_axis = false,\n    ),\n    trajectories = (\n        color = :yellow,\n    ),\n)","category":"section"},{"location":"#Provided-Examples","page":"Introduction","title":"Provided Examples","text":"Examples are located in a separate repository G4Examples to minimize dependencies for this core package.\n\nIn addition, they are documented in this generated documentation. The user can browse the rendered examples in documentation together with the generated output of running them with the current version of the package. At the same time it is possible to download a copy of them as a Jupyter notebook, as Markdownfile and as a plain Julia script.\n\nIf you want to run them you need to have Julia installed. Then, to setup a proper Julia environment, the user can take the Project.toml that contains the full list of dependencies required for the examples.\n\nTo setup the environment:\n\nPlace the Project.toml file in the current directory\nExecute julia --project -e 'import Pkg;Pkg.instantiate()' to download and install all required packages. This may take long rthe first time because some of the examples depend of complex and elaborated packages, for example Geant4 itself with all the data files and Makie for the visualization\nNow, you can run the downloaded example julia --project <example.jl>\n\nList of currently available examples:\n\n   Pages = Main.examples_mds\n   Depth = 1:1","category":"section"},{"location":"#Building-the-wrapper-code","page":"Introduction","title":"Building the wrapper code","text":"We use the Geant4 native binary libraries and data from the binary package Geant4_jll, which has been produced with the BinaryBuilder recipe. We will have a new version of the Geant4_jll package for each new release of Geant4.\n\nThe wrapper library is downloaded from the binary package Geant4_julia_jll.\n\nWe have the possibility during the development of this package, or to add addtional classes, to re-generate locally a new C++ wrapper library. For this, we need to have wrapit installed, which itself requires libclang to be installed. Soon will be available as a Julia package WrapIt.jl.\n\nThe configuration file gen/Geant4.wit.in is the input to the automated process. New header files can be added to the input list.\nThe script gen/build.jl does the work of generating the code and building the library. The commands to execute are:\njulia --project=gen -e 'import Pkg; Pkg.instantiate()'\njulia --project=gen gen/build.jl\n\nOnce the wrapper code is stabilized we move the generated code to the repository Geant4_cxxwrap to regenerate the binary package Geant4_julia_jll using the BinaryBuilder.","category":"section"},{"location":"examples/UserLibrary/#UserLibrary.cpp","page":"UserLibrary.cpp","title":"UserLibrary.cpp","text":"// Example of a custom solid class that will be called by Julia \n#include \"G4Box.hh\"\n#include \"G4Tubs.hh\"\n#include \"G4Orb.hh\"\n#include \"G4SubtractionSolid.hh\"\n#include \"G4UnionSolid.hh\"\n\n// The custom solid class needs to inherit from G4VSolid and implement the required methods\nclass RoundCube : public G4VSolid\n{\npublic:\n  RoundCube(double a, double r);\n  virtual ~RoundCube() { delete solid; }\n\n  // Required methods for a custom solid\n  virtual EInside Inside(const G4ThreeVector& p) const override {return solid->Inside(p);}\n  virtual G4ThreeVector SurfaceNormal(const G4ThreeVector& p) const override {return solid->SurfaceNormal(p);}\n  virtual G4double DistanceToIn(const G4ThreeVector& p, const G4ThreeVector& v) const override {return solid->DistanceToIn(p, v);}\n  virtual G4double DistanceToIn(const G4ThreeVector& p) const override {return solid->DistanceToIn(p);}\n  virtual G4double DistanceToOut(const G4ThreeVector& p, const G4ThreeVector& v, \n                                 const G4bool calcNorm=false, G4bool *validNorm=0, \n                                 G4ThreeVector *n=0) const override {return solid->DistanceToOut(p, v, calcNorm, validNorm, n);}\n  virtual G4double DistanceToOut(const G4ThreeVector& p) const override {return solid->DistanceToOut(p);}\n  virtual G4GeometryType GetEntityType() const override {return \"RoundCube\";}\n  virtual std::ostream& StreamInfo(std::ostream& os) const override {os << \"RoundCube with a = \" << a << \" r = \" << r; return os;}\n\n  virtual G4bool CalculateExtent(const EAxis pAxis, const G4VoxelLimits& pVoxelLimits, const G4AffineTransform& pTransform, G4double& pMin, G4double& pMax) const override {return solid->CalculateExtent(pAxis, pVoxelLimits, pTransform, pMin, pMax);}\n  virtual void DescribeYourselfTo (G4VGraphicsScene& scene) const override {return solid->DescribeYourselfTo(scene);}\n  virtual void BoundingLimits(G4ThreeVector& pMin, G4ThreeVector& pMax) const override {return solid->BoundingLimits(pMin, pMax);}\nprivate:\n  G4VSolid* solid;\n  double a, r;\n};\n\n// Constructor of the custom solid (RoundCube) implemented as a union and subtractions of several solids\nRoundCube::RoundCube(double a, double r) : a(a), r(r), G4VSolid(\"RoundCube\") {\n  G4double ca = a / 4;\n  G4VSolid* cube = new G4Box(\"cube\", ca, ca, ca);\n  G4VSolid* cyl = new G4Tubs(\"cyl\", 0, r, ca, 0, 2 * M_PI);\n  G4VSolid* orb = new G4Orb(\"orb\", r);\n\n  G4VSolid* edge = new G4Box(\"edge\", r, r, ca);\n  G4VSolid* vert = new G4Box(\"vert\", r, r, r);\n  G4VSolid* frame = new G4Box(\"frame\", ca, ca, ca);\n\n  G4VSolid* acyl1 = new G4SubtractionSolid(\"ucyl\", edge, cyl, G4Transform3D(G4RotationMatrix(), G4ThreeVector(-r, -r, 0)));\n  G4VSolid* acyl2 = new G4SubtractionSolid(\"ucyl\", edge, cyl, G4Transform3D(G4RotationMatrix(), G4ThreeVector(-r, r, 0)));\n  G4VSolid* acyl3 = new G4SubtractionSolid(\"ucyl\", edge, cyl, G4Transform3D(G4RotationMatrix(), G4ThreeVector(r, r, 0)));\n  G4VSolid* aorb  = new G4SubtractionSolid(\"uorb\", vert, orb, G4Transform3D(G4RotationMatrix(), G4ThreeVector(-r, -r, -r)));\n\n  G4Transform3D t1(G4RotationMatrix(), G4ThreeVector(ca, ca, 0));\n  G4Transform3D t2(G4RotationMatrix(0, M_PI / 2, 0), G4ThreeVector(ca, 0, ca));\n  G4Transform3D t3(G4RotationMatrix(0, M_PI / 2, M_PI / 2), G4ThreeVector(0, ca, ca));\n  G4Transform3D t4(G4RotationMatrix(), G4ThreeVector(ca, ca, ca));\n\n  G4VSolid* s1 = new G4SubtractionSolid(\"s1\", cube, acyl1, t1);\n  G4VSolid* s2 = new G4SubtractionSolid(\"s2\", s1, acyl2, t2);\n  G4VSolid* s3 = new G4SubtractionSolid(\"s3\", s2, acyl3, t3);\n  G4VSolid* s4 = new G4SubtractionSolid(\"s4\", s3, aorb, t4);\n\n  G4Transform3D t5(G4RotationMatrix(0, 0, 0), G4ThreeVector(ca, ca, ca));\n  G4Transform3D t6(G4RotationMatrix(0, M_PI / 2, 0), G4ThreeVector(ca, ca, -ca));\n  G4Transform3D t7(G4RotationMatrix(0, -M_PI / 2, 0), G4ThreeVector(ca, -ca, ca));\n  G4Transform3D t8(G4RotationMatrix(0, M_PI / 2, M_PI / 2), G4ThreeVector(ca, -ca, -ca));\n\n  G4VSolid* u1 = new G4UnionSolid(\"u1\", frame, s4, t5);\n  G4VSolid* u2 = new G4UnionSolid(\"u2\", u1, s4, t6);\n  G4VSolid* u3 = new G4UnionSolid(\"u3\", u2, s4, t7);\n  G4VSolid* u4 = new G4UnionSolid(\"u4\", u3, s4, t8);\n\n  solid = new G4UnionSolid(\"u5\", u4, u4, G4Transform3D(G4RotationMatrix(0, 0, M_PI), G4ThreeVector()));\n}\n\n// Define the callable functions for the custom solid\nextern \"C\" {\n  G4VSolid* createRoundCube(double a, double r) {\n    return new RoundCube(a, r);\n  }\n  void deleteRoundCube(G4VSolid* solid) {\n    delete solid;\n  }\n  const char* infoRoundCube(G4VSolid* solid) {\n    static std::string str;\n    std::ostringstream os;\n    solid->StreamInfo(os);\n    str = os.str();\n    return str.c_str();\n  }\n}\n","category":"section"}]
}
