var documenterSearchIndex = {"docs":
[{"location":"examples/G4example/#G4example.cpp","page":"G4example.cpp","title":"G4example.cpp","text":"","category":"section"},{"location":"examples/G4example/","page":"G4example.cpp","title":"G4example.cpp","text":"#include \"G4VUserDetectorConstruction.hh\"\n#include \"G4VUserPrimaryGeneratorAction.hh\"\n#include \"G4UserEventAction.hh\"\n#include \"G4UserRunAction.hh\"\n#include \"G4ParticleGun.hh\"\n#include \"G4RunManager.hh\"\n#include \"G4UImanager.hh\"\n#include \"G4RunManagerFactory.hh\"\n#include \"QBBC.hh\"\n#include \"G4NistManager.hh\"\n#include \"G4Box.hh\"\n#include \"G4LogicalVolume.hh\"\n#include \"G4PVPlacement.hh\"\n//#include \"G4SystemOfUnits.hh\"\n#include \"globals.hh\"\n#include \"G4VUserActionInitialization.hh\"\n#include <julia.h>\n#include <iostream>\n\n//---Detector construction class-------------------------------------------------------------------\nclass DetectorConstruction : public G4VUserDetectorConstruction\n{\n  public:\n    DetectorConstruction() = default;\n    ~DetectorConstruction() override = default;\n    G4VPhysicalVolume* Construct() override {\n        auto nist = G4NistManager::Instance();\n        auto world_mat = nist->FindOrBuildMaterial(\"G4_AIR\");\n        auto core_mat  = nist->FindOrBuildMaterial(\"G4_WATER\");\n        auto world_size = 1.0*CLHEP::m;\n        auto solidWorld = new G4Box(\"World\", world_size, world_size, world_size);\n        auto logicWorld = new G4LogicalVolume(solidWorld, world_mat, \"World\");\n        auto physWorld = new G4PVPlacement(0, G4ThreeVector(), logicWorld, \"World\", 0, false, 0);\n        auto core_size = 0.5*CLHEP::m;\n        auto solidCore = new G4Box(\"Core\", core_size, core_size, core_size);\n        auto logicCore = new G4LogicalVolume(solidCore, core_mat, \"Core\");\n        new G4PVPlacement(0, G4ThreeVector(), logicCore, \"Core\", logicWorld, false, 0);\n        return physWorld;\n    }\n};\n\n//---Primary generator action class----------------------------------------------------------------\nclass PrimaryGeneratorAction : public G4VUserPrimaryGeneratorAction\n{\npublic:\n    PrimaryGeneratorAction() { fParticleGun  = new G4ParticleGun(); }    \n    ~PrimaryGeneratorAction() { delete fParticleGun; }\n    void GeneratePrimaries(G4Event* anEvent) override {\n        fPrimaryParticleName = fParticleGun->GetParticleDefinition()->GetParticleName();\n        fParticleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));\n        fParticleGun->SetParticlePosition(G4ThreeVector(0.,0.,-1.*CLHEP::m));\n        fParticleGun->GeneratePrimaryVertex(anEvent);\n    }\n    G4ParticleGun* GetParticleGun() {return fParticleGun;};\n    const G4String& GetParticleName() { return fPrimaryParticleName;}\nprivate:\n    G4String fPrimaryParticleName;\n    G4ParticleGun* fParticleGun;\n};\n\ntypedef  void (*stepaction_f)(const G4Step*);\nclass SteppingAction : public G4UserSteppingAction\n{\npublic:\n    SteppingAction() {\n      action_jl = (stepaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(stepping_action, Nothing, (CxxPtr{G4Step},))\")));\n      std::cout << \"=====> \" << action_jl << std::endl;\n    } \n    ~SteppingAction() {}\n    void UserSteppingAction(const G4Step* step) override { action_jl(step); }\nprivate:\n    stepaction_f action_jl;\n};\n\ntypedef  void (*eventaction_f)(const G4Event*);\nclass EventAction : public G4UserEventAction\n{\n  public:\n    EventAction() {\n      beginevent_jl = (eventaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(begin_of_event_action, Nothing, (CxxPtr{G4Event},))\")));\n      endevent_jl = (eventaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(end_of_event_action, Nothing, (CxxPtr{G4Event},))\")));\n    }\n    ~EventAction() override = default;\n\n    void BeginOfEventAction(const G4Event* event) override { beginevent_jl(event); }\n    void EndOfEventAction(const G4Event* event) override { endevent_jl(event); }\n  private:\n    eventaction_f beginevent_jl;\n    eventaction_f endevent_jl;\n};\n\ntypedef  void (*runaction_f)(const G4Run*);\nclass RunAction : public G4UserRunAction\n{\n  public:\n    RunAction() {\n      beginrun_jl = (runaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(begin_of_run_action, Nothing, (CxxPtr{G4Run},))\")));\n      endrun_jl = (runaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(end_of_run_action, Nothing, (CxxPtr{G4Run},))\")));\n    }\n    ~RunAction() override = default;\n\n    void BeginOfRunAction(const G4Run* run) override { beginrun_jl(run); }\n    void EndOfRunAction(const G4Run* run) override { endrun_jl(run); }\n\n  private:\n    runaction_f beginrun_jl;\n    runaction_f endrun_jl;\n};\n\n//---Action initialization class-------------------------------------------------------------------\nclass ActionInitialization : public G4VUserActionInitialization\n{\n  public:\n    ActionInitialization() = default;\n    ~ActionInitialization() override = default;\n    void BuildForMaster() const override {}\n    void Build() const override {\n        SetUserAction(new PrimaryGeneratorAction);\n        SetUserAction(new RunAction);\n        SetUserAction(new EventAction);\n        SetUserAction(new SteppingAction);\n    }\n};\n\nJULIA_DEFINE_FAST_TLS // only define this once, in an executable (not in a shared library) if you want fast code.\n\n//----Main program---------------------------------------------------------------------------------\nint main(int, char**)\n{\n    //--- Required to setup the Julia context\n    jl_init();\n        /* run Julia commands */\n    jl_eval_string(\"include(\\\"MyCode.jl\\\")\");\n    if (jl_exception_occurred()) {\n        std::cout << \"=====> \" << jl_typeof_str(jl_exception_occurred()) << std::endl;\n    }\n\n    //---Construct the default run manager\n    auto runManager = G4RunManagerFactory::CreateRunManager(G4RunManagerType::Serial);\n\n    //---Set mandatory initialization classes\n    // Detector construction\n    runManager->SetUserInitialization(new DetectorConstruction());\n\n    // Physics list\n    runManager->SetUserInitialization(new QBBC(0));\n\n    // User action initialization\n    runManager->SetUserInitialization(new ActionInitialization());\n\n    // Initialize G4 kernel\n    runManager->Initialize();\n    \n    // Get the pointer to the User Interface manager\n    auto UImanager = G4UImanager::GetUIpointer();\n    UImanager->ApplyCommand(\"/control/verbose 1\");\n    UImanager->ApplyCommand(\"/run/verbose 1\");\n    //UImanager->ApplyCommand(\"/event/verbose 0\");\n    //UImanager->ApplyCommand(\"/tracking/verbose 1\");\n    UImanager->ApplyCommand(\"/gun/particle e+\");\n    UImanager->ApplyCommand(\"/gun/energy 100 MeV\");\n    UImanager->ApplyCommand(\"/run/beamOn 100000\");\n\n    // Job termination\n    delete runManager;\n\n    // strongly recommended: notify Julia that the program is about to terminate. \n    // this allows Julia time to cleanup pending write requests and run all finalizers\n    jl_atexit_hook(0);\n}","category":"page"},{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Documentation for Geant4.jl public interface.","category":"page"},{"location":"api/#Index-Types","page":"Public API","title":"Index - Types","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Pages   = [\"api.md\"]\nModules = [Geant4]\nOrder   = [:type]","category":"page"},{"location":"api/#Index-Functions","page":"Public API","title":"Index - Functions","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Pages   = [\"api.md\"]\nModules = [Geant4]\nOrder   = [:function]","category":"page"},{"location":"api/#Types","page":"Public API","title":"Types","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [Geant4]\nOrder = [:type]","category":"page"},{"location":"api/#Geant4.G4JLApplication-Tuple{}","page":"Public API","title":"Geant4.G4JLApplication","text":"G4JLApplication(<keyword arguments>)\n\nInitialize a G4JLApplication with its associated tyopes and methods.\n\nArguments\n\ndetector::G4JLDetector: detector description object\nsimdata=G4JLNoData(): simulation data object\ngenerator=G4JLParticleGun(): primary particle generator\nfield=nothing: magnetic field\nevtdisplay=nothing: event display (visualization)\nnthreads=0: number of Geant4 worker threads ( >0 implies MT)\nverbose=0 : default verbority level (physics, ...)\nrunmanager_type=G4RunManager: run manager type\nbuilder_type=G4JLDetectorConstruction: detector builder type (the default should be fine most cases)\nphysics_type=FTFP_BERT: physics list type\nstepaction_type=G4JLSteppingAction: stepping action type (the default should be fine most cases)\ntrackaction_type=G4JLTrackingAction: rtacking action type (the default should be fine most cases)\nrunaction_type=G4JLRunAction: run action type (the default should be fine most cases)\neventaction_type=G4JLEventAction: event action type (the default should be fine most cases)\nstepaction_method=nothing: stepping action method with signature (::G4Step, ::G4JLApplication)::Nothing\npretrackaction_method=nothing: pre-tracking action method with signature (::G4Track, ::G4JLApplication)::Nothing\nposttrackaction_method=nothing: post-tracking action method with signature (::G4Track, ::G4JLApplication)::Nothing\nbeginrunaction_method=nothing: begin run action method with signature (::G4Run, ::G4JLApplication)::Nothing\nendrunaction_method=nothing: end run action method with signature (::G4Run, ::G4JLApplication)::Nothing\nbegineventaction_method=nothing: begin event action method with signature (::G4Event, ::G4JLApplication)::Nothing\nendeventaction_method=nothing: end event action method with signature (::G4Event, ::G4JLApplication)::Nothing\nstackaction_method=nothing: stacking classification of new track with signature (::G4Track, ::G4JLApplication)::G4ClassificationOfNewTrack\nstatechange_method=nothing: state change notifycation method with  signature (from::G4ApplicationState, to::G4ApplicationState, ::G4JLApplication)::Bool\nsdetectors::Vector{}=[]: vector of pairs lv::String => sd::G4JLSensitiveDetector to associate logical volumes to sensitive detector\nscorers::Vector{}=[]: vector of G4JLScoringMeshs\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLDetectorGDML-Tuple{String}","page":"Public API","title":"Geant4.G4JLDetectorGDML","text":"G4JLDetectorGDML(gdmlfile::String; check_overlap::Bool, validate_schema::Bool, init_method::Union{Function,Nothing})\n\nInitialize a G4JLDetector from a GDML file. The GDML file is parsed at this moment.\n\nArguments\n\ngdmlfile::String: GDML file name\ncheck_overlap::Bool=false: check for overlaps\nvalidate_schema::Bool=true: validate the schema\ninit_method::Union{Function,Nothing}=nothing: initialization method to be called when the detector is constructed\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLMagneticField","page":"Public API","title":"Geant4.G4JLMagneticField","text":"Custom Magnetic Field\n\n\n\n\n\n","category":"type"},{"location":"api/#Geant4.G4JLMagneticField-Union{Tuple{CLHEP!Hep3Vector}, Tuple{G4JLUniformMagFieldData}} where G4JLUniformMagFieldData","page":"Public API","title":"Geant4.G4JLMagneticField","text":"G4JLUniformMagField(field::G4ThreeVector)\n\nCreate a Uniform magnetic field\n\nArguments\n\nfield::G4ThreeVector: magnetic field vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLMagneticField-Union{Tuple{T}, Tuple{String, T}} where T<:G4JLFieldData","page":"Public API","title":"Geant4.G4JLMagneticField","text":"G4JLMagneticField(name::String, data::DATA; <keyword arguments>) where DATA<:G4JLGeneratorData\n\nCreate a G4JLMagneticField with its name and associated DATA structure\n\nArguments\n\nname::String: magnetic field name\ndata::DATA: data structure associated to the magnetic field\ngetfield_method=nothing: user provided getfield function with signature: (result::G4ThreeVector, position::G4ThreeVector, ::DATA)\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLPrimaryGenerator-Union{Tuple{T}, Tuple{String, T}} where T<:G4JLGeneratorData","page":"Public API","title":"Geant4.G4JLPrimaryGenerator","text":"G4JLPrimaryGenerator(name::String, data::DATA; <keyword arguments>) where DATA<:G4JLGeneratorData\n\nCreatre a G4JLPrimaryGenerator with its name and associated DATA structure\n\nArguments\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLScoringMesh-Union{Tuple{M}, Tuple{String, M}} where M<:Geant4.AbstractMesh","page":"Public API","title":"Geant4.G4JLScoringMesh","text":"G4JLScoringMesh(name, mesh; <keyword arguments>)\n\nCreate a scoring mesh to be added to the Geant4 application.\n\nArguments\n\nname::String: scoring mech name\nmesh::AbstractMesh: mesh instance. Either a BoxMesh or CylinderMesh\nbins::Tuple: tuple with number on bins in x, y, z (default 30, 30, 30)\ntranslation::Tuple: position (x,y,z) with respect the mesh respect to the world volume. Default is  (0,0,0).\nrotation::Tuple: rotation of the mesh with respect the world volume. Default (0,0,0)\nquantities::Vector: vector of quanties to be scored (e.g. energyDeposit, doseDeposit, nOfStep)\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.G4JLSensitiveDetector-Union{Tuple{T}, Tuple{String, T}} where T<:G4JLSDData","page":"Public API","title":"Geant4.G4JLSensitiveDetector","text":"G4JLSensitiveDetector(name::String, data::DATA; <keyword arguments>) where DATA<:G4JLSDData\n\nInitialize a G4JLSensitiveDetector with its name and associated DATA structure.\n\nArguments\n\nname::String: Sensitive detector name\ndata::DATA: Data structure associted to the sensitive detector\nprocesshits_method=nothing: processHit function with signature: (data::DATA, step::G4Step, ::G4TouchableHistory)::Bool\ninitialize_method=nothing: intialize function with signature: (data::DATA, ::G4HCofThisEvent)::Nothing\nendofevent_method=nothing: endOfEvent function with signature: (data::DATA, ::G4HCofThisEvent)::Nothing \n\n\n\n\n\n","category":"method"},{"location":"api/#Functions","page":"Public API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Modules = [Geant4]\nOrder = [:function]","category":"page"},{"location":"api/#Geant4.G4JL_println","page":"Public API","title":"Geant4.G4JL_println","text":"G4JL_println(::AbstractString)\n\nPrint the string to the Geant4 output in a thread safe manner prefixing the string with the thread ID.\n\nArguments\n\ns::AbstractString: string to be printed\n\n\n\n\n\n","category":"function"},{"location":"api/#Geant4.GetVolume-Tuple{String}","page":"Public API","title":"Geant4.GetVolume","text":"GetVolume(name::String)\n\nGet the  the G4LogicalVolume with this name.\n\nArguments\n\nname::String: logical volume name\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.GetWorldVolume-Tuple{}","page":"Public API","title":"Geant4.GetWorldVolume","text":"GetWorldVolume()\n\nGet the world volume of the currently instantiated detector geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.beamOn-Tuple{G4JLApplication, Int64}","page":"Public API","title":"Geant4.beamOn","text":"beamOn(app::G4JLApplication, nevents::Int)\n\nStart a new run with nevents events. In case of multi-threading, the function enters a GC safe state before starting the run.\n\nArguments\n\napp::G4JLApplication: Geant4 application\nnevents::Int: number of events\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.configure-Tuple{G4JLApplication}","page":"Public API","title":"Geant4.configure","text":"configure(app::G4JLApplication)\n\nConfigure the Geant4 application. It sets the declared user actions, event generator, and physcis list.\n\nArguments\n\napp::G4JLApplication: Geant4 application\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.getSDdata-Tuple{Any, Any}","page":"Public API","title":"Geant4.getSDdata","text":"getSDdata(app::G4JLApplication, name::String)\n\nGet the data associated to the Sentitive Detector with a given name taking into account the current worker thread ID\n\nArguments\n\napp::G4JLApplication: Geant4 application\nname::String: sensitive detector name\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.getSIMdata-Tuple{Any}","page":"Public API","title":"Geant4.getSIMdata","text":"getSIMdata(app::G4JLApplication)\n\nGet the Simulation Data taking into account the current worker thread ID\n\nArguments\n\napp::G4JLApplication: Geant4 application\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.getfield-Tuple{CLHEP!Hep3Vector, G4JLMagneticField}","page":"Public API","title":"Geant4.getfield","text":"getfield(pos::G4ThreeVector, bfield::G4JLMagneticField)\n\nFunction to exercise a custom magnetic field\n\nArguments\n\npos::G4ThreeVector: position\nbfield::G4JLMagneticField: magnetic field object\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.initialize-Tuple{G4JLApplication}","page":"Public API","title":"Geant4.initialize","text":"initialize(app::G4JLApplication)\n\nInitialize the Geant4 application. It initializes the G4RunManager, which constructs the detector geometry, and sets  the declared sensitive detectors. In case of multi-threading, the function enters a GC safe state before initializing the application, which will be calling thebuild()` functions by the worker threads.\n\nArguments\n\napp::G4JLApplication: Geant4 application\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.move!-Tuple{Any}","page":"Public API","title":"Geant4.move!","text":"move!(o)\n\nMove ownerhip of C++ object to receiver. The object cannot not be used anymore after this call.\n\n\n\n\n\n","category":"method"},{"location":"api/#Geant4.reinitialize-Tuple{G4JLApplication, G4JLDetector}","page":"Public API","title":"Geant4.reinitialize","text":"reinitialize(app::G4JLApplication, det::G4JLDetector)\n\nRe-initialize the Geant4 application with a new detector defintion.\n\nArguments\n\napp::G4JLApplication: Geant4 application\ndet::G4JLDetector: new detector definition\n\n\n\n\n\n","category":"method"},{"location":"examples/MyCode/#MyCode.jl","page":"MyCode.jl","title":"MyCode.jl","text":"","category":"section"},{"location":"examples/MyCode/","page":"MyCode.jl","title":"MyCode.jl","text":"#---Load the needed Julia modules------------------------------------------------------------------\n\nusing Geant4\nusing GeometryBasics\nusing FHist\nusing Plots\n\nprintln(\"=====> Loading MyCode.jl\")\n\nedepHist = H1D(\"Event total Edep distribution\", 100, 0., 110.)\nedep = 0.0\n\nfunction end_of_event_action(event)\n    push!(edepHist, edep)\n    return                      # This is mandatory to force to return nothing\nend\n\nfunction begin_of_event_action(event)\n    global edep = 0.0\n    return                      # This is mandatory to force to return nothing\nend\n\nfunction stepping_action(step)\n    global edep += GetTotalEnergyDeposit(step)\n    return                      # This is mandatory to force to return nothing\nend\n\nfunction begin_of_run_action(run)\n    return                      # This is mandatory to force to return nothing\nend\n\nfunction end_of_run_action(run)    \n    println(\"=====> End of run\")\n    h = edepHist\n    img = plot(h.hist, title=h.title)\n    savefig(img, \"edepHist.png\")\n    println(\"=====> edepHist.png saved\")\n    return                      # This is mandatory to force to return nothing\nend  ","category":"page"},{"location":"releases/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"releases/#0.2.x","page":"Release Notes","title":"0.2.x","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New Examples:\nUserLib: how to build and call a user custom library providing additional Geant4 functionally that is not provided by the set of wrapped classes\nJuliaAction: emmbeding Julia in a C++ application. In this example we call user actions implemented in Julia","category":"page"},{"location":"releases/#0.2.0","page":"Release Notes","title":"0.2.0","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New Features\nAdapted to CxxWrap 0.16\nChanged gen/build.jl to generate the code first and then call cmake (not yet using WrapIt.jl package)\nAdded new example advanced/AlephTPC to integrate Geant4 with PYTHIA8\nChanged the documentation to generate examples as markdown, as notebook and as julia script using the package Literate.jl ","category":"page"},{"location":"releases/#0.1.17","page":"Release Notes","title":"0.1.17","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New Features\nAdded wrapper for G4StepLimiterPhysics","category":"page"},{"location":"releases/#0.1.15","page":"Release Notes","title":"0.1.15","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"Fixes:\nReturned threadid is -2 for non-multithreaded builds of Geant4","category":"page"},{"location":"releases/#0.1.14","page":"Release Notes","title":"0.1.14","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New Features:\nAdded function getfield(pos::G4ThreeVector, bfield::G4JLMagneticField)\nAdded G4JLEmptyDetector as default detector (for testing and tutorials)\nbuild some protection to re-use physics lists in case re-creating an G4JLApplication ","category":"page"},{"location":"releases/#0.1.13","page":"Release Notes","title":"0.1.13","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New Features:\nAdded wrappers for PhysicsLists classes: G4DecayPhysics, G4EmStandardPhysics, G4RadioactiveDecayPhysics\nImplemented user stacking action\nAdded examples basic/B3a","category":"page"},{"location":"releases/#0.1.12","page":"Release Notes","title":"0.1.12","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"Moved the examples to new repository https://github.com/JuliaHEP/G4Examples.jl\nFixes:\nVeto CLHEP::HepRandomEngine::get to avoid clash with Base.get\nDisable finalizer for class G4JLStateDependent. Fixes event display.","category":"page"},{"location":"releases/#0.1.11","page":"Release Notes","title":"0.1.11","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"Migrated to Julia 1.10\nUsing the latest version of WrapIt to generate the CxxWrap wrappers\nNew features\nAdded G4JLGeneralParticleSource, which makes use of the Geant4 G4GeneralParticleSource class for generation of primary particles for simulations. See documentation.\nAdded a new extension module G4Hist that defines convenient histogram types (H1D and H2D) on top of FHist.jl. See documentation. ","category":"page"},{"location":"releases/#0.1.10","page":"Release Notes","title":"0.1.10","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New features\nProvide an EventDisplay as a building block of the application. New evtdisplay argument in the constructor. \nAdded new wrapped classes to support event displays: G4EventManager, G4TrajectoryContainer, G4VTrajectory, G4VTrajectoryPoint, G4StateManager, G4VStateDependent G4ApplicationState","category":"page"},{"location":"releases/#0.1.9","page":"Release Notes","title":"0.1.9","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"Changes needed for running ATLTileCalTB example ","category":"page"},{"location":"releases/#0.1.8","page":"Release Notes","title":"0.1.8","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New features:\nAdded all example scripts as tests, so that the CI will systematically execute them.\nAdded new wrapped classes: G4LogicalVolumeStore, G4MaterialPropertiesTable, G4OpticalParameters, G4OpticalSurface, G4LogicalBorderSurface, G4LogicalSkinSurface, G4VProcess, G4ProcessType, G4Random, G4EmStandardPhysics_option4, G4OpticalPhysics, G4OpBoundaryProcess, G4ProcessManager, G4ProcessVector\nAdded Geant4.PhysicalConstants sub-module\nAdded testRandom to the test suite\nAdded Scintillation example with scintillating crystals and optical photons\nFixes:\nFixed broken [visualization] examples\nImprove HBC30 example to visualize trajectories in a more smooth manner. Moved it under ext/G4Vis/examples","category":"page"},{"location":"releases/#0.1.7","page":"Release Notes","title":"0.1.7","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New features:\nSupport for ARM64 (MacOS M1). Implemented workaround for closures in @safe_cfunction, which were for supported in this  platform. \nAdded support for magnetic field. Additional keyword argument in the G4JLApplication. Added example HBC30 for a simulation of a liquid hydrogen bubble chamber.\nAdded drawing capabilities for G4Polyhedra, G4EllipticalTube, G4Ellipsoid\nFixes:\nFix example WaterPhantom to added to new callback closures","category":"page"},{"location":"releases/#0.1.6","page":"Release Notes","title":"0.1.6","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New features:\nRestructured G4Vis as an extension of Geant4.jl. It is automatically loaded when all the required weak dependencies are satisfied (e.g. \"Makie\", \"Colors\", \"StaticArrays\", \"Rotations\", \"LinearAlgebra\")\nAdded missing basic solids including the BooleanSolid\nUsing the IGLWrap_jll binary wrapper to libigl C++ library to draw boolean solids.\nAdded notebook ext/G4Vis/Solids.ipynb to exercise and draw all possible solids (some are still missing)","category":"page"},{"location":"releases/#0.1.5","page":"Release Notes","title":"0.1.5","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"New features:\nSupport for Multi-threading. New parameter in G4JLApplication to set the number of threads. Default is serial, nthreads = 0\nAdded verbosity level with the argument verbose in G4JLApplication\nFixes:\nFix continuous pre-compilation after moving to Julia 1.9\nFix for embedded figures in notebooks","category":"page"},{"location":"releases/#0.1.4","page":"Release Notes","title":"0.1.4","text":"","category":"section"},{"location":"releases/","page":"Release Notes","title":"Release Notes","text":"Added support for scoring with G4JLScoringMesh function\nAdded generation of documentation including running the jupyter notebooks","category":"page"},{"location":"#Geant4.jl","page":"Introduction","title":"Geant4.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia bindings for the Geant4 particle transportation toolkit. It is using CxxWrap.jl package to wrap C++ types and functions to Julia. Since the Geant4 toolkit is rather large and complex, writing the wrapper code by hand is not really an option. For this we use the package WrapIt that automates the generation of the wrapper code making use of the clang library.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation of the concepts and how to write applications with the Geant4 toolkit can be found with the Application Developer Guide or the Classes and Members reference guide for a detailed description of each C++ class. In this document we will only highlight the differences between the Julia and the C++ API. We will document the additional types that have been added on top of the C++ classes to make the user interface more Julia friendly. To distinguish these new types from the types coming directly from C++ via the CxxWrap wrappers, these types are prefixed with G4JL.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Geant4.jl package does no require any special installation. Stable releases are registered into the Julia general registry, and therefore can be deployed with the standard Pkg Julia package manager.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(\"Geant4\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Examples are located in a separate repository G4Examples to minimize dependencies since they use additional functionality such as graphics, plotting, analysis tools, etc. To use and play with the examples, the user can clone the examples repository and setup a complete Julia environment with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"$ git clone https://github.com/JuliaHEP/G4Examples.jl.git\n$ julia --project=G4Examples.jl -e 'import Pkg; Pkg.instantiate()'","category":"page"},{"location":"#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Import the Geant4 module. All the wrapped Geant4 classes are exported since they are prefixed by G4 minimizing the chances of a name clash with other Julia symbols. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"\njulia> using Geant4\njulia> runManager = G4RunManager()\n**************************************************************\n Geant4 version Name: geant4-11-01-patch-01 [MT]   (10-February-2023)\n                       Copyright : Geant4 Collaboration\n                      References : NIM A 506 (2003), 250-303\n                                 : IEEE-TNS 53 (2006), 270-278\n                                 : NIM A 835 (2016), 186-225\n                             WWW : http://geant4.org/\n**************************************************************\n\nGeant4.G4RunManagerAllocated(Ptr{Nothing} @0x00007f9fcb6f9c50)\n\njulia> methodswith(G4RunManager, supertypes=true)\n[1] convert(t::Type{G4RunManager}, x::T) where T<:G4RunManager in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:676\n[2] AbortEvent(arg1::Union{CxxWrap.CxxWrapCore.CxxRef{<:G4RunManager}, Union{CxxWrap.CxxWrapCore.SmartPointer{T2}, T2} where T2<:G4RunManager}) in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:618\n...\n[94] rndmSaveThisRun(arg1::Union{CxxWrap.CxxWrapCore.CxxRef{<:G4RunManager}, Union{CxxWrap.CxxWrapCore.SmartPointer{T2}, T2} where T2<:G4RunManager}) in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:618\n\njulia> v = GetVersionString(runManager)\nConstCxxRef{G4String}(Ptr{G4String} @0x00007ffed34df2d8)\n\njulia> String(v)\n\" Geant4 version Name: geant4-11-01-patch-01 [MT]   (10-February-2023)\"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that class methods are called with the object instance as first argument. In C++ the GetVersionString method would be called as runManager->GetVersionString() while in Julia it is called as GetVersionString(runManager). Thanks to the Julia multi-dispatch we do not need to prefix the methods with the module name Geant4.GetVersionString(runManager), even for very common function names such as mag.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> v = G4ThreeVector(1,2,3)\nGeant4.CLHEP!Hep3VectorAllocated(Ptr{Nothing} @0x00007f9fcaf2a710)\n\njulia> mag(v)\n3.7416573867739413","category":"page"},{"location":"#Geant4-Julia-interface","page":"Introduction","title":"Geant4 Julia interface","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main goal for defining a Geant4 application in the Julia interface is to create an instance of the G4JLApplication type, where all the needed elements for running a Geant4 application are declared, such as the detector geometry, the physics list, the primary particle generator, the type of run manager, the user actions, etc. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Figure)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These are the needed elements:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"detector. An instance of a detector structure inheriting from the abstract type G4JLDetector, in which all the detector parameters are defined. The user should also provide a method specialization of Geant4.getConstructor(::G4JLDetector)::Function to return the Julia function that toolkit needs to call in order to construct the geometry and return the pointer of the 'world' physical volume. There is no default.\nfield. An instance of the magnetic field class. The G4JLUniformMagField(...) function provides a uniform magnetic field. See later how to define a custom one.\nsimdata. An instance of the simulation data structure that the program will need to collect during the simulation execution. This mutable structure needs to inherit from the abstract type G4JLSimulationData and is completely user defined with counters, data structures to collect the hits or doses, histograms, etc. The default is an instance of type G4JLNoData.\nnthreads. Number of worker threads to be used. The default is 0, which means serial mode. Any number > 0 will use the MT functionality of Geant4, and therefore the user would need to pay attention to the user actions that are run concurrently to avoid data races (see Julia doc on multi-threading)\nverbose. Verbosity level (for physics list). The default is 0.\nphysics_type. The physics list predefined type. Default is FTFP_BERT.\ngenerator_type. The primary generator generator type. The default is G4JLParticleGun, which encapsulates a G4ParticleGun. The underlying G4ParticleGun can be obtained by calling GetGun().\nuser actions. Julia methods defining the different possible user actions (e.g. stepping action, tracking action, run action, event action). The default is no action.\nsdetectors. List of sensitive detectors. This is given as a Vector of pairs lv::String => sd::G4JLSensitiveDetector to associate logical volumes by name to sensitive detector instances (see next section).\nscorers. List of scoring meshes defined with the function G4JLScoringMesh.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once the G4JLApplication is instantiated (and implicitly an instance of the G4RunManager created), the user can control the application with the following commands:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"configure(::G4JLApplication). It associates the physics list, generator and user actions to the selected G4RunManager instance. \ninitialize(::G4JLApplication). It basically calls the Initialize() method of the run manager and associate the declared sensitive detectors.\nreinitialize(::G4JLApplication, ::G4JLDetector). It re-defines the declared detector geometry with a new instance of G4JLDetector. \nbeamOn(::G4JLApplication, ::Int). Starts a run with a given number of events.","category":"page"},{"location":"#Constructing-the-detector","page":"Introduction","title":"Constructing the detector","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Parameters of the detector are collected in a user defined mutable data structure inheriting from G4JLDetector. The user also needs to provide a Julia method for constructing the geometry. This method needs to have following the signature","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<User_Det_Constructor_Function>(::G4JLDetector)::CxxPtr{G4VPhysicalVolume}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The only argument of the function gives access to the user defined structure with all the detector parameters.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThe type CxxPtr{G4VPhysicalVolume} denotes a C++ pointer to the G4VPhysicalVolume type.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The user can use the native G4 classes for constructing the geometry such as the different type of solids (e.g. G4Box, G4Tubs, etc.), G4LogicalVolume, G4PVPlacement, G4PVReplica, etc. Alternatively, the user can use the type G4JLDetectorGDML to construct a detector from a GDML file.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nNote that by default constructed C++ objects from Julia would get automatically deleted by the Julia garbage collector (GC) since a finalizer gets installed to the wrapper classes. This is particularly a problem when constructing the geometry.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently for the following classes have the finalizer disabled in the wrapper: G4PVPlacement, G4LogicalVolume, G4PVReplica, G4Material, G4Isotope, G4Element. This means that instances of them will not be deleted by Julia to avoid double deletion (often a crash) when the geometry gets deleted at the finalization of the application from the C++ side. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A pointer to any of the G4Solid needs to be passed to the G4LogicalVolume using move!(objref) function to transfer the ownership of the referenced object to the C++ side. See the following example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"trackerS = G4Tubs(\"tracker\", 0, trackerSize, trackerSize, 0, 360deg)\ntrackerLV = G4LogicalVolume(move!(trackerS), m_air, \"Tracker\")\nG4PVPlacement(nothing,              # no rotation\n    G4ThreeVector(0,0,0),           # at (0,0,0)\n    trackerLV,                      # its logical volume\n    \"Tracker\",                      # its name\n    worldLV,                        # its mother  volume\n    false,                          # no boolean operations\n    0,                              # copy number\n    checkOverlaps)                  # checking overlaps","category":"page"},{"location":"#Physics-List","page":"Introduction","title":"Physics List","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The user can provide one of the pre-defined physics lists, such as QGS_BIC, QBBC or FTFP_BERT. Alternatively, the user can define a Julia structas a subtype ofG4VUserPhysicsList` and modify some of the physcis in the constructor. For example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"struct ScintPhysicsList <: G4VUserPhysicsList\n    function ScintPhysicsList(verbose)\n        pl = FTFP_BERT(verbose)\n        # replace G4EmStandardPhysics\n        ReplacePhysics(pl, move!(G4EmStandardPhysics_option4(verbose)))\n        # register G4OpticalPhysics\n        RegisterPhysics(pl, move!(G4OpticalPhysics(verbose)))\n        # activate  scintillation\n        optpar = G4OpticalParameters!Instance()\n        SetProcessActivation(optpar, \"Scintillation\", true)\n        # activate cherenkov radiation\n        SetProcessActivation(optpar, \"Cerenkov\", true)\n        return pl\n    end \nend","category":"page"},{"location":"#Magnetic-field","page":"Introduction","title":"Magnetic field","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The user can define either an uniform magnetic field or a custom one. To define an custom one:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"define first a user structure for the parameters that inherits from the abstract type G4JLFieldData\nthen, define a function with the signature (result::G4ThreeVector, position::G4ThreeVector, params::G4JLFieldData)::Nothing\nand finally, with all this, instantiate the magnetic field calling the function \n  G4JLMagneticField(<name>, <data>; getfield_method=<function>)","category":"page"},{"location":"#Primary-Particle-Generator","page":"Introduction","title":"Primary Particle Generator","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The user can define either a custom primary particle generator or use one of the two defined ones:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"G4JLGunGenerator. Uses the G4ParticleGun class of Geant4 that generates a single particle type with a fix kinetic energy, position and direction.\nG4JLGunGenerator(particle = \"proton\", \n                 energy = 3GeV, \n                 direction = G4ThreeVector(0,0,1), \n                 position = G4ThreeVector(0,0,-2940.0))\nG4JLGeneralParticleSource. Uses the G4GeneralParticleSource class of Geant4 to generate one of more sources of primary particles with predefined distributions for energy, position and direction. An example can be:\nsrc1 = (particle=\"e+\", intensity=0.5,\n        ene=(type=\"Exp\", min=2MeV, max=10MeV, ezero=2.),\n        pos=(type=\"Plane\", shape=\"Circle\", centre=G4ThreeVector(1cm,2cm,0cm), radius=3cm),\n        ang=(type=\"cos\", mintheta=0deg, maxtheta=180deg))\nsrc2 = (particle=\"gamma\", intensity=0.5,\n        ene=(type=\"Brem\", min=2MeV, max=10MeV, temp=2e12),\n        pos=(type=\"Plane\", shape=\"Ellipse\", centre=G4ThreeVector(3cm,1cm,0cm), halfx=1cm, halfy=2cm),\n        ang=(type=\"iso\", mintheta=0deg, maxtheta=180deg))\ngps = G4JLGeneralParticleSource(sources = [ src1, src2 ])\nthe standard particle gun parameters works as well:\nG4JLGeneralParticleSource(particle = \"proton\", \n                          energy = 3GeV, \n                          direction = G4ThreeVector(0,0,1), \n                          position = G4ThreeVector(0,0,0))\nCustom Generator. It is fairly simple to write a custom generator. It is needed to define a structure for the parameters to configure the generator, and a two functions to initialize and generate the primary particles called for each event. Here is an example:\n# define the data structure with the generator parameters\nmutable struct PlaneSourceData <: G4JLGeneratorData\n  particleName::String\n  particlePtr::CxxPtr{G4ParticleDefinition}\n  energy::Float64 \n  halfx::Float64\n  halfy::Float64\n  position::G4ThreeVector\n  direction::G4ThreeVector\nend\n\n# define the constructor with the default parameters\nfunction PlaneSource(;particle=\"gamma\", energy=0.07MeV, halfx=7cm, halfy=7cm, \n                                      position=G4ThreeVector(0,0,-14.9cm), direction=G4ThreeVector(0,0,1))\n  data = PlaneSourceData(particle, CxxPtr{G4ParticleDefinition}(C_NULL), energy, halfx, halfy, position, direction)\n  function init(data:: PlaneSourceData, app::G4JLApplication)\n      data.particlePtr = FindParticle(data.particleName)\n  end\n  function generate( evt::G4Event, data:: PlaneSourceData)::Nothing\n      mass = data.particlePtr |> GetPDGMass\n      momentum = âˆš((mass + data.energy)^2 - mass^2)\n      pvec = momentum * data.direction\n      pos = data.position + G4ThreeVector( data.halfx * (rand() - 0.5),  data.halfy * (rand() - 0.5), 0)\n      primary = G4PrimaryParticle(data.particlePtr, pvec |> x, pvec |> y, pvec |> z )\n      vertex = G4PrimaryVertex(pos, 0ns)\n      SetPrimary(vertex, move!(primary))    # note that we give up ownership of the objects just created\n      AddPrimaryVertex(evt, move!(vertex))  # note that we give up ownership of the objects just created\n  end\n  G4JLPrimaryGenerator(\"PlaneSource\", data; init_method=init, generate_method=generate)\nend","category":"page"},{"location":"#User-Actions","page":"Introduction","title":"User Actions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"User actions are native Julia functions that are callbacks of the Geant4 toolkit. They are declared in the constructor of G4JLApplication, so they do not need to be associated to a specific function name. All user actions receive a reference to the G4JLApplication from which the user can obtain details of the actual application, such as the current detector, the physics, the generator, or the running simulation data. There are the available attributes of the application instance:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"    runmanager::G4RunManager    # The C++ G4RunManager instance\n    detector::DET               # User defined detector structure with all parameters\n    simdata::Vector{DAT}        # User defined simulation data structs (each worker has its own)\n    physics::G4VUserPhysicsList # Physics List\n    generator::G4JLPrimaryGenerator # Primary particle generator\n    field::Union{G4Field, G4JLMagneticField} # Magnetic field instance\n    evtdisplay::G4JLDisplay     # Event display instance\n    nthreads::Int32             # number of worker threads\n    verbose::Int32              # verbosity level for physics lists\n    sdetectors::Dict{String,Vector{G4JLSensitiveDetector}} # dictionary of sensitive detectors\n    scorers::Vector{G4JLScoringMesh} # vector of scoring meshes","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following are the currently defined possible user actions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"stepping action. Called on each simulation step. The signature is (::G4Step, ::G4JLApplication)::Nothing. Consult the G4Step reference manual to see what you can get from it. \npre-tracking action. Called at the creation of a new participle being tracked. The signature is (::G4Track, ::G4JLApplication)::Nothing. Consult the G4Step reference manual to see what you can get from it.\npost-tracking action. Called at the end of the particle being tracked. The signature is (::G4Track, ::G4JLApplication)::Nothing. Consult the G4Track reference manual to see what you can get from it.\nbegin-event action. Called at the beginning of each event. The signature is (::G4Event, ::G4JLApplication)::Nothing. Consult the G4Event reference manual to see what you can get from it.\nend-event action. Called at the end of each event. The signature is (::G4Event, ::G4JLApplication)::Nothing. Consult the G4Event reference manual to see what you can get from it.\nbegin-run action. Called at the beginning of a run. The signature is (::G4Run, ::G4JLApplication)::Nothing. Consult the G4Run reference manual to see what you can get from it.\nend-run action. Called at the end of a run. The signature is (::G4Run, ::G4JLApplication)::Nothing. Consult the G4Run reference manual to see what you can get from it.","category":"page"},{"location":"#Sensitive-Detectors","page":"Introduction","title":"Sensitive Detectors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The user can define sensitive detectors by defining a data structure and 3 callback functions, which will initialize, fill and dispose the defined data structure. Later, the instantiated sensitive detector would be associated to one or more logical volumes of the detector setup. Instantiating a G4JLSensitiveDetector will require the following arguments:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"name. A string to identify the sensitive detector. No default.\nsd data. A instance of a user defined G4JLSDData mutable data structure that will passed to each callback invocation.\ninitialize method. User method that is called at the beginning of each event. The signature is (::B2aSDData, ::G4HCofThisEvent)::Nothing.\nendOfEvent method. User method that is called at the end of each event. The signature is (::B2aSDData, ::G4HCofThisEvent)::Nothing.\nprocessHits method. User method that is called at simulation step that ends at the associated logical volume. The signature is (::B2aSDData, ::G4Step, ::G4TouchableHistory)::Bool. Consult the G4Step reference manual to see what you can get from the G4Step. It returns true if a true hit is generated.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following is a example on how to define a sensitive detector","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"#--------------------------------------------------------------------------------------------------\n#---Define Crystal Sensitive Detector--------------------------------------------------------------\n#--------------------------------------------------------------------------------------------------\n#---SD collected data------------------------------------------------------------------------------\nstruct CrystalSDData <: G4JLSDData\n    hitcollection::Vector{Hit}   # define a hit collection\n    CrystalSDData() = new(Hit[])\nend\n#---Initialize method------------------------------------------------------------------------------\nfunction crystal_initialize(::G4HCofThisEvent, data::CrystalSDData)::Nothing\n    empty!(data.hitcollection)   # empty the hit collection at every event\n    return\nend\n#---Process Hit method-----------------------------------------------------------------------------\nfunction crystal_processHits(step::G4Step, ::G4TouchableHistory, data::CrystalSDData)::Bool\n    part = step |> GetTrack |> GetParticleDefinition\n    part == G4OpticalPhoton && return false \n    edep = step |> GetTotalEnergyDeposit\n    edep <  0. && return false\n    pos = step |> GetPostStepPoint |> GetPosition\n    push!(data.hitcollection, Hit(0., pos, edep, ScintCryst))  # fill the collection with a new Hit\n    return true\nend\n#---Create SD instance-----------------------------------------------------------------------------\nG4JLSensitiveDetector(\"Crystal_SD\", CrystalSDData();           # name an associated data are mandatory\n                       processhits_method=crystal_processHits, # process hist method (also mandatory)\n                       initialize_method=crystal_initialize)   # intialize method","category":"page"},{"location":"#Scoring-meshes","page":"Introduction","title":"Scoring meshes","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The user can also specify scoring meshes to obtain quantities on the defined grid. In Geant4 this is achieved using a set of UI commands. In this Julia interface this functionality has been encapsulated in a number of data structures. The function to create a scoring mesh is G4JLScoringMesh and receive as arguments the the type and dimensions of the mesh, the position, the rotation, the number of bins in each dimension, and the quantities to accumulate with eventually some filter conditions. See for example the scoring mesh from RE03:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"sc1 = G4JLScoringMesh(\"boxMesh_1\",\n                      BoxMesh(1m,1m,1m),\n                      bins = (30, 30, 30),\n                      quantities = [ energyDeposit(\"eDep\")\n                                     nOfStep(\"nOfStepGamma\", filters=[ParticleFilter(\"gammafilter\", \"gamma\")])\n                                     nOfStep(\"nOfStepEMinus\", filters=[ParticleFilter(\"eMinusFilter\", \"e-\")])\n                                     nOfStep(\"nOfStepEPlus\", filters=[ParticleFilter(\"ePlusFilter\", \"e+\")])\n                                   ]\n                      )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The scoring mesh is added into the 'scorersargument when constructing a [G4JLApplication`](@ref). After a run hs been executed, the user can obtain the quantity values (sum, sum2,entries) on the 3D grid just calling by accessing the quantity as an attribute of the scoring mesh. The returned 3D Julia array is shaped to the declared bins. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> beamOn(app,10000)\njulia> sum, sum2, entries = sc1.eDep\njulia> typeof(sum)\nArray{Float64, 3}\n\njulia> typeof(entries)\nArray{Int64, 3}\n\njulia> size(sum)\n(30, 30, 30)","category":"page"},{"location":"#Detector-and-Event-Display","page":"Introduction","title":"Detector and Event Display","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For visualization applications, the user can create an instance of G4JLEventDisplay([settings file]) and give it to the constructor of G4JLApplication in the evtdisplay attribute. The constructor accepts a visualization settings file that will overwrite the default settings in the file Geant4.jl/ext/G4Vis/settings.jl. The format of the settings is Julia NamedTuple. Here is an example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(\n    display = (\n        show_axis = false,\n    ),\n    trajectories = (\n        color = :yellow,\n    ),\n)","category":"page"},{"location":"#Provided-Examples","page":"Introduction","title":"Provided Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Examples are located in a separate repository G4Examples to minimize dependencies for this core package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition, they are documented in this generated documentation. The user can browse the rendered examples in documentation together with the generated output of running them with the current version of the package. At the same time it is possible to download a copy of them as a Jupyter notebook, as Markdownfile and as a plain Julia script.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you want to run them you need to have Julia installed. Then, to setup a proper Julia environment, the user can take the Project.toml that contains the full list of dependencies required for the examples.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To setup the environment:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Place the Project.toml file in the current directory\nExecute julia --project -e 'import Pkg;Pkg.instantiate()' to download and install all required packages. This may take long rthe first time because some of the examples depend of complex and elaborated packages, for example Geant4 itself with all the data files and Makie for the visualization\nNow, you can run the downloaded example julia --project <example.jl>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"List of currently available examples:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"   Pages = Main.examples_mds\n   Depth = 1:1","category":"page"},{"location":"#Building-the-wrapper-code","page":"Introduction","title":"Building the wrapper code","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We use the Geant4 native binary libraries and data from the binary package Geant4_jll, which has been produced with the BinaryBuilder recipe. We will have a new version of the Geant4_jll package for each new release of Geant4.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The wrapper library is downloaded from the binary package Geant4_julia_jll.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We have the possibility during the development of this package, or to add addtional classes, to re-generate locally a new C++ wrapper library. For this, we need to have wrapit installed, which itself requires libclang to be installed. Soon will be available as a Julia package WrapIt.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The configuration file gen/Geant4.wit.in is the input to the automated process. New header files can be added to the input list.\nThe script gen/build.jl does the work of generating the code and building the library. The commands to execute are:\njulia --project=gen -e 'import Pkg; Pkg.instantiate()'\njulia --project=gen gen/build.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once the wrapper code is stabilized we move the generated code to the repository Geant4_cxxwrap to regenerate the binary package Geant4_julia_jll using the BinaryBuilder.","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"EditURL = \"JuliaAction_lit.jl\"","category":"page"},{"location":"examples/JuliaAction/#Calling-G4-actions-in-Julia","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"","category":"section"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"This is a very simple example of calling user actions in Julia from a C++ Geant4 application. We define the user actions in Julia language in the file MyCode.jl and call them from the C++ application. The name and signatures of the functions are important since the C++ will associate them in the corresponding inherited classes.","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"The C++ code is a single file G4example.cpp that defines the Geant4 the minimal set of classes to run a simulation.","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"The main program is responsible of initializing Julia by calling julia_init and loading the Julia code executing.\njl_init()\njl_eval_string(\"include(\\\"MyCode.jl\\\")\");\nEach constructor of a user action class needs to initialize a C++ function pointer to the corresponding Julia function. This is done in the constructor to avoid any dynamic dispatch at runtime. For example, for the EventAction class:\ntypedef  void (*eventaction_f)(const G4Event*);\nclass EventAction : public G4UserEventAction {\n  public:\n    EventAction() {\n        beginevent_jl = (eventaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(begin_of_event_action, Nothing, (CxxPtr{G4Event},))\")));\n        endevent_jl = (eventaction_f)(jl_unbox_voidpointer(jl_eval_string(\"@cfunction(end_of_event_action, Nothing, (CxxPtr{G4Event},))\")));\n    }\n    ...\n  private:\n    eventaction_f beginevent_jl;\n    eventaction_f endevent_jl;\n};\nFinally the actions are called in the corresponding Geant4 classes. For example in the EventAction class:\nvoid EventAction::BeginOfEventAction(const G4Event* event) {\n    beginevent_jl(event);\n}\n...","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"note: Note that\nYou can also download this example as a Jupyter notebook and a plain Julia source file.The C++ code is available as a source file and the Julia code is available as a source file.","category":"page"},{"location":"examples/JuliaAction/#Table-of-contents","page":"Calling G4 actions in Julia","title":"Table of contents","text":"","category":"section"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"Pages = [\"JuliaAction.md\"]\nDepth = 2:3","category":"page"},{"location":"examples/JuliaAction/#Loading-the-necessary-Julia-modules","page":"Calling G4 actions in Julia","title":"Loading the necessary Julia modules","text":"","category":"section"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"using Geant4_jll   # Needed to locate the Geant4 installation directory","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"â”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/JLLWrappers/7Zgw7_8jRdX.so for JLLWrappers [692b3bcd-3c85-4b1f-b108-f13ce0eb3210]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Expat_jll/4P57b_m9y0a.so for Expat_jll [2e619515-83b5-522b-bb60-26c02a35a201]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/NetworkOptions/J8H6s_4x0TT.so for NetworkOptions [ca575930-c2e3-43a9-ace4-1e988b2c1908]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/MbedTLS_jll/u5NEn_4x0TT.so for MbedTLS_jll [c8ffd9c3-330d-5841-b78e-0817d7145fa1]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/LibSSH2_jll/K6mup_4x0TT.so for LibSSH2_jll [29816b5a-b9ab-546f-933c-edad1886dfa8]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/LibGit2_jll/nfCpg_4x0TT.so for LibGit2_jll [e37daf67-58a4-590a-8e99-b0245dd2ffc5]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/LibGit2/xrYJZ_4x0TT.so for LibGit2 [76f85450-5226-5b5a-8eaa-529ad045b433]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/ArgTools/aGHFV_4x0TT.so for ArgTools [0dad84c5-d112-42e6-8d28-ef12dabb789f]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/nghttp2_jll/KTGSA_4x0TT.so for nghttp2_jll [8e850ede-7688-5339-a07c-302acd2aaf8d]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/LibCURL_jll/9JWaY_4x0TT.so for LibCURL_jll [deac9b47-8bc7-5906-a0fe-35ac56dc84c0]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/MozillaCACerts_jll/XKIUi_4x0TT.so for MozillaCACerts_jll [14a3606d-f60d-562e-9121-12d972cd8159]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/LibCURL/ht49g_4x0TT.so for LibCURL [b27032c2-a3e7-50c8-80cd-2d36dbcbfd21]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/Downloads/eiA4B_4x0TT.so for Downloads [f43a241f-c20a-4ad4-852c-f6b1247861c6]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/Tar/G9ZYP_4x0TT.so for Tar [a4e569a6-e804-4fa4-b0f3-eef7a1d5b13e]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/p7zip_jll/dfuGM_4x0TT.so for p7zip_jll [3f19e933-33d8-53b3-aaab-bd5110c3b7a0]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/Pkg/tUTdb_4x0TT.so for Pkg [44cfe95a-1eb2-52ea-b672-e2afdf69b78f]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libXau_jll/S8Fsv_m9y0a.so for Xorg_libXau_jll [0c0b7dd1-d40b-584c-a123-a41640f87eec]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libXdmcp_jll/o7tTX_m9y0a.so for Xorg_libXdmcp_jll [a3789734-cfe1-5b06-b2d0-1dd0d9d62d05]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libpthread_stubs_jll/Ef0AA_m9y0a.so for Xorg_libpthread_stubs_jll [14d82f49-176c-5ed1-bb49-ad3f5cbd8c74]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libxcb_jll/n4mZf_m9y0a.so for Xorg_libxcb_jll [c7cfdc94-dc32-55de-ac96-5a1b8d977c5b]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_xtrans_jll/xYA3D_m9y0a.so for Xorg_xtrans_jll [c5fb5394-a638-5e4d-96e5-b29de1b5cf10]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libX11_jll/KzQhU_m9y0a.so for Xorg_libX11_jll [4f6342f7-b3d2-589e-9d20-edeb45f2b2bc]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libXext_jll/H6ltV_m9y0a.so for Xorg_libXext_jll [1082639a-0dae-5f34-9b06-72781eeb8cb3]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libICE_jll/06LST_m9y0a.so for Xorg_libICE_jll [f67eecfb-183a-506d-b269-f58e52b52d7c]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libSM_jll/A09k2_m9y0a.so for Xorg_libSM_jll [c834827a-8449-5923-a945-d239c165b7dd]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libXt_jll/mjVMq_m9y0a.so for Xorg_libXt_jll [28c4a263-0105-5ca0-9a8c-f4f6b89a1dd4]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xorg_libXmu_jll/ojbMS_m9y0a.so for Xorg_libXmu_jll [6bc1fdef-f8f4-516b-84c1-6f5f86a35b20]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Libglvnd_jll/z0JB7_m9y0a.so for Libglvnd_jll [7e76a0d4-f3c7-5321-8279-8d96eeed0f29]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Xerces_jll/4EQxx_m9y0a.so for Xerces_jll [637d83c4-b86a-5d90-b82d-5cf0573a8cfc]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/Geant4_jll/GKQi4_m9y0a.so for Geant4_jll [872b6946-528a-5ac7-9145-d37eec569368]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Loading object cache file /opt/hostedtoolcache/julia/1.11.2/x64/share/julia/compiled/v1.11/REPLExt/m7ggP_4x0TT.so for REPLExt [e5eb5ef1-03cf-53a7-ae1d-5a66b08e832b]\nâ”” @ Base loading.jl:1244\nâ”Œ Debug: Extension REPLExt of Pkg loaded\nâ”” @ Base loading.jl:1545\nâ”Œ Debug: Loading object cache file /home/runner/.julia/compiled/v1.11/DisplayAs/NC05O_m9y0a.so for DisplayAs [0b91fe84-8a4c-11e9-3e1d-67c38462b6d6]\nâ”” @ Base loading.jl:1244\n","category":"page"},{"location":"examples/JuliaAction/#Building-G4Example-Application","page":"Calling G4 actions in Julia","title":"Building G4Example Application","text":"","category":"section"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"The custom library is defined in the C++ file G4example.cpp. It is a single file to facilitate the building of the executable.","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"The attribute Geant4_jll.artifact_dir provides the path to the Geant4 installation directory. Sources are in the same location as this script.","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"cd(@__DIR__)\ng4prefix = Geant4_jll.artifact_dir\njlprefix = dirname(Sys.BINDIR);","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"We use the executables geant4-config and julia-config.jl to get the needed libraries and compiler/linker flags.","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"g4libs = read(`$g4prefix/bin/geant4-config --libs`, String) |> split\nfilter!(x -> x != \"-lG4gdml\", g4libs)\njllibs = read(`$jlprefix/share/julia/julia-config.jl --ldlibs`, String) |> split\nappend!(jllibs, [\"-L$jlprefix/lib\"])\ncflags = read(`$g4prefix/bin/geant4-config --cflags`, String) |> split\nldflags = [\"-Wl,-rpath,$g4prefix/lib\", \"-Wl,-rpath,$jlprefix/lib\"];\nSys.KERNEL == :Linux  && append!(ldflags, [\"-Wl,--no-as-needed\"]);","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"Run the compilation and link command","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"Base.run(`c++ -O2 -fPIC $cflags -I$jlprefix/include/julia $ldflags $g4libs $jllibs\n          -o G4example.exe $(@__DIR__)/G4example.cpp`).exitcode == 0 || error(\"Compilation failed\");","category":"page"},{"location":"examples/JuliaAction/#Run-the-application","page":"Calling G4 actions in Julia","title":"Run the application","text":"","category":"section"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"We need to set the variable JULIA_PROJECT pointing to correctly setup Julia environment.","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"withenv(\"JULIA_PROJECT\" => \"@.\") do\n   Base.run(`./G4example.exe`).exitcode == 0 || error(\"Execution failed\");\nend","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"true","category":"page"},{"location":"examples/JuliaAction/#Display-the-results","page":"Calling G4 actions in Julia","title":"Display the results","text":"","category":"section"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"println(\"=====> The file edepHist.png should have been saved\")","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"=====> The file edepHist.png should have been saved\n","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"(Image: )","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"","category":"page"},{"location":"examples/JuliaAction/","page":"Calling G4 actions in Julia","title":"Calling G4 actions in Julia","text":"This page was generated using Literate.jl.","category":"page"}]
}
