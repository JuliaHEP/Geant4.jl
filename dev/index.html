<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · Geant4.jl</title><meta name="title" content="Introduction · Geant4.jl"/><meta property="og:title" content="Introduction · Geant4.jl"/><meta property="twitter:title" content="Introduction · Geant4.jl"/><meta name="description" content="Documentation for Geant4.jl."/><meta property="og:description" content="Documentation for Geant4.jl."/><meta property="twitter:description" content="Documentation for Geant4.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="Geant4.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>Geant4.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Geant4-Julia-interface"><span>Geant4 Julia interface</span></a></li><li><a class="tocitem" href="#Provided-Examples"><span>Provided Examples</span></a></li><li><a class="tocitem" href="#Building-the-wrapper-code"><span>Building the wrapper code</span></a></li></ul></li><li><a class="tocitem" href="api/">Public API</a></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/B1/">Basic/B1 Example</a></li><li><a class="tocitem" href="examples/B2a/">Basic/B2a Example</a></li><li><a class="tocitem" href="examples/B2aVis/">Basic/B2a Event Display Example</a></li><li><a class="tocitem" href="examples/B3a/">Basic/B3a Example</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Extended</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/GPS/">Extended/GPS Example</a></li><li><a class="tocitem" href="examples/RE03/">Extended/RE03 Example</a></li><li><a class="tocitem" href="examples/TestEm3/">Extended/TestEm3 Example</a></li><li><a class="tocitem" href="examples/Solids/">Geant4 Solids</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/TPCSim/">Simulation of the Aleph TPC</a></li><li><a class="tocitem" href="examples/HBC30/">CERN Liquid Hydrogen Bubble Chamber</a></li><li><a class="tocitem" href="examples/WaterPhantom/">Water Phantom with Scoring</a></li><li><a class="tocitem" href="examples/UserLib/">Calling Custom C++ library</a></li><li><a class="tocitem" href="examples/JuliaAction/">Calling G4 actions in Julia</a></li></ul></li></ul></li><li><a class="tocitem" href="releases/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaHEP/Geant4.jl/blob/master/docs/src/index.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Geant4.jl"><a class="docs-heading-anchor" href="#Geant4.jl">Geant4.jl</a><a id="Geant4.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Geant4.jl" title="Permalink"></a></h1><p>Julia bindings for the <a href="https://geant4.web.cern.ch">Geant4</a> particle transportation toolkit. It is using <a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap.jl</a> package to wrap C++ types and functions to Julia. Since the Geant4 toolkit is rather large and complex, writing the wrapper code by hand is not really an option. For this we use the package <a href="https://github.com/grasph/wrapit">WrapIt</a> that automates the generation of the wrapper code making use of the clang library.</p><p>Documentation of the concepts and how to write applications with the Geant4 toolkit can be found with the <a href="https://geant4-userdoc.web.cern.ch/UsersGuides/ForApplicationDeveloper/html/index.html">Application Developer Guide</a> or the <a href="https://geant4.kek.jp/Reference/11.1.1/index.html">Classes and Members reference guide</a> for a detailed description of each C++ class. In this document we will only highlight the differences between the Julia and the C++ API. We will document the additional types that have been added on top of the C++ classes to make the user interface more Julia friendly. To distinguish these new types from the types coming directly from C++ via the CxxWrap wrappers, these types are prefixed with <code>G4JL</code>.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The Geant4.jl package does no require any special installation. Stable releases are registered into the Julia general registry, and therefore can be deployed with the standard <code>Pkg</code> Julia package manager.</p><pre><code class="language-julia hljs">julia&gt; using Pkg
julia&gt; Pkg.add(&quot;Geant4&quot;)</code></pre><p>Examples are located in a separate repository <a href="https://github.com/JuliaHEP/G4Examples.jl">G4Examples</a> to minimize dependencies since they use additional functionality such as graphics, plotting, analysis tools, etc. To use and play with the examples, the user can clone the examples repository and setup a complete Julia environment with:</p><pre><code class="language-sh hljs">$ git clone https://github.com/JuliaHEP/G4Examples.jl.git
$ julia --project=G4Examples.jl -e &#39;import Pkg; Pkg.instantiate()&#39;</code></pre><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>Import the <code>Geant4</code> module. All the wrapped Geant4 classes are exported since they are prefixed by <code>G4</code> minimizing the chances of a name clash with other Julia symbols. </p><pre><code class="language-julia-repl hljs">
julia&gt; using Geant4
julia&gt; runManager = G4RunManager()
**************************************************************
 Geant4 version Name: geant4-11-01-patch-01 [MT]   (10-February-2023)
                       Copyright : Geant4 Collaboration
                      References : NIM A 506 (2003), 250-303
                                 : IEEE-TNS 53 (2006), 270-278
                                 : NIM A 835 (2016), 186-225
                             WWW : http://geant4.org/
**************************************************************

Geant4.G4RunManagerAllocated(Ptr{Nothing} @0x00007f9fcb6f9c50)

julia&gt; methodswith(G4RunManager, supertypes=true)
[1] convert(t::Type{G4RunManager}, x::T) where T&lt;:G4RunManager in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:676
[2] AbortEvent(arg1::Union{CxxWrap.CxxWrapCore.CxxRef{&lt;:G4RunManager}, Union{CxxWrap.CxxWrapCore.SmartPointer{T2}, T2} where T2&lt;:G4RunManager}) in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:618
...
[94] rndmSaveThisRun(arg1::Union{CxxWrap.CxxWrapCore.CxxRef{&lt;:G4RunManager}, Union{CxxWrap.CxxWrapCore.SmartPointer{T2}, T2} where T2&lt;:G4RunManager}) in Geant4 at /Users/mato/.julia/packages/CxxWrap/IdOJa/src/CxxWrap.jl:618

julia&gt; v = GetVersionString(runManager)
ConstCxxRef{G4String}(Ptr{G4String} @0x00007ffed34df2d8)

julia&gt; String(v)
&quot; Geant4 version Name: geant4-11-01-patch-01 [MT]   (10-February-2023)&quot;</code></pre><p>Note that class methods are called with the object instance as first argument. In C++ the <code>GetVersionString</code> method would be called as <code>runManager-&gt;GetVersionString()</code> while in Julia it is called as <code>GetVersionString(runManager)</code>. Thanks to the Julia multi-dispatch we do not need to prefix the methods with the module name <code>Geant4.GetVersionString(runManager)</code>, even for very common function names such as <code>mag</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; v = G4ThreeVector(1,2,3)
Geant4.CLHEP!Hep3VectorAllocated(Ptr{Nothing} @0x00007f9fcaf2a710)

julia&gt; mag(v)
3.7416573867739413</code></pre><h2 id="Geant4-Julia-interface"><a class="docs-heading-anchor" href="#Geant4-Julia-interface">Geant4 Julia interface</a><a id="Geant4-Julia-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Geant4-Julia-interface" title="Permalink"></a></h2><p>The main goal for defining a Geant4 application in the Julia interface is to create an instance of the <a href="api/#Geant4.G4JLApplication-Tuple{}"><code>G4JLApplication</code></a> type, where all the needed elements for running a Geant4 application are declared, such as the detector geometry, the physics list, the primary particle generator, the type of run manager, the user actions, etc. </p><p><img src="assets/interfaces.png" alt="Figure"/></p><p>These are the needed elements:</p><ul><li><strong>detector</strong>. An instance of a detector structure inheriting from the abstract type <code>G4JLDetector</code>, in which all the detector parameters are defined. The user should also provide a method specialization of <code>Geant4.getConstructor(::G4JLDetector)::Function</code> to return the Julia function that toolkit needs to call in order to construct the geometry and return the pointer of the &#39;world&#39; physical volume. There is no default.</li><li><strong>field</strong>. An instance of the magnetic field class. The <code>G4JLUniformMagField(...)</code> function provides a uniform magnetic field. See later how to define a custom one.</li><li><strong>simdata</strong>. An instance of the simulation data structure that the program will need to collect during the simulation execution. This mutable structure needs to inherit from the abstract type <code>G4JLSimulationData</code> and is completely user defined with counters, data structures to collect the hits or doses, histograms, etc. The default is an instance of type <code>G4JLNoData</code>.</li><li><strong>nthreads</strong>. Number of worker threads to be used. The default is 0, which means serial mode. Any number &gt; 0 will use the MT functionality of Geant4, and therefore the user would need to pay attention to the user actions that are run concurrently to avoid data races (see <a href="https://docs.julialang.org/en/v1/manual/multi-threading/#Data-race-freedom">Julia doc on multi-threading</a>)</li><li><strong>verbose</strong>. Verbosity level (for physics list). The default is 0.</li><li><strong>physics_type</strong>. The physics list predefined type. Default is <code>FTFP_BERT</code>.</li><li><strong>generator_type</strong>. The primary generator generator type. The default is <code>G4JLParticleGun</code>, which encapsulates a <code>G4ParticleGun</code>. The underlying <code>G4ParticleGun</code> can be obtained by calling <code>GetGun()</code>.</li><li><strong>user actions</strong>. Julia methods defining the different possible user actions (e.g. stepping action, tracking action, run action, event action). The default is no action.</li><li><strong>sdetectors</strong>. List of sensitive detectors. This is given as a <code>Vector</code> of pairs <code>lv::String =&gt; sd::G4JLSensitiveDetector</code> to associate logical volumes by name to sensitive detector instances (see next section).</li><li><strong>scorers</strong>. List of scoring meshes defined with the function <a href="api/#Geant4.G4JLScoringMesh-Union{Tuple{M}, Tuple{String, M}} where M&lt;:Geant4.AbstractMesh"><code>G4JLScoringMesh</code></a>.</li></ul><p>Once the <code>G4JLApplication</code> is instantiated (and implicitly an instance of the <code>G4RunManager</code> created), the user can control the application with the following commands:</p><ul><li><code>configure(::G4JLApplication)</code>. It associates the physics list, generator and user actions to the selected <code>G4RunManager</code> instance. </li><li><code>initialize(::G4JLApplication)</code>. It basically calls the <code>Initialize()</code> method of the run manager and associate the declared sensitive detectors.</li><li><code>reinitialize(::G4JLApplication, ::G4JLDetector)</code>. It re-defines the declared detector geometry with a new instance of <code>G4JLDetector</code>. </li><li><code>beamOn(::G4JLApplication, ::Int)</code>. Starts a run with a given number of events.</li></ul><h3 id="Constructing-the-detector"><a class="docs-heading-anchor" href="#Constructing-the-detector">Constructing the detector</a><a id="Constructing-the-detector-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-detector" title="Permalink"></a></h3><p>Parameters of the detector are collected in a user defined mutable data structure inheriting from <code>G4JLDetector</code>. The user also needs to provide a Julia method for constructing the geometry. This method needs to have following the signature</p><pre><code class="language-julia hljs">&lt;User_Det_Constructor_Function&gt;(::G4JLDetector)::CxxPtr{G4VPhysicalVolume}</code></pre><p>The only argument of the function gives access to the user defined structure with all the detector parameters.</p><div class="admonition is-info" id="Note-f21c6bfd8b503f91"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f21c6bfd8b503f91" title="Permalink"></a></header><div class="admonition-body"><p>The type <code>CxxPtr{G4VPhysicalVolume}</code> denotes a C++ pointer to the <code>G4VPhysicalVolume</code> type.</p></div></div><p>The user can use the native G4 classes for constructing the geometry such as the different type of solids (e.g. G4Box, G4Tubs, etc.), <code>G4LogicalVolume</code>, <code>G4PVPlacement</code>, <code>G4PVReplica</code>, etc. Alternatively, the user can use the type <a href="api/#Geant4.G4JLDetectorGDML-Tuple{String}"><code>G4JLDetectorGDML</code></a> to construct a detector from a GDML file.</p><div class="admonition is-info" id="Note-e45e4849d4e194a8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e45e4849d4e194a8" title="Permalink"></a></header><div class="admonition-body"><p>Note that by default constructed C++ objects from Julia would get automatically deleted by the Julia garbage collector (GC) since a <code>finalizer</code> gets installed to the wrapper classes. This is particularly a problem when constructing the geometry.</p></div></div><p>Currently for the following classes have the <code>finalizer</code> disabled in the wrapper: <code>G4PVPlacement</code>, <code>G4LogicalVolume</code>, <code>G4PVReplica</code>, <code>G4Material</code>, <code>G4Isotope</code>, <code>G4Element</code>. This means that instances of them will not be deleted by Julia to avoid double deletion (often a crash) when the geometry gets deleted at the finalization of the application from the C++ side. </p><p>A pointer to any of the <code>G4Solid</code> needs to be passed to the <code>G4LogicalVolume</code> using <a href="api/#Geant4.move!-Tuple{Any}"><code>move!(objref)</code></a> function to transfer the ownership of the referenced object to the C++ side. See the following example:</p><pre><code class="language-julia hljs">trackerS = G4Tubs(&quot;tracker&quot;, 0, trackerSize, trackerSize, 0, 360deg)
trackerLV = G4LogicalVolume(move!(trackerS), m_air, &quot;Tracker&quot;)
G4PVPlacement(nothing,              # no rotation
    G4ThreeVector(0,0,0),           # at (0,0,0)
    trackerLV,                      # its logical volume
    &quot;Tracker&quot;,                      # its name
    worldLV,                        # its mother  volume
    false,                          # no boolean operations
    0,                              # copy number
    checkOverlaps)                  # checking overlaps</code></pre><h3 id="Physics-List"><a class="docs-heading-anchor" href="#Physics-List">Physics List</a><a id="Physics-List-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-List" title="Permalink"></a></h3><p>The user can provide one of the pre-defined physics lists, such as <code>QGS_BIC</code>, <code>QBBC</code> or <code>FTFP_BERT</code>. Alternatively, the user can define a Julia <code>struct</code><code>as a subtype of</code>G4VUserPhysicsList` and modify some of the physcis in the constructor. For example:</p><pre><code class="language-julia hljs">struct ScintPhysicsList &lt;: G4VUserPhysicsList
    function ScintPhysicsList(verbose)
        pl = FTFP_BERT(verbose)
        # replace G4EmStandardPhysics
        ReplacePhysics(pl, move!(G4EmStandardPhysics_option4(verbose)))
        # register G4OpticalPhysics
        RegisterPhysics(pl, move!(G4OpticalPhysics(verbose)))
        # activate  scintillation
        optpar = G4OpticalParameters!Instance()
        SetProcessActivation(optpar, &quot;Scintillation&quot;, true)
        # activate cherenkov radiation
        SetProcessActivation(optpar, &quot;Cerenkov&quot;, true)
        return pl
    end 
end</code></pre><h3 id="Magnetic-field"><a class="docs-heading-anchor" href="#Magnetic-field">Magnetic field</a><a id="Magnetic-field-1"></a><a class="docs-heading-anchor-permalink" href="#Magnetic-field" title="Permalink"></a></h3><p>The user can define either an uniform magnetic field or a custom one. To define an custom one:</p><ul><li>define first a user structure for the parameters that inherits from the abstract type <code>G4JLFieldData</code></li><li>then, define a function with the signature <code>(result::G4ThreeVector, position::G4ThreeVector, params::G4JLFieldData)::Nothing</code></li><li>and finally, with all this, instantiate the magnetic field calling the function <pre><code class="nohighlight hljs">  G4JLMagneticField(&lt;name&gt;, &lt;data&gt;; getfield_method=&lt;function&gt;)</code></pre></li></ul><h3 id="Primary-Particle-Generator"><a class="docs-heading-anchor" href="#Primary-Particle-Generator">Primary Particle Generator</a><a id="Primary-Particle-Generator-1"></a><a class="docs-heading-anchor-permalink" href="#Primary-Particle-Generator" title="Permalink"></a></h3><p>The user can define either a custom primary particle generator or use one of the two defined ones:</p><ul><li><p><strong>G4JLGunGenerator</strong>. Uses the <code>G4ParticleGun</code> class of Geant4 that generates a single particle type with a fix kinetic energy, position and direction.</p><pre><code class="language-julia hljs">G4JLGunGenerator(particle = &quot;proton&quot;, 
                 energy = 3GeV, 
                 direction = G4ThreeVector(0,0,1), 
                 position = G4ThreeVector(0,0,-2940.0))</code></pre></li><li><p><strong>G4JLGeneralParticleSource</strong>. Uses the <code>G4GeneralParticleSource</code> class of Geant4 to generate one of more sources of primary particles with predefined distributions for energy, position and direction. An example can be:</p><pre><code class="language-julia hljs">src1 = (particle=&quot;e+&quot;, intensity=0.5,
        ene=(type=&quot;Exp&quot;, min=2MeV, max=10MeV, ezero=2.),
        pos=(type=&quot;Plane&quot;, shape=&quot;Circle&quot;, centre=G4ThreeVector(1cm,2cm,0cm), radius=3cm),
        ang=(type=&quot;cos&quot;, mintheta=0deg, maxtheta=180deg))
src2 = (particle=&quot;gamma&quot;, intensity=0.5,
        ene=(type=&quot;Brem&quot;, min=2MeV, max=10MeV, temp=2e12),
        pos=(type=&quot;Plane&quot;, shape=&quot;Ellipse&quot;, centre=G4ThreeVector(3cm,1cm,0cm), halfx=1cm, halfy=2cm),
        ang=(type=&quot;iso&quot;, mintheta=0deg, maxtheta=180deg))
gps = G4JLGeneralParticleSource(sources = [ src1, src2 ])</code></pre><p>the standard particle gun parameters works as well:</p><pre><code class="language-julia hljs">G4JLGeneralParticleSource(particle = &quot;proton&quot;, 
                          energy = 3GeV, 
                          direction = G4ThreeVector(0,0,1), 
                          position = G4ThreeVector(0,0,0))</code></pre></li><li><p><strong>Custom Generator</strong>. It is fairly simple to write a custom generator. It is needed to define a structure for the parameters to configure the generator, and a two functions to initialize and generate the primary particles called for each event. Here is an example:</p><pre><code class="language-julia hljs"># define the data structure with the generator parameters
mutable struct PlaneSourceData &lt;: G4JLGeneratorData
  particleName::String
  particlePtr::CxxPtr{G4ParticleDefinition}
  energy::Float64 
  halfx::Float64
  halfy::Float64
  position::G4ThreeVector
  direction::G4ThreeVector
end

# define the constructor with the default parameters
function PlaneSource(;particle=&quot;gamma&quot;, energy=0.07MeV, halfx=7cm, halfy=7cm, 
                                      position=G4ThreeVector(0,0,-14.9cm), direction=G4ThreeVector(0,0,1))
  data = PlaneSourceData(particle, CxxPtr{G4ParticleDefinition}(C_NULL), energy, halfx, halfy, position, direction)
  function init(data:: PlaneSourceData, app::G4JLApplication)
      data.particlePtr = FindParticle(data.particleName)
  end
  function generate( evt::G4Event, data:: PlaneSourceData)::Nothing
      mass = data.particlePtr |&gt; GetPDGMass
      momentum = √((mass + data.energy)^2 - mass^2)
      pvec = momentum * data.direction
      pos = data.position + G4ThreeVector( data.halfx * (rand() - 0.5),  data.halfy * (rand() - 0.5), 0)
      primary = G4PrimaryParticle(data.particlePtr, pvec |&gt; x, pvec |&gt; y, pvec |&gt; z )
      vertex = G4PrimaryVertex(pos, 0ns)
      SetPrimary(vertex, move!(primary))    # note that we give up ownership of the objects just created
      AddPrimaryVertex(evt, move!(vertex))  # note that we give up ownership of the objects just created
  end
  G4JLPrimaryGenerator(&quot;PlaneSource&quot;, data; init_method=init, generate_method=generate)
end</code></pre></li></ul><h3 id="User-Actions"><a class="docs-heading-anchor" href="#User-Actions">User Actions</a><a id="User-Actions-1"></a><a class="docs-heading-anchor-permalink" href="#User-Actions" title="Permalink"></a></h3><p>User actions are native Julia functions that are callbacks of the Geant4 toolkit. They are declared in the constructor of <code>G4JLApplication</code>, so they do not need to be associated to a specific function name. All user actions receive a reference to the <code>G4JLApplication</code> from which the user can obtain details of the actual application, such as the current detector, the physics, the generator, or the running simulation data. There are the available attributes of the application instance:</p><pre><code class="language-julia hljs">    runmanager::G4RunManager    # The C++ G4RunManager instance
    detector::DET               # User defined detector structure with all parameters
    simdata::Vector{DAT}        # User defined simulation data structs (each worker has its own)
    physics::G4VUserPhysicsList # Physics List
    generator::G4JLPrimaryGenerator # Primary particle generator
    field::Union{G4Field, G4JLMagneticField} # Magnetic field instance
    evtdisplay::G4JLDisplay     # Event display instance
    nthreads::Int32             # number of worker threads
    verbose::Int32              # verbosity level for physics lists
    sdetectors::Dict{String,Vector{G4JLSensitiveDetector}} # dictionary of sensitive detectors
    scorers::Vector{G4JLScoringMesh} # vector of scoring meshes</code></pre><p>The following are the currently defined possible user actions:</p><ul><li><strong>stepping action</strong>. Called on each simulation step. The signature is <code>(::G4Step, ::G4JLApplication)::Nothing</code>. Consult the <a href="https://geant4.kek.jp/Reference/11.1.1/classG4Step.html">G4Step</a> reference manual to see what you can get from it. </li><li><strong>pre-tracking action</strong>. Called at the creation of a new participle being tracked. The signature is <code>(::G4Track, ::G4JLApplication)::Nothing</code>. Consult the <a href="https://geant4.kek.jp/Reference/11.1.1/classG4Track.html">G4Step</a> reference manual to see what you can get from it.</li><li><strong>post-tracking action</strong>. Called at the end of the particle being tracked. The signature is <code>(::G4Track, ::G4JLApplication)::Nothing</code>. Consult the <a href="https://geant4.kek.jp/Reference/11.1.1/classG4Track.html">G4Track</a> reference manual to see what you can get from it.</li><li><strong>begin-event action</strong>. Called at the beginning of each event. The signature is <code>(::G4Event, ::G4JLApplication)::Nothing</code>. Consult the <a href="https://geant4.kek.jp/Reference/11.1.1/classG4Event.html">G4Event</a> reference manual to see what you can get from it.</li><li><strong>end-event action</strong>. Called at the end of each event. The signature is <code>(::G4Event, ::G4JLApplication)::Nothing</code>. Consult the <a href="https://geant4.kek.jp/Reference/11.1.1/classG4Event.html">G4Event</a> reference manual to see what you can get from it.</li><li><strong>begin-run action</strong>. Called at the beginning of a run. The signature is <code>(::G4Run, ::G4JLApplication)::Nothing</code>. Consult the <a href="https://geant4.kek.jp/Reference/11.1.1/classG4Run.html">G4Run</a> reference manual to see what you can get from it.</li><li><strong>end-run action</strong>. Called at the end of a run. The signature is <code>(::G4Run, ::G4JLApplication)::Nothing</code>. Consult the <a href="https://geant4.kek.jp/Reference/11.1.1/classG4Run.html">G4Run</a> reference manual to see what you can get from it.</li></ul><h3 id="Sensitive-Detectors"><a class="docs-heading-anchor" href="#Sensitive-Detectors">Sensitive Detectors</a><a id="Sensitive-Detectors-1"></a><a class="docs-heading-anchor-permalink" href="#Sensitive-Detectors" title="Permalink"></a></h3><p>The user can define sensitive detectors by defining a data structure and 3 callback functions, which will initialize, fill and dispose the defined data structure. Later, the instantiated sensitive detector would be associated to one or more logical volumes of the detector setup. Instantiating a <code>G4JLSensitiveDetector</code> will require the following arguments:</p><ul><li><strong>name</strong>. A string to identify the sensitive detector. No default.</li><li><strong>sd data</strong>. A instance of a user defined <code>G4JLSDData</code> mutable data structure that will passed to each callback invocation.</li><li><strong>initialize method</strong>. User method that is called at the beginning of each event. The signature is <code>(::B2aSDData, ::G4HCofThisEvent)::Nothing</code>.</li><li><strong>endOfEvent method</strong>. User method that is called at the end of each event. The signature is <code>(::B2aSDData, ::G4HCofThisEvent)::Nothing</code>.</li><li><strong>processHits method</strong>. User method that is called at simulation step that ends at the associated logical volume. The signature is <code>(::B2aSDData, ::G4Step, ::G4TouchableHistory)::Bool</code>. Consult the <a href="https://geant4.kek.jp/Reference/11.1.1/classG4Step.html">G4Step</a> reference manual to see what you can get from the G4Step. It returns true if a true hit is generated.</li></ul><p>The following is a example on how to define a sensitive detector</p><pre><code class="language-julia hljs">#--------------------------------------------------------------------------------------------------
#---Define Crystal Sensitive Detector--------------------------------------------------------------
#--------------------------------------------------------------------------------------------------
#---SD collected data------------------------------------------------------------------------------
struct CrystalSDData &lt;: G4JLSDData
    hitcollection::Vector{Hit}   # define a hit collection
    CrystalSDData() = new(Hit[])
end
#---Initialize method------------------------------------------------------------------------------
function crystal_initialize(::G4HCofThisEvent, data::CrystalSDData)::Nothing
    empty!(data.hitcollection)   # empty the hit collection at every event
    return
end
#---Process Hit method-----------------------------------------------------------------------------
function crystal_processHits(step::G4Step, ::G4TouchableHistory, data::CrystalSDData)::Bool
    part = step |&gt; GetTrack |&gt; GetParticleDefinition
    part == G4OpticalPhoton &amp;&amp; return false 
    edep = step |&gt; GetTotalEnergyDeposit
    edep &lt;  0. &amp;&amp; return false
    pos = step |&gt; GetPostStepPoint |&gt; GetPosition
    push!(data.hitcollection, Hit(0., pos, edep, ScintCryst))  # fill the collection with a new Hit
    return true
end
#---Create SD instance-----------------------------------------------------------------------------
G4JLSensitiveDetector(&quot;Crystal_SD&quot;, CrystalSDData();           # name an associated data are mandatory
                       processhits_method=crystal_processHits, # process hist method (also mandatory)
                       initialize_method=crystal_initialize)   # intialize method</code></pre><h3 id="Scoring-meshes"><a class="docs-heading-anchor" href="#Scoring-meshes">Scoring meshes</a><a id="Scoring-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Scoring-meshes" title="Permalink"></a></h3><p>The user can also specify scoring meshes to obtain quantities on the defined grid. In Geant4 this is achieved using a set of UI commands. In this Julia interface this functionality has been encapsulated in a number of data structures. The function to create a scoring mesh is <a href="api/#Geant4.G4JLScoringMesh-Union{Tuple{M}, Tuple{String, M}} where M&lt;:Geant4.AbstractMesh"><code>G4JLScoringMesh</code></a> and receive as arguments the the type and dimensions of the mesh, the position, the rotation, the number of bins in each dimension, and the quantities to accumulate with eventually some filter conditions. See for example the scoring mesh from RE03:</p><pre><code class="language-julia hljs">sc1 = G4JLScoringMesh(&quot;boxMesh_1&quot;,
                      BoxMesh(1m,1m,1m),
                      bins = (30, 30, 30),
                      quantities = [ energyDeposit(&quot;eDep&quot;)
                                     nOfStep(&quot;nOfStepGamma&quot;, filters=[ParticleFilter(&quot;gammafilter&quot;, &quot;gamma&quot;)])
                                     nOfStep(&quot;nOfStepEMinus&quot;, filters=[ParticleFilter(&quot;eMinusFilter&quot;, &quot;e-&quot;)])
                                     nOfStep(&quot;nOfStepEPlus&quot;, filters=[ParticleFilter(&quot;ePlusFilter&quot;, &quot;e+&quot;)])
                                   ]
                      )</code></pre><p>The scoring mesh is added into the &#39;scorers<code>argument when constructing a [</code>G4JLApplication`](@ref). After a run hs been executed, the user can obtain the quantity values (sum, sum2,entries) on the 3D grid just calling by accessing the quantity as an attribute of the scoring mesh. The returned 3D Julia array is shaped to the declared bins. </p><pre><code class="language-julia-repl hljs">julia&gt; beamOn(app,10000)
julia&gt; sum, sum2, entries = sc1.eDep
julia&gt; typeof(sum)
Array{Float64, 3}

julia&gt; typeof(entries)
Array{Int64, 3}

julia&gt; size(sum)
(30, 30, 30)</code></pre><h3 id="Detector-and-Event-Display"><a class="docs-heading-anchor" href="#Detector-and-Event-Display">Detector and Event Display</a><a id="Detector-and-Event-Display-1"></a><a class="docs-heading-anchor-permalink" href="#Detector-and-Event-Display" title="Permalink"></a></h3><p>For visualization applications, the user can create an instance of <code>G4JLEventDisplay([settings file])</code> and give it to the constructor of <code>G4JLApplication</code> in the <code>evtdisplay</code> attribute. The constructor accepts a visualization settings file that will overwrite the default settings in the file <a href="https://github.com/JuliaHEP/Geant4.jl/blob/master/ext/G4Vis/settings.jl">Geant4.jl/ext/G4Vis/settings.jl</a>. The format of the settings is Julia <code>NamedTuple</code>. Here is an example:</p><pre><code class="language-julia hljs">(
    display = (
        show_axis = false,
    ),
    trajectories = (
        color = :yellow,
    ),
)</code></pre><h2 id="Provided-Examples"><a class="docs-heading-anchor" href="#Provided-Examples">Provided Examples</a><a id="Provided-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Provided-Examples" title="Permalink"></a></h2><p>Examples are located in a separate repository <a href="https://github.com/JuliaHEP/G4Examples.jl">G4Examples</a> to minimize dependencies for this core package.</p><p>In addition, they are documented in this generated documentation. The user can browse the rendered examples in documentation together with the generated output of running them with the current version of the package. At the same time it is possible to download a copy of them as a <code>Jupyter notebook</code>, as <code>Markdown</code>file and as a plain <code>Julia script</code>.</p><p>If you want to run them you need to have Julia <a href="https://julialang.org/downloads/">installed</a>. Then, to setup a proper Julia environment, the user can take the <a href="https://github.com/JuliaHEP/Geant4.jl/blob/master/docs/Project.toml"><code>Project.toml</code></a> that contains the full list of dependencies required for the examples.</p><p>To setup the environment:</p><ul><li>Place the <code>Project.toml</code> file in the current directory</li><li>Execute <code>julia --project -e &#39;import Pkg;Pkg.instantiate()&#39;</code> to download and install all required packages. This may take long rthe first time because some of the examples depend of complex and elaborated packages, for example <code>Geant4</code> itself with all the data files and <code>Makie</code> for the visualization</li><li>Now, you can run the downloaded example <code>julia --project &lt;example.jl&gt;</code></li></ul><p>List of currently available examples:</p><ul><li><a href="examples/B1/#Basic/B1-Example">Basic/B1 Example</a></li><li><a href="examples/B2a/#Basic/B2a-Example">Basic/B2a Example</a></li><li><a href="examples/B2aVis/#Basic/B2a-Event-Display-Example">Basic/B2a Event Display Example</a></li><li><a href="examples/B3a/#Basic/B3a-Example">Basic/B3a Example</a></li><li><a href="examples/GPS/#Extended/GPS-Example">Extended/GPS Example</a></li><li><a href="examples/RE03/#Extended/RE03-Example">Extended/RE03 Example</a></li><li><a href="examples/TestEm3/#Extended/TestEm3-Example">Extended/TestEm3 Example</a></li><li><a href="examples/Solids/#Geant4-Solids">Geant4 Solids</a></li><li><a href="examples/TPCSim/#Simulation-of-the-Aleph-TPC">Simulation of the Aleph TPC</a></li><li><a href="examples/HBC30/#CERN-Liquid-Hydrogen-Bubble-Chamber">CERN Liquid Hydrogen Bubble Chamber</a></li><li><a href="examples/WaterPhantom/#Water-Phantom-with-Scoring">Water Phantom with Scoring</a></li><li><a href="examples/UserLib/#Calling-Custom-C-library">Calling Custom C++ library</a></li><li><a href="examples/JuliaAction/#Calling-G4-actions-in-Julia">Calling G4 actions in Julia</a></li></ul><h2 id="Building-the-wrapper-code"><a class="docs-heading-anchor" href="#Building-the-wrapper-code">Building the wrapper code</a><a id="Building-the-wrapper-code-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-wrapper-code" title="Permalink"></a></h2><p>We use the Geant4 native binary libraries and data from the binary package <a href="https://github.com/JuliaBinaryWrappers/Geant4_jll.jl">Geant4_jll</a>, which has been produced with the <code>BinaryBuilder</code> <a href="https://github.com/JuliaPackaging/Yggdrasil/tree/master/G/Geant4">recipe</a>. We will have a new version of the <code>Geant4_jll</code> package for each new release of Geant4.</p><p>The wrapper library is downloaded from the binary package <a href="https://github.com/JuliaBinaryWrappers/Geant4_julia_jll.jl">Geant4_julia_jll</a>.</p><p>We have the possibility during the development of this package, or to add addtional classes, to re-generate locally a new C++ wrapper library. For this, we need to have <a href="https://github.com/grasph/wrapit"><code>wrapit</code></a> installed, which itself requires <code>libclang</code> to be installed. Soon will be available as a Julia package <code>WrapIt.jl</code>.</p><ul><li>The configuration file <code>gen/Geant4.wit.in</code> is the input to the automated process. New header files can be added to the input list.</li><li>The script <code>gen/build.jl</code> does the work of generating the code and building the library. The commands to execute are:<pre><code class="nohighlight hljs">julia --project=gen -e &#39;import Pkg; Pkg.instantiate()&#39;
julia --project=gen gen/build.jl</code></pre></li></ul><p>Once the wrapper code is stabilized we move the generated code to the repository <a href="https://github.com/peremato/Geant4_cxxwrap">Geant4_cxxwrap</a> to regenerate the binary package <code>Geant4_julia_jll</code> using the <code>BinaryBuilder</code>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">Public API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Thursday 19 June 2025 07:35">Thursday 19 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
